# 1.创建`GDT`表及其表项

## 1.1 系统架构

![image-20250413141553927](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250413141553927.png)

​	`GDT`是一个配置表，里面存储了有关存储访问相关的配置信息，也即`x86-32`位最核心的配置数据。在进入保护模式后，所有有关内存访问操作，都需要经过`GDT`,`GDT`中每项称为段描述符(Segment descriptors)。其具体格式如下：

![image-20250413141632276](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250413141632276.png)

​	大体分为三部分：

- `base addr`(基地址)
- `limit`(界限)
- `attr`(属性)

​	整个`GDT`表最大位`64KB`，每个表项为`8`字节，所以表项数最大为`8192`个。

​	在`GDT`表设置好以后，需要通过`lgdt()`来将该表的信息加载到`GDTR`寄存器中。`GDTR`是一个48位寄存器，包含`limit`和`base`两部分，如下图所示：

![image-20250413142157420](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250413142157420.png)

​	其中`base address`是`32`位，`limit`是`16`位。`limit`保存的`GDT`表项的字节大小，当其值为`0`时，表示其字节数为`1`；当`GDT`表项的数量为`N`时，`limit`的值设置成`8 * N - 1`。

> **全局描述符表GDT（Global Descriptor Table）**在整个系统中，全局描述符表GDT只有一张(一个处理器对应一个GDT)，GDT可以被放在内存的任何位置，但CPU必须知道GDT的入口，也就是基地址放在哪里，Intel的设计者门提供了一个**寄存器[GDTR](https://zhida.zhihu.com/search?content_id=2533962&content_type=Article&match_order=1&q=GDTR&zhida_source=entity)**用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过**[LGDT指令](https://zhida.zhihu.com/search?content_id=2533962&content_type=Article&match_order=1&q=LGDT指令&zhida_source=entity)**将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。GDTR中存放的是GDT在内存中的基地址和其表长界限。

https://zhuanlan.zhihu.com/p/25867829

# 2.保护模式下的内存管理简介

## 2.1 IA32内存管理机制概览

​	IA32将内存管理分为两部分：段式存储和页式存储，目前我们只考虑段式存储。由于这种处理，所以得出三种类型的地址：逻辑地址、线性地址、物理地址。

- 物理地址：实际的物理内存中的地址
- 逻辑地址：使用段+偏移表示的地址
- 线性地址：将段+偏移进行转换后的地址，也是我们程序中所使用的地址。如果分页机制未开启，则线性地址=物理地址。

其中段式存储特点如下：

- 将线性地址空间转变成多个段（segments）
- 每个段带有相关的保护机制
- 有多种类型的段：数据、代码、栈、门、tss
- 使用的地址为逻辑地址，即段选择子+偏移

页式存储的特点如下：

- 将线性地址转换为逻辑地址
- 在较小的内存上实现更大的虚拟内容
- 按需加载等功能

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1652416187360-c31dfce7-c4ec-4457-bca1-8dfef1a1aaa0.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

## 2.2平坦模型

​	`IA32`中段式存储比较复杂，本项目使用的是基础平坦模型，特点如下：

- 只使用了两个段：代码段和数据段
- 段起始地址均为0，大小为`4GB`。即不管实际有没有那么大的内存空间，都设置成那么大。访问不存在的区域会产生保护异常。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1652416508631-2b1e37da-6073-4c50-9330-35c305845446.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

​	即采用上述模型中，我们不使用`limit`界限检查，也不使用段的基地址功能，这样程序处理会更为简单。

## 2.3 逻辑地址到线性地址的转换

​	在程序进行内存访问时，会进行逻辑地址的转换，转换到线性地址（暂不考虑分页机制)，转换过程如下：

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1652416852346-a8f794d7-c8cb-4973-807e-9d454a390283.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

# 3.重新加载GDT

## 3.1GDT表格式

![image-20250413145202154](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250413145202154.png)

以下仅界限表项的属性部分：

- S：1-代码段或数据段，0 - 系统段
- DPL：特权级，取值0-3
- P：段是否存在，1存在，0不存在
- D/B：指示代码或栈的大小是32位还是16位，1 - 32位，0-16位
- G：段界限的单位。1 - 界限的单位是4KB，0 - 字节。
- L和AVL：我们不没有用到，使用0即可。
- type：见下表，用于描述段的具体类型

![image-20250413145419137](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250413145419137.png)

`GDT`表类型

```c
typedef struct _segment_desc_t
{
    uint16_t limit15_0;
    uint16_t base15_0;
    uint8_t base23_16;
    uint16_t attr;
    uint8_t base31_24;
} segment_desc_t;
```

相关属性部分：

`/code/source/kernel/include/os_cfg.h`

```c
#define KELNER_SELECTOR_CS (1 * 8)   // 内核代码段描述符
#define KELNER_SELECTOR_DS (2 * 8)   // 内核数据段描述符
#define KERNEL_STACK_SIZE (8 * 1024) // 内核栈
```

`/code/source/kernel/include/cpu/cpu.h`

```c
#define SEG_G (1 << 15)        // 段界限的单位。1 - 界限的单位是4KB，0 - 字节。
#define SEG_D (1 << 14)        // 指示代码或栈的大小是32位还是16位，1 - 32位，0-16位
#define SEG_P_PRESENT (1 << 7) // 段是否存在，1存在，0不存在

#define SEG_DPL0 (0 << 5) // 特权级0
#define SEG_DPL3 (3 << 5) // 特权级3

#define SEG_S_SYSTEM (0 << 4) // 是否位系统段,如调用门或者中断
#define SEG_S_NORMAL (1 << 4) // 普通的代码段或数据段

#define SEG_TYPE_CODE (1 << 3) // 指定其为代码段
#define SEG_TYPE_DATA (0 << 3) // 指定其为数据段
#define SEG_TYE_RW (1 << 1)    // 是否可写可读,不设置为只读
```

设置GDT表项：

```c
void segment_desc_set(int selector, uint32_t base, uint32_t limit, uint16_t attr)
{
    segment_desc_t *desc = gdt_table + (selector >> 3);

    // 如果界限比较长，将长度单位换成4KB
    if (limit > 0xFFFFF)
    {
        attr |= 0x8000;
        limit /= 0x1000;
    }

    desc->limit15_0 = limit & 0xFFFF;
    desc->base15_0 = base & 0xFFFF;
    desc->base23_16 = (base >> 16) & 0xFF;
    desc->attr = attr | (((limit >> 16) & 0xF) << 8);
    desc->base31_24 = (base >> 24) & 0xFF;
}
```



## 3.2 GDTR寄存器

​	使用LGDT指令，可以将GDT表相关的信息加载到GDTR寄存器中。后续对寄存器的访问，都会通过其指向的GDT表。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1652420955398-2d727ad4-6259-418e-ac13-13e8ecb8f48a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_11%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

​	在重新设置后，需要使用`jmp$` 选择子, `$offset`跳转。有的同学认为，可以不跳转，因为`CS`的值为8，新表中代码段描述符对应的选择子也为8，二者相等，无需跳转。

​	之所以要重新跳转，是为了使`CS`寄存器重新加载新`GDT`表中相应的信息。如下图所求，`CS`寄存器除了保存选择子信息外，还会在内部自动保存从GDT表中加载的基地址、界限、属性等相关信息。当使用`jmp $`选择子, `$offset`进行跳转后，`CS`将从新表中加载新的信息，这样就避免了仍然使用原来的信息。所以，最好是重新加载，以使用新的信息。

![image-20250413145749666](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250413145749666.png)	

​	当然，在目前的工程中，由于新表中代码段相关的信息和旧表中的相同，所以不重新加载也不影响程序的运行。

> 在该部分实现中由于`_segment_desc_t`的定义时未设置结构体按1字节对齐导致qemu运行到`/code/source/init/start.S`中`jmp $KERBEL_SELECTOR_CS,$gdt_reload`后qemu重启
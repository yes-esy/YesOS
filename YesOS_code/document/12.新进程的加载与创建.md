# 1.实现fork()系统调用

## 1.1添加调用接口

​	`fork()`其函数的功能为：创建一个与当前进程几乎完全一样的子进程。子进程从父进程继承代码、数据、堆栈等资源的副本，并拥有独立的地址空间和进程ID（`PID`）。

![image-20250701214837537](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250701214837537.png)

> **在父进程中，fork返回新创建子进程的进程ID；**
>
> **在子进程中，fork返回0；**
>
> **如果出现错误，fork返回一个负值；**

​	添加相关接口，具体实现如下：

```c
/**
 * @brief        : 创建子进程的系统调用接口
 * @return        {int} : 子进程的PID
**/
static inline int fork()
{
    syscall_args_t args;
    args.id = SYS_fork;
    sys_call(&args);
}
```

​	在系统调用表中添加该接口：`  [SYS_fork] = (sys_handler_t)sys_fork`

```c
int sys_fork(void)
{
	return -1;
}
```

## 1.2 分配任务块

​	添加用户进程表，通过分配表来分配`task_t`以及释放。

```c
static task_t task_table[TASK_NR];  // 用户进程表
static mutex_t task_table_mutex;    // 进程表互斥访问锁
```

​	并在初始化任务管理器时对进程表及互斥锁进行初始化。

```c
/**
 * @brief        : 初始化任务(进程)管理器,包括初始化就绪,延时,进程队列,初始化空闲进程,将当前进程设为null
 * @return        {*}
 **/
void task_manager_init(void)
{   
    kernel_memset((void *)task_table, 0, sizeof(task_table));
    mutex_init(&task_table_mutex);
    //...原有代码
}
```

​	实现进程的分配和释放

```c
static task_t *alloc_task(void)
{
    task_t *task = (task_t *)0;
    mutex_lock(&task_table_mutex);
    for (int i = 0; i < TASK_NR; i++) // 寻找空闲表项
    {
        task_t *curr = task_table + i;
        if (curr->name[0] == 0) // 空闲进程
        {
            task = curr;
            break;
        }
    }
    mutex_unlock(&task_table_mutex);
    return task;
}
/**
 * @brief        : 释放一个进程
 * @param         {task_t} *task: 需要释放的进程的指针
 * @return        {void}
 **/
static void free_task(task_t *task)
{
    mutex_lock(&task_table_mutex);
    task->name[0] = '\0';
    mutex_unlock(&task_table_mutex);
}
```

​	修改`task_t`添加父进程字段`  struct _task_t *parent; `并在`task_init()`时初始化为0

## 1.3 初始化任务块

​	获取当前进程，为其分配一个子进程。当前进程的栈空间的栈顶指针`esp0`减去一个系统调用栈帧的大小即可获取到该栈帧的起始地址，从而获取父进程的的运行状态信息，用于初始化子进程。

![image-20250704150138132](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250704150138132.png)



```c
/**
 * @brief        : 为当前进程创建一个子进程
 * @return        {int} : 子进程PID号
 **/
int sys_fork(void)
{
    task_t *parent_task = task_current(); // 当前进程为父进程
    task_t *child_task = alloc_task();    // 分配子进程
    if (child_task == (task_t *)0)
    {
        goto fork_failed;
    }
    syscall_frame_t *frame = (syscall_frame_t *)(parent_task->tss.esp0 - sizeof(syscall_frame_t));                          // 父进程的栈信息(寄存器)
        int err = task_init(child_task, parent_task->name, 0, frame->eip, frame->esp + sizeof(uint32_t) * SYSCALL_PARAM_COUNT); // 初始化子进程,跳过手动压入的参数
    tss_t *tss = &child_task->tss; // 子进程的tss
    tss->eax = 0;                  // 子进程返回值
    tss->ebx = frame->ebx;
    tss->ecx = frame->ecx;
    tss->edx = frame->edx;
    tss->esi = frame->esi;
    tss->ebp = frame->ebp;
    tss->edi = frame->edi;
    tss->cs = frame->cs;
    tss->ds = frame->ds;
    tss->es = frame->es;
    tss->fs = frame->fs;
    tss->gs = frame->gs;
    tss->eflags = frame->eflags;
    child_task->parent = parent_task; // 设置子进程的父进程
    tss->cr3=parent_task->tss.cr3 // 暂时一样
    task_start(child_task);
    return child_task->pid; // 返回子进程pid给父进程

fork_failed:
    if (child_task)
    {
        task_uninit(child_task);
        free_task(child_task);
    }
    return -1;
}
```

​	分配失败需要反初始化，以及相关资源释放。

```c
/**
 * @brief        : 反初始化
 * @param         {task_t *} task: 进行反初始化的进程的指针
 * @return        {void}
 **/
void task_uninit(task_t *task)
{
    if (task->tss_sel) // 选择子有效
    {
        gdt_free_sel(task->tss_sel);
    }

    if (task->tss.esp0) // 以分配特权级为0的栈
    {
        memory_free_page(task->tss.esp - MEM_PAGE_SIZE); // 从起始地址开始
    }

    if (task->tss.cr3) // 释放页表
    {
        memory_destory_uvm(task->tss.cr3);
    }

    kernel_memset(task, 0, sizeof(task)); // 清空该任务
}
```

## 1.4 复制进程地址空间

​	在为子进程创建用户地址空间时，只需要扫描父进程中`0x80000000`以上存在隐射的地址区域，进行类似映射。

![image-20250704152936339](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250704152936339.png)

​	在为子进程创建用户地址空间时，由于共用同一页表，所以实际所用的存储空间完全一页，会导致冲突。

> 父进程先运行，会将一些已经压栈的信息弹出，破坏了原有的栈，父子进程共用同一块内存空间，故子进程无法运行下去。

​	![image-20250704153527751](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250704153527751.png)

 	单独为子进程分配页表，将父进程的页表中的内容拷贝到子进程新创建的页表中。

```c
/**
 * @brief        : 返回页表表项的属性 
 * @param         {pte_t} *pte: 页表表项的指针
 * @return        {uint32_t} : 页表表项的权限
**/
static inline uint32_t get_pte_perm(pte_t *pte)
{
    return (pte->v & 0x1FF);
}
/**
 * @brief        : 释放页目录表及其映射关系
 * @param         {uint32_t} page_dir: 需要释放的页目录表的物理地址
 * @return        {void}
 **/
void memory_destory_uvm(uint32_t page_dir)
{
    uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE); // pde表项索引
    pde_t *pde = (pde_t *)(page_dir + user_pde_start);     // 得到原一级页目录表项
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++)
    {
        if (!pde->present) // 页目录表项不存在
        {
            continue;
        }
        pte_t *pte = (pte_t *)pde_paddr(pde);    // 取出页表物理地址
        for (int j = 0; j < PTE_CNT; j++, pte++) // 遍历页表
        {
            if (!pte->present) // 页表项不存在
            {
                continue;
            }
            addr_free_page(&paddr_alloc, pte_paddr(pte), 1); // 释放该页物理地址
        }
        addr_free_page(&paddr_alloc, (uint32_t)pde_paddr(pde), 1); // 释放该页表对应的空间
    }
    addr_free_page(&paddr_alloc, (uint32_t)page_dir, 1); // 释放该页目录表
}
/**
 * @brief        : 复制一个页目录表及其映射关系，创建一个新的页目录表
 * @param         {uint32_t} page_dir: 需要复制的源页目录表的物理地址
 * @return        {uint32_t} : 新创建的页目录表的物理地址，失败返回-1
 **/
uint32_t memory_copy_uvm(uint32_t page_dir)
{
    uint32_t to_page_dir = memory_create_uvm(); // 创建页目录表
    if (to_page_dir == 0)                       // 创建失败
    {
        goto copy_uvm_failed;
    }
    uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE); // pde表项索引
    pde_t *pde = (pde_t *)page_dir + user_pde_start;       // 得到原一级页目录表中用户进程开始的页目录表项
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++)  // 遍历页目录表
    {
        if (!pde->present) // 页目录表项不存在
        {
            continue;
        }
        pte_t *pte = (pte_t *)pde_paddr(pde);    // 取出页目录表项对应的页表的物理地址
        for (int j = 0; j < PTE_CNT; j++, pte++) // 遍历页表
        {
            if (!pte->present) // 页表项不存在
            {
                continue;
            }
            uint32_t page = addr_alloc_page(&paddr_alloc, 1); // 分配一页物理内存
            if (page == 0)                                    // 分配失败
            {
                goto copy_uvm_failed;
            }
            uint32_t vaddr = (i << 22) | (j << 12);
            int err = memory_create_map((pde_t *)to_page_dir, vaddr, page, 1, get_pte_perm(pte)); // 建立映射关系
            if (err < 0)
            {
                goto copy_uvm_failed;
            }
            kernel_memcpy((void *)page, (void *)vaddr, MEM_PAGE_SIZE); // 复制内容
        }
    }
    return to_page_dir;
copy_uvm_failed:
    if (to_page_dir)
    {
        memory_destory_uvm(to_page_dir); // 销毁页目录表
    }
    return -1;
}
```

# 2.实现exec系统调用

## 2.1execve()系统调用的功能

​	execve 的主要作用是加载并执行指定的可执行文件。调用后，当前进程不会创建新进程，而是直接替换为新程序的执行环境。

```c
#include <unistd.h>
int execve(const char *filename, char *const argv[], char *const envp[]);
```

- **filename**: 要执行的程序路径，可以是绝对路径或相对路径。
- **argv**: 传递给新程序的参数列表，类似于 *main* 函数的 *argv*。
- **envp**: 新程序的环境变量列表。

调用特点：

1. **进程替换**：调用 `execve` 后，当前进程的执行内容被新程序替换，但进程 ID 保留。
2. **不返回**：如果调用成功，`execve` 不会返回；如果失败，则返回 -1 并设置 *errno*。
3. **资源继承**：新程序继承当前进程的文件描述符、信号处理等资源。

## 2.2 创建一个空应用

​	创建一个独立的应用程序文件，未来可单独放在磁盘上，并从磁盘上加载。

![image-20250704160326477](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250704160326477.png)



![image-20250704160339079](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250704160339079.png)

​	创建`shell`文件目录并在此之下创建`CMakeLists.txt`文件，`main.c`文件，并创建链接脚本`link.lds`,在`applib`目录下添加`CMakeLists.txt`,创建`crt0.S`、`cstart.c`文件

`shell/CMakeLists.txt`

```cmake

project(shell LANGUAGES C)  

# 使用自定义的链接器
# 加入相应的库
set(LIBS_FLAGS "-L ${CMAKE_BINARY_DIR}/source/applib/ -lapp")
set(CMAKE_EXE_LINKER_FLAGS "-m elf_i386 -T ${PROJECT_SOURCE_DIR}/link.lds ${LIBS_FLAGS}")
set(CMAKE_C_LINK_EXECUTABLE "${LINKER_TOOL} <OBJECTS> ${CMAKE_EXE_LINKER_FLAGS} -o ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.elf")

# 在哪个目录下找头文件
include_directories(
    ${PROJECT_SOURCE_DIR}/../applib/
)

# 将所有的汇编、C文件加入工程
# 注意保证start.asm在最前头
file(GLOB C_LIST "*.c" "*.h" "*.S")
add_executable(${PROJECT_NAME} ${C_LIST})

# 不带调试信息的elf生成，何种更小，写入到image目录下
add_custom_command(TARGET ${PROJECT_NAME}
                   POST_BUILD
                   COMMAND ${OBJCOPY_TOOL} -S ${PROJECT_NAME}.elf ${CMAKE_SOURCE_DIR}/../image/${PROJECT_NAME}.elf
                   COMMAND ${OBJDUMP_TOOL} -x -d -S -m i386 ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.elf > ${PROJECT_NAME}_dis.txt
                   COMMAND ${READELF_TOOL} -a ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.elf > ${PROJECT_NAME}_elf.txt
)
```

`/shell/link.ds`

```
ENTRY(_start)
SECTIONS
{
    . = 0x81000000;
    .text : {
        *(.text)
    }
    .rodata :{
        *(.rodata)
    }
    .data : {
        *(.data)
    }
    .bss : {
        *(.bss)
    }
}
```

`/applib/crt0.S`

```assembly
/*
 * @FilePath     : /code/source/applib/crt0.S
 * @Description  :  c运行库文件,设置寄存器
 * @Author       : ys 2900226123@qq.com
 * @Version      : 0.0.1
 * @LastEditors  : ys 2900226123@qq.com
 * @LastEditTime : 2025-07-03 09:56:31
 * Copyright    : G AUTOMOBILE RESEARCH INSTITUTE CO.,LTD Copyright (c) 2025.
 */
    .text
    .global _start
    .extern cstart
_start:
    mov %ss, %ax
	mov %ax, %ds
	mov %ax, %es
	mov %ax, %fs
	mov %ax, %gs
    jmp cstart
```

`/applib/CMakeLists.txt`

```cmake

project(app LANGUAGES C)  

file(GLOB C_LIST "*.c" "*.h" "*.S")
# 生成库
add_library(${PROJECT_NAME} ${C_LIST})

# bin文件生成，写入到image目录下
add_custom_command(TARGET ${PROJECT_NAME}
                   POST_BUILD
                   COMMAND ${OBJDUMP_TOOL} -x -d -S -m i386 ${PROJECT_BINARY_DIR}/lib${PROJECT_NAME}.a > ${PROJECT_NAME}_dis.txt
                   COMMAND ${READELF_TOOL} -a ${PROJECT_BINARY_DIR}/lib${PROJECT_NAME}.a > ${PROJECT_NAME}_elf.txt
)
```

`/applib/cstart.c`

```c
/**
 * @FilePath     : /code/source/applib/cstart.c
 * @Description  :  cstart启动文件
 * @Author       : ys 2900226123@qq.com
 * @Version      : 0.0.1
 * @LastEditors  : ys 2900226123@qq.com
 * @LastEditTime : 2025-07-03 09:58:30
 * @Copyright    : G AUTOMOBILE RESEARCH INSTITUTE CO.,LTD Copyright (c) 2025.
 **/
int main(int argc, char **argv);
void cstart(int argc, char **argv)
{
    main(argc, argv); // 跳转至应用程序运行
}

```

## 2.3 增加`exec`系统调用

​	基本流程：

```c
/**
 * @brief        : 创建一个新的进程
 * @param         {char *} name: 应用程序路径
 * @param         {char **} argv: 参数
 * @param         {char **} env: 环境变量
 * @return        {int} : 创建的进程的PID
**/
static inline int execve(const char * name,char * const * argv,char * const * env )
{
    syscall_args_t args;
    args.id = SYS_execve;
    args.arg0 = (int) name;
    args.arg1 = (int) argv;
    args.arg2 = (int) env;
    sys_call(&args);
}
```

```c
/**
 * 系统调用表
 */
static const sys_handler_t sys_table[] = {
    [SYS_sleep] = (sys_handler_t)sys_sleep,
    [SYS_getpid] = (sys_handler_t)sys_getpid,
    [SYS_print_msg] = (sys_handler_t)sys_print_msg,
    [SYS_fork] = (sys_handler_t)sys_fork,
    [SYS_execve] = (sys_handler_t)sys_execve,
    [SYS_yield] = (sys_handler_t)sys_yield,

};
```

```c
/**
 * @brief        : 创建一个新的进程运行
 * @param         {char} *name: 应用程序路径
 * @param         {char} *: 参数
 * @param         {char} *: 环境变量
 * @return        {int} : 创建进程的PID
 **/
int sys_execve(char *path, char **argv, char **env)
{
	return 0;
}
```

## 2.4 添加虚拟文件访问接口

​	为实现应用程序的加载，需要完成两点工作：

- 分配相应的存储空间
- 从`elf`文件中读取数据并写入内存页中

![image-20250704164359246](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250704164359246.png)

​	读取`elf`文件,需要文件系统接口。为方便起见，使用一个简单的文件系统实现。

![image-20250704164450692](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250704164450692.png)

```c
/**
 * @FilePath     : /code/source/kernel/fs/fs.c
 * @Description  :  文件系统实现文件
 * @Author       : ys 2900226123@qq.com
 * @Version      : 0.0.1
 * @LastEditors  : ys 2900226123@qq.com
 * @LastEditTime : 2025-07-04 16:54:51
 * @Copyright    : G AUTOMOBILE RESEARCH INSTITUTE CO.,LTD Copyright (c) 2025.
 **/
#include "fs/fs.h"
#include "tools/klib.h"
#include "comm/boot_info.h"
#include "comm/cpu_instr.h"
#define TEMP_FILE_ID 100
static uint8_t TEMP_ADDR[100 * 1024]; // 临时地址
static uint8_t *temp_pos;             // 文件读写位置
/*临时使用*/
static void read_disk(uint32_t sector, uint32_t sector_count, uint8_t *buf)
{
    outb(0x1F6, (uint8_t)(0xE0));

    outb(0x1F2, (uint8_t)(sector_count >> 8));
    outb(0x1F3, (uint8_t)(sector >> 24)); // LBA参数的24 ~ 31位
    outb(0x1F4, (uint8_t)(0));            // LBA参数的32~39位
    outb(0x1F5, (uint8_t)(0));            // LBA参数的40~47位

    outb(0x1F2, (uint8_t)(sector_count));
    outb(0x1F3, (uint8_t)(sector));       // LBA参数的0~7位
    outb(0x1F4, (uint8_t)(sector >> 8));  // LBA参数的8~15位
    outb(0x1F5, (uint8_t)(sector >> 16)); // LBA参数的16~23位

    outb(0x1F7, (uint8_t)0x24);

    // 读取数据
    uint16_t *data_buf = (uint16_t *)buf;
    while (sector_count-- > 0)
    {
        // 每次扇区读之前都要检查,等待数据就绪
        while ((inb(0x1F7) & 0x88) != 0x8)
        {
        }

        // 读取数据并将数据写入到缓存中
        for (int i = 0; i < SECTOR_SIZE / 2; i++)
        {
            *data_buf++ = inw(0x1F0);
        }
    }
}

/**
 * @brief        : 打开文件
 * @param         {char} *path: 文件路径
 * @param         {int} flags: 标志
 * @return        {int} : 文件id
 **/
int sys_open(const char *path, int flags, ...)
{
    if (path[0] == '/')
    {
        read_disk(5000, 80, TEMP_ADDR);
        temp_pos = (uint8_t *)TEMP_ADDR;
        return TEMP_FILE_ID;
    }
    return -1;
}
/**
 * @brief        : 读取文件
 * @param         {int} file: 哪一个文件
 * @param         {char} *ptr: 读取到文件的目的地址
 * @param         {int} len: 读取长度
 * @return        {int} 读取成功返回读取长度,失败返回-1
**/
int sys_read(int file, char *ptr, int len)
{
    if(file == TEMP_FILE_ID)
    {
        kernel_memcpy(ptr,temp_pos,len);
        temp_pos += len;
        return len;
    }
    return -1;
}
/**
 * @brief        : 写文件
 * @param         {int} file: 写入的文件
 * @param         {char} *ptr: 
 * @param         {int} len: 写入长度
 * @return        {*}
**/
int sys_write(int file, char *ptr, int len)
{
    return -1;
}
/**
 * @brief        : 调整读写指针
 * @param         {int} file: 操作文件 
 * @param         {int} ptr: 
 * @param         {int} dir:
 * @return        {int} 成功返回 1, 失败返回 -1
**/
int sys_lseek(int file, int ptr, int dir)
{
    if(file = TEMP_FILE_ID)
    {
        temp_pos = (uint8_t *) (TEMP_ADDR + ptr); // 调整指针
        return 0;
    }
    return -1;
}
int sys_close(int file)
{
    return 0;
}
```

将`elf`文件加载到内存中。

```c

/**
 * @brief        : 将程序表头加载到页表中
 * @param         {int} file: 文件ID
 * @param         {Elf32_Phdr *} phdr: elf文件表头
 * @param         {uint32_t} page_dir: 加载目的页目录表
 * @return        {int} : 状态码:1成功,2失败
 **/
int load_phdr(int file, Elf32_Phdr *phdr, uint32_t page_dir)
{
    // 分配内存空间
    int err = memory_alloc_page_for_dir(page_dir, phdr->p_vaddr, phdr->p_memsz, PTE_P | PTE_U | PTE_W);
    if (err < 0) // 分配失败
    {
        log_printf("memory_alloc_page_for_dir err.");
        return -1;
    }
    if (sys_lseek(file, phdr->p_offset, 0) < 0) // 调整文件读写指针值偏移量的位置
    {
        log_printf("read file failed");
        return -1;
    }
    uint32_t vaddr = phdr->p_vaddr; // 起始地址
    uint32_t size = phdr->p_filesz; // 文件大小
    while (size > 0)                // 是否有数据量
    {
        int curr_size = (size > MEM_PAGE_SIZE) ? MEM_PAGE_SIZE : size; // 拷贝数据量
        uint32_t paddr = memory_get_paddr(page_dir, vaddr);            // vaddr在pade_dir中的物理地址

        if (sys_read(file, (char *)paddr, curr_size) < curr_size) // 读取到实际的物理地址中
        {
            log_printf("read file failed.");
            return -1;
        }
        size -= curr_size;  //
        vaddr += curr_size; //
    }
    return 0;
}
/**
 * @brief        : 加载elf可执行文件
 * @param         {task_t *} task: 将elf文件加载到哪一个进程运行
 * @param         {char *} path: elf文件的路径
 * @param         {uint32_t} page_dir: elf运行的新的页目录表
 * @return        {uint32_t} : 入口地址
 **/
static uint32_t load_elf_file(task_t *task, const char *path, uint32_t page_dir)
{
    Elf32_Ehdr elf_hdr;           // elf文件头
    Elf32_Phdr elf_phdr;          // elf表项
    int file = sys_open(path, 0); // 只读方式打开文件
    if (file < 0)                 // 打开失败
    {
        log_printf("open failed.path = %s", path);
        goto load_failed; // 错误处理
    }
    int cnt = sys_read(file, (char *)&elf_hdr, sizeof(elf_hdr)); // 读取文件头
    if (cnt < sizeof(Elf32_Ehdr))                                // 读取失败
    {
        log_printf("elf hdr too small.");
        goto load_failed;
    }
    // 是否为elf文件
    if ((elf_hdr.e_ident[0] != ELF_MAGIC || elf_hdr.e_ident[1] != 'E') ||
        (elf_hdr.e_ident[2] != 'L') || (elf_hdr.e_ident[3] != 'F'))
    {
        log_printf("check elf ident failed.");
        goto load_failed;
    }
    // 必须是可执行文件和针对386处理器的类型，且有入口
    if ((elf_hdr.e_type != ET_EXEC) || (elf_hdr.e_machine != ET_386) || (elf_hdr.e_entry == 0))
    {
        log_printf("check elf type or entry failed.");
        goto load_failed;
    }
    // 必须有程序头部
    if ((elf_hdr.e_phentsize == 0) || (elf_hdr.e_phoff == 0))
    {
        log_printf("none programe header");
        goto load_failed;
    }

    uint32_t e_phoff = elf_hdr.e_phoff;

    for (int i = 0; i < elf_hdr.e_phnum; i++, e_phoff += elf_hdr.e_ehsize) // 遍历表项
    {
        if (sys_lseek(file, e_phoff, 0) < 0) // 调整读写指针
        {
            log_printf("read file failed");
            goto load_failed;
        }
        cnt = sys_read(file, (char *)&elf_phdr, sizeof(elf_phdr)); // 读到elf_phdr中
        if (cnt < sizeof(elf_phdr))
        {
            log_printf("read file failed");
            goto load_failed;
        }

        // 主要判断是否是可加载的类型，并且要求加载的地址必须是用户空间
        if ((elf_phdr.p_type != PT_LOAD) || (elf_phdr.p_vaddr < MEMORY_TASK_BASE))
        {
            continue;
        }
        int err = load_phdr(file, &elf_phdr, page_dir); // 加载当前程序头到新页表中
        if (err < 0)                                    // 加载失败
        {
            log_printf("load program hdr failed");
            goto load_failed;
        }
    }
    sys_close(file);
    return elf_hdr.e_entry;

load_failed:
    if (file >= 0)
    {
        sys_close(file);
    }

    return 0;
}

```

`sys_execve`部分实现：

```c
/**
 * @brief        : 创建一个新的进程运行
 * @param         {char} *name: 应用程序路径
 * @param         {char} *: 参数
 * @param         {char} *: 环境变量
 * @return        {int} : 创建进程的PID
 **/
int sys_execve(char *name, char **argv, char **env) {
    task_t * task = task_current();

    // 现在开始加载了，先准备应用页表，由于所有操作均在内核区中进行，所以可以直接先切换到新页表
    uint32_t old_page_dir = task->tss.cr3;
    uint32_t new_page_dir = memory_create_uvm();
    if (!new_page_dir) {
        goto exec_failed;
    }

    // 加载elf文件到内存中。要放在开启新页表之后，这样才能对相应的内存区域写
    uint32_t entry = load_elf_file(task, name, new_page_dir);    // 暂时置用task->name表示
    if (entry == 0) {
        goto exec_failed;
    }

    // 切换到新的页表
    task->tss.cr3 = new_page_dir;
    mmu_set_page_dir(new_page_dir);   // 切换至新的页表。由于不用访问原栈及数据，所以并无问题

    // 调整页表，切换成新的，同时释放掉之前的
    // 当前使用的是内核栈，而内核栈并未映射到进程地址空间中，所以下面的释放没有问题
    memory_destroy_uvm(old_page_dir);            // 再释放掉了原进程的内容空间

    // 当从系统调用中返回时，将切换至新进程的入口地址运行，并且进程能够获取参数
    // 注意，如果用户栈设置不当，可能导致返回后运行出现异常。可在gdb中使用nexti单步观察运行流程
    return  0;

exec_failed:    // 必要的资源释放
    if (new_page_dir) {
        // 有页表空间切换，切换至旧页表，销毁新页表
        task->tss.cr3 = old_page_dir;
        mmu_set_page_dir(old_page_dir);
        memory_destroy_uvm(new_page_dir);
    }

    return -1;
}

```

## 2.5 分配栈并进入进程执行

​	新进程的栈分配空间与first_task可能不相同，所以也需要重新建立。

![image-20250704171631696](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250704171631696.png)

​	由于要从`sys_exec`返回，因此继续使用特权级0的栈，但是会修改压入栈中某些寄存器值。

![image-20250704171839180](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250704171839180.png)

​	给进程分配新的栈空间。

```c
/**
 * @brief        : 创建一个新的进程运行
 * @param         {char} *name: 应用程序路径
 * @param         {char} *: 参数
 * @param         {char} *: 环境变量
 * @return        {int} : 创建进程的PID
 **/
int sys_execve(char *path, char **argv, char **env)
{
    task_t *task = task_current(); // 当前运行的进程
    kernel_strncpy(task->name, get_file_name(path), TASK_NAME_SIZE);
    uint32_t old_page_dir = task->tss.cr3;       // 原页表
    uint32_t new_page_dir = memory_create_uvm(); // 创建新的页目录表
    if (!new_page_dir)                           // 创建失败
    {
        goto exce_failed;
    }
    uint32_t entry = load_elf_file(task, path, new_page_dir); // 加载elf文件,获取入口地址
    if (entry == 0)                                           // 加载失败
    {
        goto exce_failed;
    }
    uint32_t stack_top = MEM_TASK_STACK_TOP - MEM_TASK_ARG_SIZE; // 栈顶
    int err = memory_alloc_page_for_dir(
        new_page_dir,
        MEM_TASK_STACK_TOP - MEM_TASK_STACK_SIZE,
        MEM_TASK_STACK_SIZE,
        PTE_P | PTE_U | PTE_W); // 分配栈空间
    if (err < 0)                // 出现错误
    {
        goto exce_failed;
    }
    int argc = strings_count(argv);
    err = copy_args((char *)stack_top, new_page_dir, argc, argv);
    if (err < 0)
    {
        goto exce_failed;
    }
    syscall_frame_t *frame = (syscall_frame_t *)(task->tss.esp0 - sizeof(syscall_frame_t)); // 父进程的栈信息(寄存器)
    frame->eip = entry;                                                                     // 更改返回的地址,返回到函数入口
    frame->eax = frame->ebx = frame->ecx = frame->edx = 0;
    frame->esi = frame->edi = frame->ebp = 0;
    frame->eflags = EFLAGS_IF | EFLAGS_DEFAULT;
    frame->esp = stack_top;
    task->tss.cr3 = new_page_dir;     // 更新页表
    mmu_set_page_dir(new_page_dir);   // 更新cr3为新页表
    memory_destory_uvm(old_page_dir); // 释放原页表
    return 0;
exce_failed:
    if (new_page_dir)
    {
        task->tss.cr3 = old_page_dir;     // 恢复为原页表
        mmu_set_page_dir(old_page_dir);   // 恢复cr3为旧页表
        memory_destory_uvm(new_page_dir); // 释放新创建的页表
    }
    return -1;
}

```

## 2.6为进程传递参数

​	在应用重新启动前，可能向器传递若干参数，这些参数、可用argc、argv获得这些参数。

![image-20250704172933432](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250704172933432.png)

​	在调用`main`函数之前，需要先往栈中压入`argc`、`argv`参数值。

![image-20250704173149139](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250704173149139.png)

```c
    frame->esp = stack_top - sizeof(uint32_t) * SYSCALL_PARAM_COUNT;  // 设置栈帧顶部
```

![image-20250704173336155](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250704173336155.png)

```c
    uint32_t stack_top = MEM_TASK_STACK_TOP - MEM_TASK_ARG_SIZE; // 栈顶
```

​	由于当前使用的页表仍然为旧的，而非新加载进内存要运行的进程的页表，故不能直接进行拷贝。

```c
/**
 * @brief        : 将参数拷贝到目的地址
 * @param         {char *} to: 目的地址
 * @param         {uint32_t} page_dir: 对应页目录表
 * @param         {int} argc: 拷贝参数的个数
 * @param         {char **} argv: 字符串数组
 * @return        {int} : 状态码 -1失败,0成功
 **/
static int copy_args(char *to, uint32_t page_dir, int argc, char **argv)
{
    // 初始化参数
    task_args_t task_args;
    task_args.argc = argc;
    task_args.argv = (char **)(to + sizeof(task_args_t)); // 指向指针数组的起始位置

    char *dest_arg = to + sizeof(task_args_t) + sizeof(char *) * argc;                              // 2. 计算字符串存储区的起始位置
    char **dest_arg_tb = (char **)memory_get_paddr(page_dir, (uint32_t)(to + sizeof(task_args_t))); // 3. 获取指针数组在目标页表中的物理地址
    for (int i = 0; i < argc; i++)
    {
        char *from = argv[i];
        int len = kernel_strlen(from) + 1;                                                 // 字符串长度
        int err = memory_copy_uvm_data((uint32_t)dest_arg, page_dir, (uint32_t)from, len); // 拷贝字符串内容到目标位置
        ASSERT(err >= 0);
        dest_arg_tb[i] = dest_arg; // 在指针数组中记录这个字符串的虚拟地址
        dest_arg += len;           // 移动到下一个位置
    }
    return memory_copy_uvm_data((uint32_t)to, page_dir, (uint32_t)&task_args, sizeof(task_args_t)); // 将数据拷贝到page_dir中对应to的物理地址处
}
```

> ```asciiarmor
> 用户栈中的内存布局：
> ┌─────────────────┐  ← to
> │   task_args_t   │  (包含 argc 和 argv 指针)
> ├─────────────────┤  ← to + sizeof(task_args_t)
> │   char *argv[0] │  
> │   char *argv[1] │  指针数组，指向下面的字符串
> │   char *argv[2] │  
> │       ...       │  
> ├─────────────────┤  ← dest_arg (字符串存储区开始)
> │   "arg0\0"      │  
> │   "arg1\0"      │  实际的参数字符串
> │   "arg2\0"      │  
> │       ...       │  
> └─────────────────┘
> ```
>
> - `dest_arg_tb` 是指针数组的**物理地址**，用于直接写入指针值
> - `dest_arg` 是字符串在**目标进程虚拟地址空间**中的地址
> - 先拷贝所有字符串，再拷贝结构体头部，确保指针都正确设置

```c
/**
 * @brief        : 将数据从一个地址空间拷贝到另一个进程的用户虚拟内存空间中。
 * @param         {uint32_t} to: 目标虚拟地址,在page_dir页目录表中
 * @param         {uint32_t} page_dir:  目标页目录表
 * @param         {uint32_t} from: 源地址(当前地址空间)
 * @param         {uint32_t} size: 拷贝的字节数
 * @return        {int} : 状态码. 成功返回0,失败返回-1
 **/
int memory_copy_uvm_data(uint32_t to, uint32_t page_dir, uint32_t from, uint32_t size)
{
    while (size > 0)
    {
        uint32_t to_paddr = memory_get_paddr(page_dir, to); // 目的地址所在物理地址
        if (to_paddr == 0)                                  // 目标地址未映射
        {
            return -1;
        }
        uint32_t offset_in_page = to_paddr & (MEM_PAGE_SIZE - 1); // 页内偏移
        uint32_t curr_size = MEM_PAGE_SIZE - offset_in_page;      // 当前页还能拷贝的大小
        if (curr_size > size)                                     // 如果剩余要拷贝的数据小于当前页能容纳的，则只拷贝剩余的
        {
            curr_size = size;
        }

        kernel_memcpy((void *)to_paddr, (void *)from, curr_size); // 执行实际的内存拷贝（直接使用物理地址）
        // 更新指针和剩余大小
        size -= curr_size;
        to += curr_size;
        from += curr_size;
    }
    return 0 ;
}
```

> 1. **跨页拷贝处理**: 如果数据跨越多个页面，需要逐页处理，因为虚拟地址连续但物理地址可能不连续。
> 2. **地址转换**: 通过 `memory_get_paddr()` 将目标进程的虚拟地址转换为物理地址。
> 3. **页边界处理**: 计算当前页内剩余空间，避免越界访问。
> 4. **直接物理地址访问**: 使用物理地址进行拷贝，绕过虚拟内存管理。

# 3.添加sys_yield系统调用

​	之前已经实现该系统调用，较为简单，不过多赘述。
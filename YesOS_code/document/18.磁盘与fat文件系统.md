# 1.磁盘特性简介

​	早期磁盘结构比较复杂，有磁道、扇区、柱面等概念。幸运地是，我们不需要管这些。

![image-20250710140844185](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250710140844185.png)

​	为了管理方便，一般将磁盘分区为多个分区，每个分区采用不同类型的文件系统进行管理。其中磁盘最开头的第0扇区保存了整个磁盘分区的起始位置、大小等相关信息

![image-20250710140922588](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250710140922588.png)

​	某磁盘管理软件展示的分区图

![image-20250710140956172](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250710140956172.png)

​	添加`disk.c`、`disk.h`等文件，并添加`disk`磁盘这种数据结构、具体如下：

```c
#define DISK_NAME_SIZE 128                            // 磁盘名称
#define PART_NAME_SIZE 128                            // 分区名
#define DISK_PRIMARY_PART_CNT (4 + 1)                 // 分区数量
/**
 * 分区信息
 */
typedef struct _part_info_t
{
    char name[PART_NAME_SIZE]; // 分区名
    struct _disk_t *disk;
    enum
    {
        FS_INVALID = 0x00, // 无效
        FS_FAT16_0 = 0x06, // fat16
        FS_FAT16_1 = 0x0E,
    } type;           // 文件系统类型
    int start_sector; // 开始扇区
    int total_sector; // 总扇区
} part_info_t;

/**
 * 磁盘结构描述符
 */
typedef struct _disk_t
{
    char name[DISK_NAME_SIZE]; // 磁盘名称
    enum
    {
        DISK_MASTER = (0 << 4),                   // 主盘
        DISK_SLAVE = (1 << 4),                    // 从盘
    } drive;                                      // 磁盘驱动类型
    uint16_t port_base;                           // i/o端口地址
    int sector_size;                              // 扇区大小
    int sector_count;                             // 扇区数量
    part_info_t part_info[DISK_PRIMARY_PART_CNT]; // 分区表
} disk_t;
/**
 * @brief        : 磁盘初始化
 * @return        {void}
 **/
void disk_init(void)
{
    log_printf("check disk...\n");
    kernel_memset((void *)disk_buf, 0, sizeof(disk_buf));
    for (int i = 0; i < DISK_PER_CHANNEL; i++)
    {
        disk_t *disk = disk_buf + i;                       // 获取该硬盘
        kernel_sprintf(disk->name, "sd%c", i + 'a');       // 对磁盘命名
        disk->drive = (i == 0) ? DISK_MASTER : DISK_SLAVE; // 主盘还是从盘
        disk->port_base = IOBASE_PRIMARY;                  // 设置端口地址
        int err = identify_disk(disk);                     // 识别磁盘
        if (err == 0)                                      // 识别错误
        {
            print_disk_info(disk);
        }
    }
}

```

# 2.识别系统中已有的磁盘

## 2.1 基础知识

​	主要问题：系统中有多少块硬盘？具体连续接在哪个地方？

​	系统中分两条总线，分别为Primary(主）和Secondary(次），每条总结上可连接两块硬盘Primary(主）Drive和Slave(从） Drive。每条总线上共用相同的IO端口进行读写和相关控制。

​	![image-20250710141416946](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250710141416946.png)

​	为简化起见，本章仅支持Prmary Bus上的硬盘，即最多支持两块硬盘。因此，其IO端口的范围为0x1F0-0x1F7，控制端口为0x3F5，连接8259上的IRQ14号上，因此在整个系统中的中断序号为0x20（8259中断起始序号） + 14 = 0x2E。

可以通过识别命令来检测硬盘的存在，以及硬盘相关的信息。原始参考资料见：https://wiki.osdev.org/ATA_PIO_Mode。

具体流程如下：

- 写Drive / Head Register寄存器（地址0x1F6）：0xA0（master drive）或者0xB0（slave driver）

- 将扇区数量寄存器、LBAlo, LBAmid, 和 LBAhi IO（地址0x1F2-0x1F5）全设置成0

- 向命令寄存器（地址0x1F7）发送IDENTIFY命令（0xEC）

- 读取状态寄存器(0x1F7）：如果值为0，则表明该硬盘不存在。如果其它值，等待DRQ置位或者ERR置位

- 如果ERR清令状态，从0x1F0读取256个16位的数据，其中保存了有关该磁盘相关的信息。

- 返回的256个16位的数据内容：第100 - 103 个数据，共64位：保存了该磁盘总的扇区数量


 **磁盘相关寄存器**

  各寄存器说明如下：（仅列出与课程程序相关的说明）

  | 寄存器偏移 | 读写 | 功能                             |
  | ---------- | ---- | -------------------------------- |
  | 0          | R/W  | 数据寄存器                       |
  | 1          | R    | 错误寄存器                       |
  | 1          | W    | 特性寄存器                       |
  | 2          | R/W  | 扇区数量寄存器                   |
  | 3          | R/W  | Sector Number Register (LBAlo)   |
  | 4          | R/W  | Cylinder Low Register / (LBAmid) |
  | 5          | R/W  | Cylinder High Register / (LBAhi) |
  | 6          | R/W  | Drive / Head Register            |
  | 7          | R    | 状态寄存器                       |
  | 7          | W    | 命令寄存器                       |

其中0x1F6寄存器（Drive / Head）对应的位如下：

| 位    | 名称 | 功能                                   |
| ----- | ---- | -------------------------------------- |
| 0 - 3 |      | 在, bits 24 to 27 of the block number. |
| 4     | DRV  | 驱动器号                               |
| 5     | 1    |                                        |
| 6     | LBA  | 对LBA模式，总为1                       |
| 7     | 1    |                                        |

**Status Register (I/O base + 7)**

| 位   | 名称 | 功能                         |
| ---- | ---- | ---------------------------- |
| 0    | ERR  | 发生错误                     |
| 1    | IDX  |                              |
| 2    | CORR |                              |
| 3    | DRQ  | 就绪，可以写数据或者读取数据 |
| 4    | SRV  |                              |
| 5    | DF   |                              |
| 6    | RDY  |                              |
| 7    | BSY  | 忙                           |

## 2.2添加相关宏定义

​	修改`qemu-debug-win.bat`文件

```bat
start qemu-system-i386  -m 128M -s -S -serial stdio -drive file=disk1.vhd,index=0,media=disk,format=raw -drive file=disk2.vhd,index=1,media=disk,format=raw -d pcall,page,mmu,cpu_reset,guest_errors,page,trace:ps2_keyboard_set_translation
```

```c
#define DISK_PER_CHANNEL 2                            // 每根总线2块磁盘
#define IOBASE_PRIMARY 0x1F0                          // 主IDE通道基础端口地址
#define DISK_DATA(disk) (disk->port_base + 0)         // 数据寄存器地址
#define DISK_ERROR(disk) (disk->port_base + 1)        // 错误信息寄存器地址
#define DISK_SECTOR_COUNT(disk) (disk->port_base + 2) // 扇区计数寄存器地址
#define DISK_LBA_LOW(disk) (disk->port_base + 3)      // LBA地址低8位寄存器地址
#define DISK_LBA_MID(disk) (disk->port_base + 4)      // LBA地址中8位寄存器地址
#define DISK_LBA_HI(disk) (disk->port_base + 5)       // LBA地址高8位寄存器地址
#define DISK_DRIVE(disk) (disk->port_base + 6)        // 驱动器/磁头选择寄存器地址
#define DISK_STATUS(disk) (disk->port_base + 7)       // 状态寄存器地址
#define DISK_CMD(disk) (disk->port_base + 7)          // 命令寄存器地址

#define DISK_CMD_IDENTIFY 0xEC  // 识别磁盘命令
#define DISK_CMD_READ 0x24  // 读取磁盘命令
#define DISK_CMD_WRITE 0x34 // 写磁盘命令

#define DISK_STATUS_ERR (1 << 0)  // 磁盘错误状态
#define DISK_STATUS_DRQ (1 << 3)  // 数据请求位，表示磁盘准备好进行数据传输
#define DISK_STATUS_DF (1 << 5)   // 设备故障位，表示磁盘硬件故障
#define DISK_STATUS_BUSY (1 << 7) // 磁盘忙

#define DISK_DRIVE_BASE 0xE0 // 磁盘起始地址
```

## 2.3识别磁盘信息并保存

​	完善`disk_init`函数，填充相关初始化信息

```c
/**
 * @brief        : 磁盘初始化
 * @return        {void}
 **/
void disk_init(void)
{
    log_printf("check disk...\n");
    kernel_memset((void *)disk_buf, 0, sizeof(disk_buf));
    for (int i = 0; i < DISK_PER_CHANNEL; i++)
    {
        disk_t *disk = disk_buf + i;                       // 获取该硬盘
        kernel_sprintf(disk->name, "sd%c", i + 'a');       // 对磁盘命名
        disk->drive = (i == 0) ? DISK_MASTER : DISK_SLAVE; // 主盘还是从盘
        disk->port_base = IOBASE_PRIMARY;                  // 设置端口地址
        int err = identify_disk(disk);                     // 识别磁盘
        if (err == 0)                                      // 识别错误
        {
            print_disk_info(disk);
        }
    }
}
```

实现一个发送命令的函数,参考`read_disk`,具体如下：

```c
/**
 * @brief        : 向磁盘发命令
 * @param         {disk_t *} disk: 目的磁盘
 * @param         {uint32_t} start_sector: 起始扇区
 * @param         {uint32_t} sector_count: 扇区数量
 * @param         {int} cmd: 所发送的命令
 * @return        {void}
 **/
static void disk_send_cmd(disk_t *disk, uint32_t start_sector, uint32_t sector_count, int cmd)
{
    outb(DISK_DRIVE(disk), (DISK_DRIVE_BASE | disk->drive));     // 设置驱动器和LBA模式，bit4选择驱动器(0=主盘,1=从盘)，bit6=1启用LBA模式
    outb(DISK_SECTOR_COUNT(disk), (uint8_t)(sector_count >> 8)); // 设置扇区计数高8位
    outb(DISK_LBA_LOW(disk), (uint8_t)(start_sector >> 24));     // 设置LBA地址的24-31位
    outb(DISK_LBA_MID(disk), 0);                                 // 设置LBA地址的32-39位
    outb(DISK_LBA_HI(disk), 0);                                  // 设置LBA地址的40-47位
    outb(DISK_SECTOR_COUNT(disk), (uint8_t)(sector_count));      // 设置扇区计数低8位
    outb(DISK_LBA_LOW(disk), (uint8_t)(start_sector >> 0));      // 设置LBA地址的0-7位
    outb(DISK_LBA_MID(disk), (uint8_t)(start_sector >> 8));      // 设置LBA地址的8-15位
    outb(DISK_LBA_HI(disk), (uint8_t)(start_sector >> 16));      // 设置LBA地址的16-23位
    outb(DISK_CMD(disk), (uint8_t)cmd);                          // 发送命令到命令寄存器
}
```

​	完成对磁盘数据的读取与写入

```c
/**
 * @brief        : 读取磁盘的数据到缓冲区
 * @param         {disk_t *} disk: 需要读取的磁盘
 * @param         {void *} buf: 读取到的数据的缓冲区
 * @param         {int} size: 读取的大小
 * @return        {void}
 **/
static void disk_read_data(disk_t *disk, void *buf, int size)
{
    uint16_t *p = (uint16_t *)buf; // 指向缓冲区首地址

    for (int i = 0; i < size / 2; i++)
    {
        *p++ = inw(DISK_DATA(disk));
    }
}
/**
 * @brief        : 往磁盘写入数据
 * @param         {disk_t *} disk: 需要写入的磁盘
 * @param         {void *} buf: 写入的数据存储的缓冲区
 * @param         {int} size: 写入的大小
 * @return        {void}
 **/
static inline void disk_write_data(disk_t *disk, void *buf, int size)
{
    uint16_t *p = (uint16_t *)buf; // 写入数据缓冲区首地址
    for (int i = 0; i < size / 2; i++)
    {
        outw(DISK_DATA(disk), *p++);
    }
}
```

​	等待操作的完成

```c
/**
 * @brief        : 等待磁盘(磁盘存在)状态空闲
 * @param         {disk_t} *disk: 等待的磁盘
 * @return        {int} 若磁盘空闲返回0,否则(非空闲或错误)返回-1
 **/
static int disk_wait_data(disk_t *disk)
{
    uint8_t status; // 记录状态
    do
    {
        // 等待数据或者有错误
        status = inb(DISK_STATUS(disk)); // 读取磁盘状态
        if ((status &
             (DISK_STATUS_BUSY | DISK_STATUS_DRQ | DISK_STATUS_ERR)) != DISK_STATUS_BUSY) // 磁盘空闲
        {
            break;
        }
    } while (1);

    return (status & DISK_STATUS_ERR) ? -1 : 0; // 磁盘是否空闲
}
```

打印磁盘的信息

```c
/**
 * @brief        : 打印磁盘信息
 * @param         {disk_t *} : 需要打印的磁盘
 * @return        {void}
 **/
static void print_disk_info(disk_t *disk)
{
    log_printf("disk : %s\n", disk->name);                                                  // 打印磁盘名称
    log_printf("port base:%x\n", disk->port_base);                                         // 端口地址
    log_printf("total size %d m\n", disk->sector_count * disk->sector_size / 1024 / 1024); // 磁盘大小
}
```

最后磁盘的识别

```c
/**
 * @brief        : 识别磁盘
 * @param         {disk_t} *disk: 需要识别的磁盘
 * @return        {int} 若成功返回0,失败返回-1
 **/
static int identify_disk(disk_t *disk)
{
    disk_send_cmd(disk, 0, 0, DISK_CMD_IDENTIFY); // 发送识别命令
    int err = inb(DISK_STATUS(disk));             // 读取磁盘状态
    if (err == 0)                                 // 不存在
    {
        log_printf("%s dosen't exist\n", disk->name);
        return -1;
    }
    // 存在
    err = disk_wait_data(disk); // 读取磁盘状态
    if (err < 0)                // 非空闲
    {
        log_printf("disk[%s]:read faied.\n", disk->name);
        return -1;
    }
    uint16_t buf[256];
    disk_read_data(disk, buf, sizeof(buf)); // 读取磁盘
    disk->sector_count = *(uint32_t *)(buf + 100);
    disk->sector_size = SECTOR_SIZE;
    return 0;
}
```

# 3.解析磁盘分区表

## 3.1基础知识

​	磁盘分区结构。

![image-20250710142816858](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250710142816858.png)

​	分区表中共4个表项，每个表1页包含了起始扇区、总扇区数、文件系统类型等关键性信息。

![image-20250710142934681](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250710142934681.png)

## 3.2分区表结构

```c
#pragma pack(1)
/**
 * 分区表表项
 */
typedef struct _part_item_t
{
    uint8_t boot_active;          // 引导标志
    uint8_t start_header;         // 分区起始位置的磁头号
    uint16_t start_sector : 6;    // 分区起始位置的磁头号
    uint16_t start_cylinder : 10; // 分区起始位置的磁头号
    uint8_t system_id;            // 分区类型标识符
    uint8_t end_header;           // 分区结束位置的磁头号
    uint16_t end_sector : 6;      // 分区结束位置的扇区号
    uint16_t end_cylinder : 10;   // 分区结束位置的柱面号
    uint32_t relative_sector;     // 分区相对于磁盘起始位置的偏移量
    uint32_t total_sectors;       // 分区的总扇区数
} part_item_t;

/**
 * mbr分区表
 */
typedef struct _mbr_t
{
    uint8_t code[446];                          // 引导代码46字节
    part_item_t part_item[MBR_PRIMARY_PART_NR]; // 分区表
    uint8_t boot_sig[2];                        // 引导标志
} mbr_t;
#pragma pack()

```

​	在检测磁盘的函数中添加

```c
/**
 * @brief        : 识别磁盘
 * @param         {disk_t} *disk: 需要识别的磁盘
 * @return        {int} 若成功返回0,失败返回-1
 **/
static int identify_disk(disk_t *disk)
{
    ...raw code...
// 第0个分区描述整个磁盘的情况
    part_info_t *part = disk->part_info + 0;           // 第0项
    part->disk = disk;                                 // 设置磁盘
    kernel_sprintf(part->name, "%s%d", disk->name, 0); // 设置分区名
    part->start_sector = 0;                            // 起始扇区号
    part->total_sector = disk->sector_count;           // 磁盘扇区数量
    part->type = FS_INVALID;                           // 分区类型未知
    detect_part_info(disk);                            // 解析分区信息
      return 0;
}
```

```c
/**
 * @brief        : 检测磁盘分区信息
 * @param         {disk_t} *disk: 需要检测的磁盘
 * @return        {int} : 成功返回0,失败返回-1
 **/
static int detect_part_info(disk_t *disk)
{
    mbr_t mbr;
    disk_send_cmd(disk, 0, 1, DISK_CMD_READ); // 发送读命令
    int err = disk_wait_data(disk);           // 等待磁盘状态
    if (err < 0)
    {
        log_printf("read mbr failed.\n");
        return err;
    }
    disk_read_data(disk, &mbr, sizeof(mbr)); // 读取数据到mbr中
    part_item_t *item = mbr.part_item;
    part_info_t *part_info = disk->part_info + 1;
    for (int i = 0; i < MBR_PRIMARY_PART_NR; i++, item++, part_info++)
    {
        part_info->type = item->system_id; // 设置类型
        if (part_info->type == FS_INVALID)
        {
            part_info->total_sector = 0;
            part_info->start_sector = 0;
            part_info->disk = (disk_t *)0;
        }
        else
        {
            kernel_sprintf(part_info->name, "%s%d", disk->name, i + 1); // 设置分区名
            part_info->start_sector = item->relative_sector;            // 起始扇区号
            part_info->total_sector = item->total_sectors;              // 磁盘扇区数量
            part_info->disk = disk;
        }
    }
    return 0;
}
```

> 1. **读取主引导记录 (MBR)**
>
>    - `disk_send_cmd(disk, 0, 1, DISK_CMD_READ);`: 向磁盘发送一个读命令。这个命令指示磁盘控制器从第 0 个扇区（LBA 地址为 0）开始，读取 1 个扇区的数据。磁盘的第 0 个扇区正是主引导记录（MBR）所在的位置。
>    - `disk_wait_data(disk);`: 等待磁盘完成数据准备，以便可以读取。
>    - `disk_read_data(disk, &mbr, sizeof(mbr));`: 从磁盘读取一个扇区（512 字节）的数据，并将其存入名为 `mbr` 的结构体变量中。`mbr_t` 结构体就是用来描述 MBR 结构的。
>
> 2. **解析分区表**
>
>    - MBR 的末尾包含一个 64 字节的分区表，最多可以定义 4 个主分区，每个分区表项为 16 字节。
>    - `part_item_t *item = mbr.part_item;`: 获取指向 `mbr` 结构中分区表数组的第一个表项的指针。
>    - `part_info_t *part_info = disk->part_info + 1;`: 获取指向 `disk` 结构中用于存储分区信息的数组的第二个元素的指针。第一个元素（索引为 0）在 `identify_disk` 函数中已经被用来代表整个磁盘了，所以这里从第二个元素（索引为 1）开始存放第一个分区的信息。
>
> 3. **遍历并填充分区信息**
>
>    - `for (int i = 0; i < MBR_PRIMARY_PART_NR; i++, item++, part_info++)`: 循环遍历 MBR 中的 4 个主分区表项（`MBR_PRIMARY_PART_NR` 通常定义为 4）。
>
>    - `part_info->type = item->system_id;`: 从 MBR 分区表项中读取分区类型（如 FAT32、NTFS 等）并保存。
>
>    - `if (part_info->type == FS_INVALID)`: 检查分区类型是否为无效或未使用（通常值为 0）。如果是，则将该分区的其他信息清零。
>
>    - `else`
>      
>      : 如果是一个有效的分区：
>
>      - `kernel_sprintf(...)`: 为分区创建一个名称，例如，如果磁盘名为 "hda"，分区名就会是 "hda1", "hda2" 等。
>     - `part_info->start_sector = item->relative_sector;`: 记录分区的起始扇区号。
>      - `part_info->total_sector = item->total_sectors;`: 记录分区的总扇区数。
>      - `part_info->disk = disk;`: 将分区信息与它所属的磁盘关联起来。

# 4.增加磁盘设备管理

​	由于对磁盘的读写往往是仅针对某个分区进行读写；因此，我们实际上需要将磁盘进一步拆分成子设备，其编号为0xa0、 0xal、0×a2、0×a3。

![image-20250710154758809](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250710154758809.png)

# 5.实现磁盘的读取和写入

​	此外，进程在往磁盘读写数据时，需要与中断相互配合，因此需要信号量的配合。

![image-20250710162706970](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250710162706970.png)

# 6.`FAT16`文件系统

​	磁盘上的分区实质就是很多连续扇区的集合。针对如何利用这些扇区来存储文件，有非常多种方法。这些管理方法以及相应的数 据结构，称之为文件系统。

![image-20250710173218763](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250710173218763.png)

​	可以考虑让文件在磁盘上连续存储，但是当存储了大量大小不同的文件，并且经过多次删除、创建等操作后，易形成碎片。

![image-20250710183713965](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250710183713965.png)

​	FAT16文件系统简单，非常适合学习。其采用的是不连续地存储，即将磁盘上的扇区组织成了簇，然后将簇涟接起来表示某个特 定的文件。

![image-20250710184022583](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250710184022583.png)

​	因此，FAT16将文件数据和连接关系分开存储。

![image-20250710184541641](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250710184541641.png)

​	当分区上大量存储的是大文件时，则需要较多的`FAT`表项来表示一个大文件中所有数据块的链接关系。因此，为减少`FAT`表项的 数量，`FAT16`采用簇来表示存储数据的基本数据块。

​	`FAT`分区的存储划分。

![image-20250710184836126](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250710184836126.png)

## 6.1 挂载`FAT16`文件系统



![image-20250710190855141](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250710190855141.png)	在FAT16文件系统的DBR区域，可以详细的划分为如下几块区域。挂载FAT16文件系统，其主要功能是从该区域中读取有关FAT16文件系统相关的配置信息，以便为后续地文件读写操作准备。


















































# 1.利用内联汇编显示字符串

## 1.1 基本功能

​	通过反复调用`BIOS`显示字符的方式来显示一个完整的字符串。

​	该功能将用于loader在初始化过程在jog你显示初始化进度错误信息等，具体实现较为简单。

`show_msg`

```c
static void show_msg(const char *msg)
{
    char c;
    while ((c = *msg++) != '\0')
    {
        /**
         * mov $0xe,%ah\n\t
         * mov $'L',%al\n\t
         * mov int $0x10
         */
        __asm__ __volatile__("mov $0xe,%%ah\n\t"
            "mov %[ch],%%al\n\t"
            "int $0x10" ::[ch] "r"(c));
    }
}
```

## 1.2 检测内存容量

### 1.2.1内存检测方法 `INT 0x15,EAX = 0XE820`

1. **第一次调用时**：
   - `ES`:`DI`存储保存读取的信息的存储位置。
   - 清除`EBX`，设置为`0`。
   - `EDX`需要设置成：`0x534D4150`。
   - `EAX`设置成：`0xE820`。
   - `ECX`设置成：`24`。
   - 执行`INT 0x15`。
   - 返回结果：`EAX = 0x534D4150`，`CF`标志清`0`，`EBX`被设置成某个数值用于下次调用，`CL`=实际读取的字节数。

2. **后续调用**：
   - `EDX`需要设置成：`0x534D4150`。
   - `EAX`重设为`0xE820`。
   - `ECX`重设为`24`。
   - 执行`INT 0x15`。
   - 返回结果：`EAX = 0x534D4150`，`CF`标志清`0`。如果`EBX=0`，则表明读取完毕，否则当前条目有效。

这种方法通过特定的寄存器设置和中断指令来实现内存信息的读取和处理。

```c
// 内存检测信息结构
typedef struct SMAP_entry {
    uint32_t BaseL; // base address uint64_t
    uint32_t BaseH;
    uint32_t LengthL; // length uint64_t
    uint32_t LengthH;
    uint32_t Type; // entry Type
    uint32_t ACPI; // extended
}__attribute__((packed)) SMAP_entry_t;

/**
 * @brief        : 检测内存容量
 * @return        {*}
 **/
static void detect_memory(void)
{
    uint32_t contID = 0;
    SMAP_entry_t smap_entry;
    int signature, bytes;

    show_msg("detecting memory:");

    // 初次：EDX=0x534D4150,EAX=0xE820,ECX=24,INT 0x15, EBX=0（初次）
    // 后续：EAX=0xE820,ECX=24,
    // 结束判断：EBX=0
    boot_info.ram_region_count = 0;
    for (int i = 0; i < BOOT_RAM_REGION_MAX; i++)
    {
        SMAP_entry_t *entry = &smap_entry;

        __asm__ __volatile__("int  $0x15"
                             : "=a"(signature), "=c"(bytes), "=b"(contID)
                             : "a"(0xE820), "b"(contID), "c"(24), "d"(0x534D4150), "D"(entry));
        if (signature != 0x534D4150)
        {
            show_msg("detect failed.\r\n");
            return;
        }

        // todo: 20字节
        if (bytes > 20 && (entry->ACPI & 0x0001) == 0)
        {
            continue;
        }

        // 保存RAM信息，只取32位，空间有限无需考虑更大容量的情况
        if (entry->Type == 1)
        {
            boot_info.ram_region_cfg[boot_info.ram_region_count].start = entry->BaseL;
            boot_info.ram_region_cfg[boot_info.ram_region_count].size = entry->LengthL;
            boot_info.ram_region_count++;
        }

        if (contID == 0)
        {
            break;
        }
    }
    show_msg("detect successful\r\n");
}

```

## 1.3进入保护模式

### 1.3.1实模式

​	x86在上电启动后自动进入实模式，即==16位工作==模式，这种模式是最早期的8086芯片所使用的工作模式。早期的芯片设计得较简单、工作模式也较简单，所以有诸多限制：

- 最大只能访问`1MB`的内存：采用段值：偏移的方式访问，内核寄存器最大为16位宽。如段寄存器`CS`, `DS`, `ES`, `FS`, `GS`,  `SS`均为16位宽，`AX`, `BX`, `CX` `DX`, `SI`, `DI`, `SP`等也均为16位宽
- 所有的操作数最大为16位宽，出栈入栈也以16位为单位
- ==没有任何保护机制==，意味着应用程序可以读写内存中的任意位置
- ==没有特权级支持==，意味着应用程序可以随意执行任何指令，例如停机指令、关中断指令
- ==没有分页机制和虚拟内存的支持==

​	将这种模式理解为一种比较原始、粗暴、简单的工作模式。虽然其有这些限制，但是这种模式下可以使用BIOS提供的服务，方便我们显示字符、读取磁盘等。

### 1.3.2 保护模式

​	在后续的芯片设计中，`intel`为处理器增加了一些新的功能，可以实现某些保护功能，即保护模式。具体的特点如下：

- 寄存器位宽扩展至32位，例如AX扩展至32位的`EAX`，最大可访问4GB内存
- 所有操作数最大为32位宽，出入栈也为32位
- 提供4种特权级。操作系统可以运行在最高特权级，可执行任意指令；应用程序可运行于最低特权级，避免其执行某些特权指令，例如停机指令、关中断指令
- 支持虚拟内存，可以开启分页机制，以隔离不同的应用程序

### 1.3.3 基本流程(实模式切换至保护模式)

从实模式切换至保护模式，需遵循一定的流程：

![image-20250405142307546](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250405142307546.png)

1. 禁用中断
2. 打开`A20`地址线
3. 加载`GDT`表
4. 设置`CR0`的保护使能位
5. 远跳转，清空流水线

**禁用中断:**

```c
/**
 * @brief        : 关中断
 * @return        {*}
 **/
static inline void cli(void)
{
    __asm__ __volatile__("cli");
}
```

**开启`A20`地址线**：

```assembly
in al, 0x92
or al, 2
out 0x92,al
```

```c
/**
 * @brief        :从I/O端口读取一个字节
 * @param         {uint16_t} port:端口号
 * @return        {*}读取的字节
 **/
static inline uint8_t inb(uint16_t port)
{
    uint8_t rv;
    /**
     * inb al,dx
     */
    __asm__ __volatile__("inb %[p],%[v]" : [v] "=a"(rv) : [p] "d"(port));
    return rv;
}
/**
 * @brief        : 往指定端口写数据
 * @param         {uint16_t} port:端口号
 * @param         {uint8_t} data:要写的数据
 * @return        {*}
 **/
static inline void outb(uint16_t port, uint8_t data)
{
    /**
     * outb al,dx
     */
    __asm__ __volatile__("outb %[v],%[p]" ::[p] "d"(port), [v] "a"(data));
}

// 开启A20地址线,使得可以访问1M以上的空间
uint8_t v = inb(0x92);
outb(0x92,v|0x2);
```

**加载gdt表：**

```c
/**
 * @brief        : 加载gdt表(全局描述符)
 * @param         {uint32_t} start: 起始地址
 * @param         {uint32_t} size: 大小
 * @return        {*}
 **/
static inline void lgdt(uint32_t start, uint32_t size)
{
    // gdt表的信息
    struct
    {
        uint16_t limit;
        uint16_t start15_0;
        uint16_t start31_16;
    } gdt;
    gdt.start31_16 = start >> 16;//获取高16位
    gdt.start15_0 = start & 0xFFFF;//获取低16位
    gdt.limit = size - 1;//大小
    __asm__ __volatile__("lgdt %[g]" ::[g] "m"(gdt));
}

```

**开启保护位:**

​	此项需要设置`CR0`寄存器的`PE`位为1。`CR0`无法直接读写，必须先读取到某个中间寄存器，修改值后，再将值回写到`CR0`中。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1651816387132-d4874201-1a7b-4f12-936f-94a10617f2ac.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

```c
/**
 * @brief        : 远跳转指令
 * @param         {uint32_t} selector: 选择子
 * @param         {uint32_t} offset: 偏移量
 * @return        {*}
 **/
static inline void far_jump(uint32_t selector, uint32_t offset)
{
    uint32_t addr[] = {offset, selector};
    __asm__ __volatile__("ljmpl *(%[a])" ::[a] "r"(addr));
}
```

> - 实模式：https://wiki.osdev.org/Real_Mode
> - A20地址线：https://blog.csdn.net/sinolover/article/details/93877845

**整块代码：**

```c
static void enter_protect_mode()
{
    // 关中断
    cli();
    // 开启A20地址线,使得可以访问1M以上的空间
    uint8_t v = inb(0x92);
    outb(0x92, v | 0x2);
    // 设置gdt表
    lgdt((uint32_t)gdt_table, sizeof(gdt_table));
    // 读取cr0
    uint32_t cr0 = read_cr0();
    // 写cr0
    write_cr0(cr0 | (1 << 0));
    // 远跳转指令
    far_jump(8, (uint32_t)protect_mode_entry);
}
```

​	`protect_mode_entry`在头文件中申明并在`/loader/start.asm`中定义。其内容如下：

```asm
protect_mode_entry:
	// 重新加载所有的数据段描述符
	mov $16, %ax
	mov %ax, %ds
	mov %ax, %ss
	mov %ax, %es
	mov %ax, %fs
	mov %ax, %gs
	// 长跳转进入到32位内核加载模式中
	jmp $8, $load_kernel
```

​	通过上述设置后即可进入保护模式(32位模式)拥有`4GB`的内存，同时可以观察到`cs`,`ds`,`ss`,`es`等由16位模式变成32位模式。

![image-20250405215529083](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250405215529083.png)

![image-20250405215755318](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250405215755318.png)

# 2.使用LBA模式读取磁盘（LBA48模式）

​	由于进入保护模式后，无法使用BIOS中断的磁盘读取服务。由于读取的磁盘数据会放在1MB以上的内存区域，所以也不便于在进入保护模式前使用BIOS的磁盘读取服务来读取。

## 2.1 LBA48模式

LBA48模式将硬盘上所有的扇区看成线性排列，没有磁盘、柱面等概念，因此访问起来更加简单，扇区序号从0开始。其访问序列如下：

```c
outb(0x1F6,0x40|(slave<<4)); // 选择硬盘:主盘或者从盘

outb(0x1F2,sector_count highbyte);
outb(0x1F3,LBA4);
outb(0x1F4,LBA5);
outb(0x1F5,LBA6);

outb(0x1F2,sector_count low byte);
outb(0x1F3,LBA1);
outb(0x1F4,LBA2);
outb(0x1F5,LBA3);

Send the "READ SECTORS EXT" command(0x24) to port 0x1F7:
outb(0x1F7,0x24);
```

**各寄存器说明如下：**


| 寄存器偏移 | 读写 | 功能 |
| :-: | :-: | :-: |
| 0 | `R/W` | 数据寄存器 |
| 1 | `R` | 错误寄存器 |
| 1 | `W` | 特性寄存器 |
| 2 | `R/W` | 扇区数量寄存器 |
| 3 | `R/W` | `Sector Number Register (LBAlo)` |
| 4 | `R/W` | `Cylinder Low Register / (LBAmid)` |
| 5 | `R/W` | `Cylinder High Register / (LBAhi)` |
| 6 | `R/W` | `Drive / Head Register` |
| 7 | `R` | 状态寄存器 |
| 7 | `W` | 命令寄存器 |

**其中0x1F6寄存器(Drive/Head)对应的位如下：**

|  位  | 名称  | 功能                                |
| :--: | :---: | :---------------------------------- |
| 0~3  |       | 在bits 24 to 27 of the block number |
|  4   | `DRV` | 驱动号                              |
|  5   |   1   |                                     |
|  6   | `LBA` | 对LBA模式，总为1                    |
|  7   |   1   |                                     |

**Status Register(I/O base + 7)：**

| 位   | 名称   | 功能                         |
| ---- | ------ | ---------------------------- |
| 0    | `ERR`  | 发生错误                     |
| 1    | `IDX`  |                              |
| 2    | `CORR` |                              |
| 3    | `DRQ`  | 就绪，可以写数据或者读取数据 |
| 4    | `SRV`  |                              |
| 5    | `DF`   |                              |
| 6    | `RDY`  |                              |
| 7    | `BSY`  | 忙                           |

> **参考资料:**
> ●硬盘访问模式及相关寄存器：https://wiki.osdev.org/ATA_PIO_Mode

`read_disk()`实现如下：

```c
/**
 * @brief        : 使用LBA48模式读取磁盘
 * @param         {uint32_t} sector: 扇区号
 * @param         {uint32_t} sector_count: 扇区数量
 * @param         {uint8_t *} buff: 输入缓冲区
 * @return        {*}
 **/
static void read_disk(uint32_t sector, uint32_t sector_count, uint8_t *buf)
{
    outb(0x1F6, (uint8_t)(0xE0));

    outb(0x1F2, (uint8_t)(sector_count >> 8));
    outb(0x1F3, (uint8_t)(sector >> 24)); // LBA参数的24 ~ 31位
    outb(0x1F4, (uint8_t)(0));            // LBA参数的32~39位
    outb(0x1F5, (uint8_t)(0));            // LBA参数的40~47位

    outb(0x1F2, (uint8_t)(sector_count));
    outb(0x1F3, (sector));               // LBA参数的0~7位
    outb(0x1F4, (uint8_t)(sector >> 8)); // LBA参数的8~15位
    outb(0x1F5, (sector >> 16));         // LBA参数的16~23位

    outb(0x1F7, (uint8_t 0x24));

    // 读取数据
    uint16_t *data_buf = (uint16_t *)buf;
    while (sector_count-- > 0)
    {
        // 每次扇区读之前都要检查,等待数据就绪
        while ((inb(0x1F7) & 0x88))
        {
        }

        // 读取数据并将数据写入到缓存中
        for (int i = 0; i < SECTOR_SIZE / 2; i++)
        {
            *data_buf++ = inw(0x1F0);
        }
    }
}
```

> [!CAUTION]
>
> 这里遵循`LBA48`的读取方式
>
> 首先是读取扇区数量的高8位
>
> 然后是 24 --- 31
>
> 然后是 32 --- 39
>
> 然后是 40 --- 47
>
> 再然后是 要读取的扇区数量的低8位
>
> 然后是是 0---7 位
>
> 然后是   8---15
>
> 然后是   16---32



`inw`指令的实现：

```c
static inline uint16_t inw(uint16_t  port) {
	uint16_t rv;
	__asm__ __volatile__("in %1, %0" : "=a" (rv) : "dN" (port));
	return rv;
}
```

## 2.2 创建内核工程

生成的内核在磁盘以及内存中的位置，目前如下（后续还将进行调整）。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1651873636288-14a7e1f8-1a05-4fa5-8302-b58f8baa413b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

​	实际上，上述位置的确定并不唯一，可自行选择合适的地址，只要保证`loader`能够正确加载即可。
​	可以看到，在第100扇区之前预留了比较大的空间，目的是以后`loader`代码量增大时，有足够的空间存放，不必再临时调整`kernel`的位置。

​	通过函数指针 `  ((void (*)(void))SYS_KERNEL_LOAD_ADDR)();`跳转到`kernel`运行。

`loader`加载`kernel`流程：

```ascii
										+-----------------------+
										| loader加载内核到       |
										| SYS_KERNEL_LOAD_ADDR   |
										+-----------------------+
										          |
										          v
										+-----------------------+
										| 调用 ((void (*)())     |
										| SYS_KERNEL_LOAD_ADDR)()|
										+-----------------------+
										          |
										          v
										+-----------------------+
										| 进入_start()           |
										| (kernel/init/start.S)  |
										+-----------------------+
										          |
										          v
										+-----------------------+
										| 调用kernel_init()      |
										| (kernel/init/init.c)   |
										+-----------------------+
```

# 3.向内核传递启动信息

## 3.1 x86的栈

​	保护模式下（32位模式下），x86的栈单元为32位，压栈时总是先`esp-4`，再写入数据；出栈过程则正好相反，先取出数据，再`esp+4`。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1651898342404-568a9696-f5d7-408d-943e-c2216efe04b0.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

![image-20250410151147384](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250410151147384.png)

​	在`C`函数中，编译器会根据定义的局部变量、计算过程、函数调用按照一定的规范自动规划栈的使用。具体的使用方法如下：

- 保存局部变量和数据
- 传递参数：从参数列表右侧往左压入栈
- 保存返回地址
- 通过`ebp+`偏移取调用者的传入的参数和自己的局部变量

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1651898430771-ff7a5f6e-8a33-4c29-8901-fe8b10b461df.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

​	项目中实际上时做了从`loader`到`kernel`的两级函数调用。

```c
load_kernel()
    
	--> ((void (*)(boot_info_t *))SYS_KERNEL_LOAD_ADDR)
    
    	-->kernel_init(boot_info)
```

​	我们所做的工作实际上理解编译器对栈的分配处理规则，取出`load_kernel`传过来的参数，再通过栈传给`kernel_init`。有以下两种处理方法：

```assembly
//第一种方法
push %ebp
mov %esp, %ebp
mov 0x8(%ebp), %eax
push %eax
 
 
//第二种方法
mov 4(%esp), %eax
push %eax
 
//第三种方法
push 4(%esp)

//kernel_init(boot_info)
//call kernel_init
```

通过栈传递信息的过程：

```c
阶段一：loader调用内核入口
	1.初始阶段
	((void (*)(boot_info_t *))SYS_KERNEL_LOAD_ADDR)(&boot_info);

				栈顶(高地址) +---------------+
				            |   ...         |  <- 其他栈内容
				            +---------------+  
				栈底(低地址) |               |  <- ESP
    
	2.参数入栈
				栈顶(高地址) +---------------+
				            |   ...         |
				            +---------------+
				            | &boot_info    |  <- 参数入栈
				            +---------------+
				栈底(低地址) |               |  <- ESP
                    
	3.调用指令执行
				栈顶(高地址) +---------------+
				            |   ...         |
				            +---------------+
				            | &boot_info    |  <- 函数参数
				            +---------------+
				            | 返回地址      |  <- 实际上永远不会返回到这里
				            +---------------+
				栈底(低地址) |               |  <- ESP
  
    	现在控制权转移到 _start（SYS_KERNEL_LOAD_ADDR 地址）。
  
阶段二：内核汇编入口_start的栈操作
    4.执行push %ebp   保存旧的帧指针
				栈顶(高地址) +---------------+
				            |   ...         |
				            +---------------+
				            | &boot_info    |  <- 函数参数
				            +---------------+
				            | 返回地址      |  <- loader中的返回地址
				            +---------------+
				            | 旧的 EBP      |  <- 保存的帧指针
				            +---------------+
				栈底(低地址) |               |  <- ESP
               
    
    5.执行mov %esp, %ebp  建立新的栈帧：
				栈顶(高地址) +---------------+
				            |   ...         |
				            +---------------+
				            | &boot_info    |  <- EBP+8
				            +---------------+
				            | 返回地址      |  <- EBP+4
				            +---------------+
				            | 旧的 EBP      |  <- EBP 现在指向这里
				            +---------------+
				栈底(低地址) |               |  <- ESP
    
    6.执行mov 0x8(%ebp),%eax 加载参数到寄存器（但栈不变）：
				栈顶(高地址) +---------------+
				            |   ...         |
				            +---------------+
				            | &boot_info    |  <- EBP+8 (这个值被加载到EAX)
				            +---------------+
				            | 返回地址      |  <- EBP+4
				            +---------------+
				            | 旧的 EBP      |  <- EBP
				            +---------------+
				栈底(低地址) |               |  <- ESP
    
    此时 EAX = &boot_info
    7. 执行 push %eax ,为调用 kernel_init 准备参数：
				栈顶(高地址) +---------------+
				            |   ...         |
				            +---------------+
				            | &boot_info    |  <- 原始参数(EBP+8)
				            +---------------+
				            | 返回地址       |  <- EBP+4
				            +---------------+
				            | 旧的 EBP      |  <- EBP
				            +---------------+
				            | &boot_info    |  <- 作为参数再次入栈
				            +---------------+
				栈底(低地址) |               |  <- ESP
                    
    8. 执行 call kernel_init
				栈顶(高地址) +---------------+
				            |   ...         |
				            +---------------+
				            | &boot_info    |  <- 原始参数(EBP+8)
				            +---------------+
				            | 返回地址      |  <- EBP+4
				            +---------------+
				            | 旧的 EBP      |  <- EBP
				            +---------------+
				            | &boot_info    |  <- kernel_init的参数
				            +---------------+
				            | 返回地址      |  <- 返回到_start的地址
				            +---------------+
				栈底(低地址) |               |  <- ESP
```



# 4.代码段数据段与链接脚本

![image-20250410155008536](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250410155008536.png)

![image-20250410155408778](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250410155408778.png)

```
.text -- 代码段
.bss  -- 全局变量(未初始化),静态变量(未初始化)
.data -- 全局变量,静态局部变量(有初始化)
.rodata -- 常量
```

![image-20250410155849078](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250410155849078.png)

![image-20250410160159206](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250410160159206.png)

# 5.加载内核映像文件

## 5.1原理说明

当前存储规划如下图：

![image-20250410163722258](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250410163722258.png)

二进制映像文件的内容是按程序最终在内存中的分布来组织的

![image-20250410163925431](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250410163925431.png)

为了更好地组织程序和数据，一般需要专用的文件格式，如PE格式或者`elf`格式。
`ELF`用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件的文件格式

![image-20250410164133452](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250410164133452.png)

`elf`加载过程

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1652394893005-e5f0a2e2-fc77-47ee-bea6-2c0fcf581dbd.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

修改`CMakeLists.txt`文件

```cmake
# bin文件生成，写入到image目录下
add_custom_command(TARGET ${PROJECT_NAME}
                   POST_BUILD
                   # 不使用 - O binary 添加 - S 对elf文件瘦身
                   COMMAND ${OBJCOPY_TOOL} -S ${PROJECT_NAME}.elf ${CMAKE_SOURCE_DIR}/../image/${PROJECT_NAME}.elf
                   COMMAND ${OBJDUMP_TOOL} -x -d -S -m i386 ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.elf > ${PROJECT_NAME}_dis.txt
                   COMMAND ${READELF_TOOL} -a ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.elf > ${PROJECT_NAME}_elf.txt
)
```

## 5.2 对`elf`文件进行解析

### 5.2.1ELF文件格式

​	`windows`的可执行文件格式通常为`.exe`结尾的`PE` 文件格式，而`linux/unix`用得更多的则为`elf`文件格式。
我们的工具链编译生成的即为这种文件格式。此种文件格式结构简要图如下。对我们而言，只需要关注下图右半部分（即`Execution View`，左半部分是给链接器用的）。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1652155264083-b587906a-6c66-4b42-99cd-aca3dab23009.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

​	该文件中包含了前一节课时中提到`.text/.rodata/.data/.bss`各段的信息。通常解析该文件，找到`program header table`，从该表中，即可从中读取出相应的代码、数据段的相关信息，并可根据该信息将代码或数据加载到对应的内存中，完成整个加载过程。
其中`elf header`包含了有关该文件的全局性配置数据，以及描述了该文件的具体结构，其位于文件的最开头。

​	相关定义如下：

```c
/**
 * @FilePath     : /code/source/comm/elf.h
 * @Description  :  elf头文件
 * @Author       : ys 2900226123@qq.com
 * @Version      : 0.0.1
 * @LastEditors  : ys 2900226123@qq.com
 * @LastEditTime : 2025-04-11 15:15:46
 * @Copyright    : G AUTOMOBILE RESEARCH INSTITUTE CO.,LTD Copyright (c) 2025.
 **/

#ifndef OS_ELF_H
#define OS_ELF_H

#include "types.h"

// ELF相关数据类型
typedef uint32_t Elf32_Addr;
typedef uint16_t Elf32_Half;
typedef uint32_t Elf32_Off;
typedef uint32_t Elf32_Sword;
typedef uint32_t Elf32_Word;

#pragma pack(1)

// ELF Header
#define EI_NIDENT 16
#define ELF_MAGIC 0x7F

typedef struct
{
    char e_ident[EI_NIDENT]; // elf标识
    Elf32_Half e_type; // ELF文件类型
    Elf32_Half e_machine; // 目标文件体系类型，即运行架构,x86,riscv,arm等
    Elf32_Word e_version; // 目标文件版本
    Elf32_Addr e_entry; // elf 入口地址
    Elf32_Off e_phoff; // 程序头部偏移
    Elf32_Off e_shoff; // 节区头部偏移
    Elf32_Word e_flags; // 
    Elf32_Half e_ehsize; // ELF 格式头部大小
    Elf32_Half e_phentsize; 
    Elf32_Half e_phnum;
    Elf32_Half e_shentsize;
    Elf32_Half e_shnum;
    Elf32_Half e_shstrndx;
} Elf32_Ehdr;

/**
e_ident[**]                   //elf标识
e_type;                       //elf类型（上述三种类型）
e_ machine;               //目标文件体系类型，即运行架构，如x86、riscv、arm等
e_version;                  //目标文件版本
e_entry;                      //elf入口地址
e_ phoff;                     //程序头部偏移
e_shoff;                      //节区头部偏移
e_flags;                     
e_ehsize;                  //ELF格式头部大小
e_phentsize;             //程序头部表项大小
e_phnum;                  //程序头表项个数，即segment数
e_shentsize;              //节区头部表项大小
e_shnum;                  //节区表项个数，即section数
e_shstrndx;
**/
#define PT_LOAD 1

typedef struct
{
    Elf32_Word p_type;
    Elf32_Off p_offset;
    Elf32_Addr p_vaddr;
    Elf32_Addr p_paddr;
    Elf32_Word p_filesz;
    Elf32_Word p_memsz;
    Elf32_Word p_flags;
    Elf32_Word p_align;
} Elf32_Phdr;
/*
p_type;                    //segment类型
p_offset;                  //segment在文件中的偏移
p_vaddr;                 //segment虚地址
p_paddr;                 //物理地址
p_filesz;                  //文件中segment字节数
p_memsz;              //内存中segment字节数
p_flags;
p_align;
*/
#pragma pack()
#endif

```

> [!NOTE]
>
> 对于结构体中的每个成员，如果 <n> 小于该成员的默认对齐大小（关于默认对齐大小，可参考上文中提到的博文），则使用 <n> bytes 作为该成员的对齐大小。如果<n> 大于默认对齐大小，则使用默认对齐大小。简言之，**使用<n> 和默认对齐大小中较小的那个，作为该数据成员的对齐大小。** 详情见： [__alignof__](https://developer.arm.com/documentation/101754/0620/armclang-Reference/Compiler-specific-Keywords-and-Operators/--alignof--).

​	该结构体描述了需要加载到内存中的相关配置信息，我们可以根据其中配置，进行解析加载。具体加载过程如下：

- 初步检查`elf header`的合法性（本项目只做了非常简单的检查）
- 通过`elf header -> e_phoff `定位到 `program header table` ，遍历`elf header -> e_phhum`次，加载各个段
  - 从文件位置`p_offset`处读取`filesz`大小的数据，写入内存中的`paddr`的位置处
  - 如果`p_filesz < p_memsz` 则将内存清零(bss区初始化)

- 取`elf header -> e_entry` ,跳转到该地址运行

​	从上述流程可以看出，在C代码中定义的未初始化的全局变量（分配在`BSS`区，初始值为0），并没有在`ELF`中分配相应的空间，需要自己在内存中手动清0.
下图仅为某`elf`文件的内容存储示例，不同`elf`文件可能组织不同。课程视频中所展示的为`text, rodata, data, bss`被组织在一起，而非下图的分开存放。

​	![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1652394893005-e5f0a2e2-fc77-47ee-bea6-2c0fcf581dbd.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

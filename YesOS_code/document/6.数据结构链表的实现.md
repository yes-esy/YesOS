# 1.定义结点和链表

​	本项目所实现的链表为双向链表，级每个结点包含两个指针：`next`指向后继结点，`pre`指向前驱结点。同时定义了一个链表结构`list_t`。

```c
/* 结点 */
typedef struct _list_node_t
{
    struct _list_node_t *pre;
    struct _list_node_t *next;
} list_node_t;
```

```c
/* 链表结构 */
typedef struct _list_t
{
    list_node_t *first; // 指向第一个结点
    list_node_t *last;  // 指向下一个结点
    int count;
} list_t;
```

相关函数接口：

```c
/**
 * @brief        : 链表节点初始化;
 * @param         {list_node_t *} node: 需要初始化的节点
 * @return        {*}
 **/
static inline void list_node_init(list_node_t *node)
{
    node->pre = node->next = (list_node_t *)0;
}

/**
 * @brief        : 链表的前驱节点
 * @param         {list_node_t *} node: 当前节点
 * @return        {list_node_t *} 当前节点的前去节点
 **/
static inline list_node_t *list_node_pre(list_node_t *node)
{
    return node->pre;
}

/**
 * @brief        : 链表的后继节点
 * @param         {list_node_t *} node: 当前节点
 * @return        {list_node_t *} 当前节点的后继节点
 **/
static inline list_node_t *list_node_next(list_node_t *node)
{
    return node->next;
}

typedef struct _list_t
{
    list_node_t *first; // 指向第一个结点
    list_node_t *last;  // 指向下一个结点
    int count;          // 链表中的结点个数
} list_t;

// 链表初始化函数
void list_init(list_t *list);

/**
 * @brief        : 判断链表是否为空
 * @param         {list_t} *list: 需要判断的链表
 * @return        {int}: 为1表示为空,0表示不为空
 **/
static inline int list_is_empty(list_t *list)
{
    return list->count == 0;
}
/**
 * @brief        : 返回链表的头结点
 * @param         {list_t} *list: 链表
 * @return        {list_node_t*}: 链表的头结点
 **/
static inline list_node_t *list_first(list_t *list)
{
    return list->first;
}
/**
 * @brief        : 返回链表的尾结点
 * @param         {list_t} *list: 对应链表
 * @return        {list_node_t*}: 链表尾结点
 **/
static inline list_node_t *list_last(list_t *list)
{
    return list->last;
}
/**
 * @brief        : 返回链表的结点数量
 * @param         {list_t} *list: 对应链表
 * @return        {int}: 链表数量
**/
static inline int list_count(list_t *list)
{
    return list->count;
}
```

基本增删的实现：

```c

/**
 * @brief        : 链表初始化函数
 * @param         {list_t *} list: 待初始化的链表
 * @return        {*}
 **/
void list_init(list_t *list)
{
    list->first = list->last = (list_node_t *)0;
    list->count = 0;
}
/**
 * @brief        : 链表头部插入结点
 * @param         {list_t} *list: 待插入的链表
 * @param         {list_node_t} *node: 待插入的结点
 * @return        {*}
**/
void list_insert_first(list_t *list, list_node_t *node)
{
    node->next = list->first;
    node->pre = (list_node_t *)0;
    // 链表为空;
    if (list_is_empty(list))
    {
        list->first = list->last = node;
    }
    else
    {
        list->first->pre = node;
        list->first = node;
    }
    list->count++;
}

/**
 * @brief        : 链表尾部插入结点
 * @param         {list_t} *list: 待插入的链表
 * @param         {list_node_t} *node: 待插入的结点
 * @return        {*}
**/
void list_insert_last(list_t *list, list_node_t *node)
{
    node->pre = list->last;
    node->next = (list_node_t *)0;

    if (list_is_empty(list))
    {
        list->first = list->last = node;
    }
    else
    {
        list->last->next = node;
        list->last = node;
    }
    list->count++;
}
/**
 * @brief        : 移除链表的头结点
 * @param         {list_t} *list: 待移除结点的链表的指针
 * @return        {list_node_t*}: 被移除的结点的指针
 **/
list_node_t *list_remove_first(list_t *list)
{
    if (list_is_empty(list))
    {
        return (list_node_t *)0;
    }

    list_node_t *remove_node = list->first;

    list->first = remove_node->next;

    if (list->first == (list_node_t *)0)
    {
        list->last = (list_node_t *)0;
    }
    else
    {
        remove_node->next->pre = (list_node_t *)0;
        // list->first->pre = (list_node_t *) 0;
    }

    remove_node->pre = remove_node->next = (list_node_t *)0;
    list->count--;
    return remove_node;
}

/**
 * @brief        : 移除链表中的指定结点
 * @param         {list_t} *list: 待移除结点的链表的指针
 * @param         {list_node_t} *node: 需要移除的结点的指针
 * @return        {list_node_t*}: 被移除的结点的指针
**/
list_node_t *list_remove(list_t *list, list_node_t *node)
{
    if (node == list->first)
    {
        list->first = node->next;
    }

    if (node == list->last)
    {
        list->last = node->pre;
    }

    if (node->pre)
    {
        node->pre->next = node->next;
    }

    if (node->next)
    {
        node->next->pre = node->pre;
    }
    node->pre = node->next = (list_node_t *)0;

    list->count--;
    return node;
}
```

# 2.获取结点所在的结构体

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1661605298247-9f28ded1-f35a-4e40-b164-12430c7d4fd4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_35%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

实现：

```c
/**
 * 1. 求结点在所在结构中的偏移:
 * 定义一个指向0的指针，用(struct aa *)&0->node，
 * 所得即为node字段在整个结构体的偏移
 */
#define offset_in_parent(parent_type, node_name) \
    ((uint32_t)&(((parent_type *)0)->node_name))

/**
 * 2. 求node所在的结构体首址：node的地址 - node的偏移
 * 即已知a->node的地址，求a的地址
 */
#define offset_to_parent(node, parent_type, node_name) \
    ((uint32_t)node - offset_in_parent(parent_type, node_name))

/**
 * 3. 进行转换: (struct aa *)addr
 * list_node_parent(node_addr, struct aa, node_name)
 */
#define list_node_parent(node, parent_type, node_name) \
    ((parent_type *)(node ? offset_to_parent((node), parent_type, node_name) : 0))

```

​	其中

```
#define offset_in_parent(parent_type, node_name)      ((uint32_t)&(((parent_type*)0)->node_name))
```

​	该宏计算某个结构体成员相对于整个结构体中的偏移量（字节计）。

​	`((parent_type*)0)`用于获得一个指向地址`0`处的`parent_type`类型的指针。为了访问该结构体中的`node_name`成员，可以使用表达式`((parent_type*)0)->name`，而要获取其地址，可以再使用取地址符`&((parent_type*)0)->name`。

​	显然，`name`相对于整个结构体开始的地址偏移量应当为：`((parent_type*)0)->name`的地址 - `((parent_type*)0)`的地址。而由于`((parent_type*)0)`的地址即为0，所以偏移量就等于`((parent_type*)0)->name`的地址。
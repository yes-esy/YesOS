

# 1.内存管理问题

## 1.1 分页处理

​	在分页机制中，CPU将内存看作一块块固定大小的内存页。这个页大小使用的是硬件支持的4KB大小的页。也就是说，操作系统需要将内存视作大量4KB的内存页的集合，当应用程序和操作系统需要使用内存时，就分配4KB大小的内存页供其使用。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/12764787/1672965255657-fb4f3bac-eb03-42f4-bc7c-e4fbec78aef1.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

​	引入了这种机制之后，一个应用程序运行起来后，其所占用的内存会在分页机制的管理下，映射成实际物理内存中的多个页中。**也就是当应用程序需要新的内存时，就从整个物理内存中找到一个空闲的内存页给它。**

![image.png](https://cdn.nlark.com/yuque/0/2023/png/12764787/1672965367009-c45936c8-f7cf-4f6e-bb7e-caf6a512d282.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_34%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

​	当然，如此一来也带来了一些问题，就是如上图中所到的，应用程序在内存的空闲中分布是不连续的。因此，硬件提供了分页机制来解决这个问题。

​	如下图所示，每个应用程序在运行起来后都有一个地址转换的页表，这个页表可以将进程它访问的地址进行转换，转换到某个右侧的某个物理页。而进程自己看到的则是左侧的内存分布，它所看到的是自己分布在连续的内存空间中。（具体转换原理会在后面说明）

![image.png](https://cdn.nlark.com/yuque/0/2023/png/12764787/1672965509110-57af657e-4cee-4e46-96ce-e42156342a59.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_31%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

# 2.数据结构——位图的创建于初始化

## 2.1 位图的基本介绍

​	位图是一种非常简单的用于标识某些状态的数据结构，它是很多个位组成的。由于每个位只有0、1两种值，所以可以用于标识一个内存页是否已经被使用。

​	**采用这种结构是因为其实现简单，且占用内存小，保需要一个位就可以表示一个内存页的分配状态。当然，你也可以自行设计其它的数据结构。**

![image-20250607192019094](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250607192019094.png)

```c++
/**
 * @brief 位图数据结构
 */
typedef struct _bitmap_t
{
    int bit_count;  // 位图的总位数
    uint8_t *bits;  // 位图空间
} bitmap_t;

/**
 * @brief        : 获取所需要的字节数量
 * @param         {int} bit_count: 位图位数
 * @return        {int} 需要的字节数
 **/
int bitmap_byte_count(int bit_count)
{
    return (bit_count + 8 - 1) / 8; // 向上取整
}



/**
 * @brief        : 位图初始化
 * @param         {bitmap_t} *bitmap: 位图
 * @param         {uint8_t} *bits:  位图空间
 * @param         {int} count: 位图的总位数
 * @param         {int} init_bit: 初始化为0还是1
 * @return        {*}
 **/
void bitmap_init(bitmap_t *bitmap, uint8_t *bits, int count, int init_bit)
{
    bitmap->bit_count = count;
    bitmap->bits = bits;

    int bytes = bitmap_byte_count(bitmap->bit_count);

    // 对该位图所在区域清空
    kernel_memset((void *)bitmap->bits, init_bit ? 0xFF : 0, bytes);
}
```

## 2.2 位图的分配

### 2.2.1 置位操作

```c++
/**
 * @brief        : 获取所需要的字节数量
 * @param         {int} bit_count: 位图位数
 * @return        {int} 需要的字节数
 **/
int bitmap_byte_count(int bit_count)
{
    return (bit_count + 8 - 1) / 8; // 向上取整
}

/**
 * @brief        : 连续设置若干位
 * @param         {bitmap_t} *bitmap: 需要设置的位图
 * @param         {int} index: 要操作的起始位索引
 * @param         {int} count: 设置多少个连续的位
 * @param         {int} bit: 置0或1
 * @return        {*}
 **/
void bitmap_set_bit(bitmap_t *bitmap, int index, int count, int bit)
{
    // 
    for (int i = 0; (i < count) && (index < bitmap->bit_count); i++, index++)
    {
        if (bit)
        {
            // index / 8：确定目标位所在的字节位置
            // index % 8: 确定目标位所在的字节偏移位置0~7
            bitmap->bits[index / 8] |= 1 << (index % 8);
        }
        else
        {
            bitmap->bits[index / 8] &= ~(1 << (index % 8));
        }
    }
}

/**
 * @brief        : 获取指定位图索引的分配情况
 * @param         {bitmap_t} *bitmap: 位图指针
 * @param         {int} index: 指定位图的索引
 * @return        {int} 1为已被分配，0为未被分配
 **/
int bitmap_get_bit(bitmap_t *bitmap, int index)
{
    // index/8 第几个字节
    // index%8 index在字节中的偏移量
    // @todo
    return (bitmap->bits[index / 8] & (1 << (index % 8))) ? 1 : 0;
}

/**
 * @brief        : 检查位图某一个位是否被设置，1为已被设置，0为未被设置
 * @param         {bitmap_t} *bitmap:位图指针
 * @param         {int} index: 需要检查的位置的索引
 * @return        {int} 1为已被设置；0为未被设置
 **/
int bitmap_is_set(bitmap_t *bitmap, int index)
{
    return bitmap_get_bit(bitmap, index) ? 1 : 0;
}
```

# 3、创建地址分配结构

​	创建`addr_alloc_t`结构，包括位图，以及其所管理的物理内存区域的起始地址，大小，以及内存页的大小

```c++
typedef struct _addr_alloc_t
{
    bitmap_t bitmap;    // 位图
    uint32_t start;     // 起始地址
    uint32_t size;      // 大小
    uint32_t page_size; // 页大小,块大小
    mutex_t mutex;      // 互斥信号量
} addr_alloc_t;

/**
 * @brief        : 对相应的地址分配结构进行初始化
 * @param         {addr_alloc_t} *alloc: 地址分配结构的指针
 * @param         {uint8_t} *bits: 位图字节缓冲区
 * @param         {uint32_t} start: 起始地址
 * @param         {uint32_t} size: 大小
 * @param         {uint32_t} page_size: 页大小,块大小
 * @return        {*}
 **/
static void addr_alloc_init(addr_alloc_t *alloc, uint8_t *bits, uint32_t start, uint32_t size, uint32_t page_size)
{
    mutex_init(&alloc->mutex);
    alloc->start = start;
    alloc->size = size;
    alloc->page_size = page_size;
    bitmap_init(&alloc->bitmap, bits, alloc->size / page_size, 0);
}
```



#  4、内存规划空间的分配

​	由于操作系统内核较小，因此其重要的数据结构及代码放在`1MB`以下即可。并且QEMU的内存可配置的比较大，所以总的来说机制的内存较为富裕。因此如果不需要节省内存，可以随心所欲一些，将OS的一些东西放在1MB以下的区域，或者1MB以下的内存区域不使用都行。

![image-20250625130116416](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250625130116416.png)

​	![image-20250625130253333](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250625130253333.png)

​	`1M`以下给操作系统使用,`1M`以上给进程使用(按页分配)。OS区域后用于位图缓存。

内存初始化：

```c
/**
 * @brief        : 向下取整到边界整数倍
 * @param         {uint32_t} size: 需要转换的大小
 * @param         {uint32_t} bound: 边界（必须为2的幂）
 * @return        {uint32_t} : 对齐后的结果
 **/
static inline uint32_t down2(uint32_t size, uint32_t bound)
{
    return size & ~(bound - 1);
}
/**
 * @brief        : 向上取整到边界整数倍
 * @param         {uint32_t} size: 需要转换的大小
 * @param         {uint32_t} bound: 边界（必须为2的幂）
 * @return        {uint32_t} : 对齐后的结果
 **/
static inline uint32_t up2(uint32_t size, uint32_t bound)
{
    return (size + bound - 1) & ~(bound - 1);
}
/**
 * @brief        : 向下取整到边界整数倍
 * @param         {uint32_t} size: 需要转换的大小
 * @param         {uint32_t} bound: 边界（必须为2的幂）
 * @return        {uint32_t} : 对齐后的结果
 **/
static inline uint32_t down2(uint32_t size, uint32_t bound)
{
    return size & ~(bound - 1);
}
/**
 * @brief        : 向上取整到边界整数倍
 * @param         {uint32_t} size: 需要转换的大小
 * @param         {uint32_t} bound: 边界（必须为2的幂）
 * @return        {uint32_t} : 对齐后的结果
 **/
static inline uint32_t up2(uint32_t size, uint32_t bound)
{
    return (size + bound - 1) & ~(bound - 1);
}
/**
 * @brief        : 初始化
 * @param         {boot_info_t} *boot_info:启动信息
 * @return        {*}
 **/
void memory_init(boot_info_t *boot_info)
{
    extern uint8_t *mem_free_start; // 指定外部符号,放在bss后面
    log_printf("memory init...");

    show_mem_inifo(boot_info); // 打印启动信息

    uint8_t *mem_free = (uint8_t *)&mem_free_start; // 指向OS后面的内存地址

    uint32_t mem_up1MB_free = total_mem_size(boot_info) - MEM_EXT_START; // 1MB以上内存区域大小

    mem_up1MB_free = down2(mem_up1MB_free, MEM_PAGE_SIZE); // 对齐到4KB, 4KB页大小的整数倍

    log_printf("free memory:0x%x,size:0x%x", MEM_EXT_START, mem_up1MB_free); // 打印内存信息

    addr_alloc_init(&paddr_alloc, mem_free, MEM_EXT_START, mem_up1MB_free, MEM_PAGE_SIZE); // 促使话地址分配结构

    mem_free += bitmap_byte_count(paddr_alloc.size / MEM_PAGE_SIZE); // 跳过位图缓存

    ASSERT(mem_free < (uint8_t *)MEM_EBDA_START);

    create_kernel_table();

    mmu_set_page_dir((uint32_t)kernel_page_dir);
    log_printf("memory success.");
}
```

​	

# 5、内存分配机制

## 5.1.1分页机制介绍

​	分页机制中，操作系统维护一个页表，用于将虚拟内存地址映射到物理内存地址。每个运行中的程序都有自己的虚拟地址空间，这些虚拟地址通过页表转换成实际的物理地址。这样，即使物理内存是分散的，程序也感觉到它们在使用一块连续的内存区域。

![image-20250626110534651](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250626110534651.png)

![image-20250626110622948](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250626110622948.png)

## 5.1.2地址转换

![image-20250626111915688](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250626111915688.png)

​	以上图为例，对于进程需要访问的某一个地址共有32位，前10位用于再页目录表中寻找到对应的页表，接下来的10位用于寻找页表中对应的页，最后12位为其页内的偏移地址

​	我们使用Intel提供的另一种分页的机制。

![image-20250626112359276](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250626112359276.png)

​	这是一种扩展分页机制（类似于一级页表），只有一个页目录表，没有页表，每页固定大小为`4MB`而不是`4KB`，节省页表空间。

## 5.2开启分页机制

​	在loader（1MB以下的内存区域）中打开分页机制，但是会存在打开分页机制后，loader看到的内存地址并不是物理地址，而是经过转换后的，会被映射到其他的内存区域而不是相同的内存区域，我们要保证loader线性地址和实际的物理地址建立相同的物理映射。

![image-20250626113823000](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250626113823000.png)

​	`CR3`指向页目录表的首地址，`PSE位为1`，读写`CR4`

![image-20250626114641475](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250626114641475.png)

```c
static void enable_page_mode()
{
#define PDE_P (1 << 0) // 表项有效
#define PDE_W (1 << 1) // 可写
#define PDE_PS (1 << 7)
#define CR4_PSE (1 << 4)
#define CR0_PG (1 << 31)
    static uint32_t page_dir[1024] __attribute__((aligned(4096))) = {
        [0] = PDE_P | PDE_PS | PDE_W, // PDE_PS，开启4MB的页，对表项0进行处理，因为loader对应表项0所在的0~4MB的内存页。
    }; // 页目录表

    // 设置PSE，以便启用4M的页，而不是4KB
    uint32_t cr4 = read_cr4(); // 读出CR4
    write_cr4(cr4 | CR4_PSE);  // 写CR4

    // 设置页表地址
    write_cr3((uint32_t)page_dir); // 写CR3

    // 开启分页机制，CR0中PG位
    write_cr0(read_cr0() | CR0_PG); // 写CR0
}
```

> `[0] = PDE_P | PDE_PS | PDE_W |0`，loader本身在1MB以下，我们只需要设置转换后也在1MB以下，即一一对应，设置映射后的地址即可。



## 5.4创建内核页表

### 5.4.1建立映射表

​	一个虚拟地址到物理地址的映射关系，应该包括线性起始地址，线性结束地址，实际物理地址，以及特权标识

```c
typedef struct _memory_map_t
{
    void *vstart;  // 线性地址起始地址（虚拟地址）
    void *vend;    // 结束地址
    void *pstart;  // 物理地址
    uint32_t perm; // 特权相关属性
} memory_map_t;
```

![image-20250626151628445](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250626151628445.png)

```c
/**
 * @brief        : 创建内核页表,并根据映射结构创建映射关系
 * @return        {*}
 **/
void create_kernel_table()
{
    extern uint8_t s_text[], e_text[], s_data[], kernel_base[];
    static memory_map_t kernel_map[] = {
    // 线性起始地址,    线性结束地址,   物理地址, 权限标识符
        {kernel_base, s_text, 0, PTE_W},                       // 内核栈区
        {s_text, e_text, s_text, 0},                           // 内核代码区，只读
        {s_data, (void *)(MEM_EBDA_START - 1), s_data, PTE_W}, // 内核数据区
        // 扩展存储空间一一映射，方便直接操作
        {(void *)MEM_EXT_START, (void *)MEM_EXT_END, (void *)MEM_EXT_START, PTE_W},
    };
    // 遍历表项，建立映射关系
    for (int i = 0; i < sizeof(kernel_map) / sizeof(memory_map_t); i++)
    {
        memory_map_t *map = kernel_map + i;

        // 页边界对齐
        uint32_t vstart = down2((uint32_t)map->vstart, MEM_PAGE_SIZE);
        uint32_t vend = up2((uint32_t)map->vend, MEM_PAGE_SIZE);
        uint32_t paddr = down2((uint32_t)map->pstart, MEM_PAGE_SIZE);
        // 页数量
        int page_count = (vend - vstart) / MEM_PAGE_SIZE;

        // 建立映射关系
        memory_create_map(kernel_page_dir, vstart, paddr, page_count, map->perm);
    }
}
```

### 5.4.2页目录和页表结构

#### 页目录结构

![image-20250626154235094](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250626154235094.png)

​	具体定义如下：

```c
/**
 * Page-Directory Entry 页目录项描述结构
 */
typedef union _pde_t
{
    uint32_t v;
    struct
    {
        uint32_t present : 1;       // 是否存在
        uint32_t write_enable : 1;  // 是否可写
        uint32_t user_mode_acc : 1; // 用户模式是否可以访问
        uint32_t write_through : 1; // 决定是否使用写直达缓存策略
        uint32_t cache_disable : 1; // 禁止对该页的缓存
        uint32_t accessed : 1;      // 是否访问过
        uint32_t : 1;               // 保留位，目前没有特定用途，匿名
        uint32_t ps : 1;            // 用于指示大页支持。如果为1，表示这是一个大页条目；如果为0，表示这是一个标准的页表条目。
        uint32_t : 4;               // 未使用到,匿名
        uint32_t phy_pt_addr : 20;  // 二级页表对应的物理地址
    };
} pde_t;
```

#### 	页表结构

![image-20250626154354274](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250626154354274.png)![image-20250626154425879](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250626154425879.png)

​	具体定义如下：

```c
/**
 * Page-Table Entry 页表表项描述结构
 */
typedef union _pte_t
{
    uint32_t v;
    struct
    {
        uint32_t present : 1;        // 是否存在
        uint32_t write_enable : 1;   // 是否可写
        uint32_t user_mode_acc : 1;  // 用户模式是否可以访问
        uint32_t write_through : 1;  // 决定是否使用写直达缓存策略
        uint32_t cache_disable : 1;  // 如果为1，禁止对该页的缓存；如果为0，允许缓存
        uint32_t accessed : 1;       // 记录该页是否被访问过
        uint32_t dirty : 1;          // 表示该页的内容是否已被修改
        uint32_t pat : 1;            // 用于间接确定访问该页所使用的内存类型，
        uint32_t global : 1;         // 该位决定翻译是否是全局的。全局页不会被TLB刷新指令清除，从而提高性能
        uint32_t : 3;                // 未使用到,匿名
        uint32_t phy_page_addr : 20; // 页的物理地址，用于指向实际的物理内存位置
    };
} pte_t;
```

### 5.4.3建立映射表

​	虚拟地址与物理地址之间建立硬件关系，确定物理起始地址、虚拟地址、要建立的映射关系的内存区域大小(页的数量)

```c
/**
 * @brief        : 建立物理地址和虚拟地址的映射关系,指定开始的虚拟起始地址映射到物理起始地址连续count物理页
 * @param         {pde_t} *page_dir: 页目录表地址
 * @param         {uint32_t} vaddr: 线性起始地址
 * @param         {uint32_t} paddr: 物理起始地址
 * @param         {int} count: 映射多少物理页
 * @param         {uint32_t} perm: 权限字段
 * @return        {int} : 建立映射关系成功返回0,失败返回-1
 **/
int memory_create_map(pde_t *page_dir, uint32_t vaddr, uint32_t paddr, int count, uint32_t perm)
{
    for (int i = 0; i < count; i++)
    {
        // log_printf("create map:v-0x%x,p-0x%x,perm:0x%x", vaddr, paddr, perm);
        pte_t *pte = find_pte(page_dir, vaddr, 1); // 从页目录表中找到对应的页表项
        if (pte == (pte_t *)0)
        {
            // 未找到返回 -1
            return -1;
        }
        // 建立映射关系
        ASSERT(pte->present == 0);
        pte->v = paddr | perm | PTE_P;

        // 下一页的映射关系
        vaddr += MEM_PAGE_SIZE;
        paddr += MEM_PAGE_SIZE;
    }
    return 0;
}
```

以一个已知的虚拟地址为例，详见下图

![3403B1B423D78AA497D841E53C690BB8](E:\QQ\QQfile/3403B1B423D78AA497D841E53C690BB8.png)

```c
/**
 * @brief        : 将页目录表的首地址写入cr3寄存器
 * @param         {uint32_t} paddr:页目录表地址
 * @return        {*}
 **/
static inline void mmu_set_page_dir(uint32_t paddr)
{
    write_cr3(paddr);
}
/**
 * @brief        : 取出页目录项在页目录表中的索引
 * @param         {uint32_t} vaddr: 对应的虚拟地址
 * @return        {uint_32} : 返回页目录项在页目录中的索引
 **/
static inline uint32_t pde_index(uint32_t vaddr)
{
    int index = (vaddr >> 22);
    return index;
}
/**
 * @brief        : 取出物理页在页表中的索引
 * @param         {uint32_t} vaddr: 对应的虚拟地址
 * @return        {uint32_t} : 返回物理页在页表中的索引
 **/
static inline uint32_t pte_index(uint32_t vaddr)
{
    return (vaddr >> 12) & 0x3FF; // 取中间10位
}
/**
 * @brief        : 取出页目录表项对应的页表物理地址,pde->phy_pt_addr为后20位
 * @param         {pde_t} *pde: 页目录表项
 * @return        {uint32_t} : 页表的物理地址
 **/
static inline uint32_t pde_paddr(pde_t *pde)
{
    return pde->phy_pt_addr << 12;
}
/**
 * @brief        : 取出页表项对应的页的物理地址,pte->phy_page_addr为后20为
 * @param         {pte_t} *pte: 页表的物理地址
 * @return        {uint32_t} : 页的物理地址
 **/
static inline uint32_t pte_paddr(pte_t *pte)
{
    return pte->phy_page_addr << 12;
}
```

对页表的查找过程实现如下：

```c
/**
 * @brief        : 寻找对应的页表
 * @param         {pde_t} *page_dir: 页目录表地址
 * @param         {uint32_t} vaddr: 虚拟地址
 * @param         {int} alloc: 如果未找到是否分配一个表项,1 是,0 否
 * @return        {pte_t *}: 页表的地址
 **/
pte_t *find_pte(pde_t *page_dir, uint32_t vaddr, int alloc)
{
    pte_t *page_table;
    pde_t *pde = page_dir + pde_index(vaddr); // 页目录表中页目录项
    if (pde->present)                         // 判断是否存在
    {
        page_table = (pte_t *)pde_paddr(pde); // 对应的页表的物理地址
    }
    else
    {
        if (alloc == 0) // 不存在,不分配
        {
            return (pte_t *)0;
        }
        // 不存在,分配
        uint32_t pg_addr = addr_alloc_page(&paddr_alloc, 1); // 分配一个页表
        if (pg_addr == 0) // 分配失败
        {
            return (pte_t *)0;
        }
        // 分配成功,对齐进行初始化
        pde->v = pg_addr | PDE_P | PDE_W | PDE_U;
        page_table = (pte_t *)pg_addr;
        kernel_memset((void *)page_table, 0, MEM_PAGE_SIZE);
    }
    return page_table + pte_index(vaddr);
}
```

### 5.4.4 添加权限处理 设置权限

​	相关权限位的设置，注意我们使用的二级页表机制，PTE中的表项相应的权限位针对物理页的权限进行设置，PDE中的表项针对页表进行权限进行设置 。相关权限主要为读/写权限。我们针对设置PDE权限较为宽泛，所有物理页均可读/写，然后通过设置PTE对页表权限进行更为精细的设置。

```c
#define PDE_CNT (1024) // 页目录表项数量
#define PTE_P (1 << 0) // 页表表项存在
#define PDE_P (1 << 0) // 页目录表项存在
#define PDE_W (1 << 1) // 页目录表项可写
#define PTE_W (1 << 1) // 页表表项可写
#define PDE_U (1 << 2) // 页目录表项用户态访问

static memory_map_t kernel_map[] = {
        // 线性起始地址,    线性结束地址,   物理地址, 权限标识符
        {kernel_base, s_text, 0, PTE_W},                       // 内核 ,只读
        {s_text, e_text, s_text, 0},                           // 内核代码区,只读,程序和只读数据
        {s_data, (void *)(MEM_EBDA_START - 1), s_data, PTE_W}, // 内核数据区,可读写数据空间
        // 扩展存储空间一一映射,方便直接操作
        {(void *)MEM_EXT_START, (void *)MEM_EXT_END, (void *)MEM_EXT_START, PTE_W},
    };
```


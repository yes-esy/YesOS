# 1.描述一个文件系统

​	从`newlib`的`printf`和gets`函数`的实现可以看出，其最终是以文件的方式通过`tty`设备驱动程序读取和写入数据。

![image-20250709145731689](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250709145731689.png)

​	除可设备外，计算机系统中还存在着磁盘，磁盘上有不同的分区，用于存储文件数据，也需要通过文件接口进行访问。

![image-20250709145815114](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250709145815114.png)

​	目前的文件系统接口实现，无法管理统一管理这些设备。因为不同设备的特性不同，操作方法也不同。

![image-20250709145857771](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250709145857771.png)

​	借鉴设备管理层的方法是针对类型的设备，添加相应的文件系统层接口实现。

![image-20250709145949002](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250709145949002.png)

![image-20250709150010151](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250709150010151.png)

相关结构的定义：

```c
struct _fs_t; // 文件系统前置声明
/**
 * 回调函数表
 */
typedef struct _fs_op_t
{
    /**
     * @brief        : 挂载操作,进行某些初始化
     * @param         {_fs_t} *fs: 指定的文件系统的指针
     * @param         {int} major: 主设备号
     * @param         {int} minor: 次设备号
     * @return        {int} : 成功返回0,失败返回-1
     **/
    int (*mount)(struct _fs_t *fs, int major, int minor);
    /**
     * @brief        : 取消挂载
     * @param         {_fs_t} *fs: 指定的文件系统的指针
     * @return        {void}
     **/
    void (*unmont)(struct _fs_t *fs);
    /**
     * @brief        : 打开某文件系统下的指定路径的文件
     * @param         {_fs_t} *fs: 指定文件系统的指针
     * @param         {char *} path: 文件的路径
     * @param         {file_t *} file: 需要打开的文件
     * @return        {int} : 成功返回0,失败返回-1
     **/
    int (*open)(struct _fs_t *fs, const char *path, file_t *file);
    /**
     * @brief        : 读取某文件
     * @param         {char} *buf: 读入的缓冲区
     * @param         {int} size: 读取的数据量
     * @param         {file_t} *file: 读取的文件
     * @return        {int} : 实际读取的数据量
     **/
    int (*read)(char *buf, int size, file_t *file);
    /**
     * @brief        : 写文件
     * @param         {char} *buf: 写入的数据的指针
     * @param         {int} size: 写入的数据量
     * @param         {file_t *} file: 写入的文件
     * @return        {int} : 实际写入的数据量
     **/
    int (*write)(char *buf, int size, file_t *file);
    /**
     * @brief        : 关闭指定的文件
     * @param         {file_t *} file: 需要关闭的文件
     * @return        {void}
     **/
    void (*open)(file_t *file);
    /**
     * @brief        : 跳转到文件指定位置操作
     * @param         {file_t *} file: 需要操作的文件
     * @param         {uint32_t} offset: 偏移量
     * @param         {int} dir:  操作的起始位置
     * @return        {int} : 指定位置的指针
     **/
    int (*seek)(file_t *file, uint32_t offset, int dir);
    /**
     * @brief        : 获取文件状态信息
     * @param         {file_t} *file: 需要获取状态信息的文件对象
     * @param         {stat *} st: 用于存储文件状态信息的结构体指针
     * @return        {int} : 成功返回0，失败返回负数错误码
     **/
    int (*stat)(file_t *file, struct stat *st);
} fs_op_t;
/**
 * 文件系统描述符
 * 如:设备文件系统、磁盘文件系统
 */
typedef struct _fs_t
{
    fs_op_t *op; // 指明该文件系统可执行的操作
} fs_t;
```

# 2.挂载设备文件系统

​	如何通过路径识别读写的是哪种类型的文件。

![image-20250709152548431](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250709152548431.png)

![image-20250709152611583](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250709152611583.png)

​	在文件系统中，通常将文件和目录按树形的方式组织起来。可以组织成在一颗树下，也可以按`C：D：`等磁盘分区进行组织。

![image-20250709152642926](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250709152642926.png)

​	对于不同类型的文件系统，使用统一的接进行挂载和管理。

![image-20250709152723349](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250709152723349.png)

```c
/**
 * @FilePath     : /code/source/kernel/fs/devfs/devfs.c
 * @Description  :  设备文件系统.c头文件
 * @Author       : ys 2900226123@qq.com
 * @Version      : 0.0.1
 * @LastEditors  : ys 2900226123@qq.com
 * @LastEditTime : 2025-07-09 15:58:53
 * @Copyright    : G AUTOMOBILE RESEARCH INSTITUTE CO.,LTD Copyright (c) 2025.
 **/
#include "fs/devfs/devfs.h"
#include "fs/fs.h"
#include "dev/dev.h"
/**
 * @brief        : 挂载操作,进行某些初始化
 * @param         {_fs_t} *fs: 指定的文件系统的指针
 * @param         {int} major: 主设备号
 * @param         {int} minor: 次设备号
 * @return        {int} : 成功返回0,失败返回-1
 **/
int devfs_mount(struct _fs_t *fs, int major, int minor)
{
    fs->type = FS_DEVFS;
}
/**
 * @brief        : 取消挂载
 * @param         {_fs_t} *fs: 指定的文件系统的指针
 * @return        {void}
 **/
void devfs_unmont(struct _fs_t *fs)
{
    return;
}
/**
 * @brief        : 打开某文件系统下的指定路径的文件
 * @param         {_fs_t} *fs: 指定文件系统的指针
 * @param         {char *} path: 文件的路径
 * @param         {file_t *} file: 需要打开的文件
 * @return        {int} : 成功返回0,失败返回-1
 **/
int devfs_open(struct _fs_t *fs, const char *path, file_t *file)
{
    return 1;
}
/**
 * @brief        : 读取某文件
 * @param         {char} *buf: 读入的缓冲区
 * @param         {int} size: 读取的数据量
 * @param         {file_t} *file: 读取的文件
 * @return        {int} : 实际读取的数据量
 **/
int devfs_read(char *buf, int size, file_t *file)
{
    return dev_read(file->dev_id, file->pos, buf, size);
}
/**
 * @brief        : 写文件
 * @param         {char} *buf: 写入的数据的指针
 * @param         {int} size: 写入的数据量
 * @param         {file_t *} file: 写入的文件
 * @return        {int} : 实际写入的数据量
 **/
int devfs_write(char *buf, int size, file_t *file)
{
    return dev_write(file->dev_id, file->pos, buf, size);
}
/**
 * @brief        : 关闭指定的文件
 * @param         {file_t *} file: 需要关闭的文件
 * @return        {void}
 **/
void devfs_close(file_t *file)
{
    return;
}
/**
 * @brief        : 跳转到文件指定位置操作
 * @param         {file_t *} file: 需要操作的文件
 * @param         {uint32_t} offset: 偏移量
 * @param         {int} dir:  操作的起始位置
 * @return        {int} : 指定位置的指针
 **/
int devfs_seek(file_t *file, uint32_t offset, int dir)
{
    return 0;
}
/**
 * @brief        : 获取文件状态信息
 * @param         {file_t} *file: 需要获取状态信息的文件对象
 * @param         {stat *} st: 用于存储文件状态信息的结构体指针
 * @return        {int} : 成功返回0，失败返回负数错误码
 **/
int devfs_stat(file_t *file, struct stat *st)
{
    return 0;
}

fs_op_t devfs_op = {
    .mount = devfs_mount,
    .unmount = devfs_unmont,
    .open = devfs_open,
    .read = devfs_read,
    .write = devfs_write,
    .close = devfs_close,
    .seek = devfs_seek,
    .stat = devfs_stat,
};

```

挂载文件系统的实现

```c
/**
 * @brief        : 根据文件系统类型获取回调函数表
 * @param         {fs_type_t} type: 文件系统类型
 * @param         {int} major: 文件系统设备号
 * @return        {fs_op_t *}: 回调函数表
 **/
static fs_op_t *get_fs_op(fs_type_t type, int major)
{
    switch (type)
    {
    case FS_DEVFS:
        return &(devfs_op);
        break;
    default:
        return (fs_op_t *)0;
        break;
    }
    return (fs_op_t *)0;
}
/**
 * @brief        : 挂载文件系统
 * @param         {fs_type_t} type: 文件系统的类型
 * @param         {char *} mount_point: 挂载点
 * @param         {int} dev_major: 主设备号
 * @param         {int} dev_minor: 次设备号
 * @return        {fs_t *} : 挂载成功的文件系统的指针
 **/
static fs_t *mount(fs_type_t type, char *mount_point, int dev_major, int dev_minor)
{
    fs_t *fs = (fs_t *)0; // 记录挂载的文件指针
    log_printf("mounting %s file system, dev:%x\n", mount_point, dev_major);
    list_node_t *curr = list_first(&mounted_list);
    while (curr) // 检查是否已挂载
    {
        fs_t *fs = list_node_parent(curr, fs_t, node);

        if (kernel_strncmp(fs->mount_point, mount_point, FS_MOUNT_POINT_SIZE) == 0) // 重复挂载,挂载失败
        {
            log_printf("%s already mounted\n");
            goto mount_failed;
        }
        curr = list_node_next(curr);
    }
    list_node_t *free_node = list_remove_first(&free_list); // 取出一个空闲结点
    if (!free_node)
    {
        log_printf("no free fs , mount failed\n");
        goto mount_failed;
    }
    fs = list_node_parent(free_node, fs_t, node); // 取出该空闲结点的指针

    fs_op_t *op = get_fs_op(type, dev_major); // 获取函数回调表指针
    if (op == (fs_op_t *)0)
    {
        log_printf("unsupported file system type , type is %s\n", type);
        goto mount_failed;
    }
    kernel_memset(fs, 0, sizeof(fs_t));                                               // 先清空
    kernel_memcpy((void *)fs->mount_point, (void *)mount_point, FS_MOUNT_POINT_SIZE); // 设置挂载点名称
    fs->op = op;                                                                      // 设备函数回调表
    if (op->mount(fs, dev_major, dev_minor) < 0)                         // 调用挂载函数挂载该文件系统
    {
        // 挂载失败
        log_printf("mount file system failed, mount point is %s\n", mount_point);
        goto mount_failed;
    }
    list_insert_last(&mounted_list, &fs->node); // 插入挂载队列
    return fs;
mount_failed:
    if (fs)
    {
        list_insert_last(&free_list, &fs->node); // 插回原空闲链表
    }
    return (fs_t *)0;
}
/**
 * @brief        : 初始化空闲文件系统链表
 * @return        {*}
 **/
static void mount_list_init(void)
{
    list_init(&free_list);                  // 初始化空闲链表
    for (int i = 0; i < FS_TABLE_SIZE; i++) // 将文件系统表插入空闲链表
    {
        list_insert_first(&free_list, &fs_table[i].node);
    }
    list_init(&mounted_list); // 初始化挂载链表
}
/**
 * @brief        : 文件系统初始化
 * @return        {void}
 **/
void fs_init(void)
{
    mount_list_init();
    file_table_init();                        // 文件表初始化
    fs_t *fs = mount(FS_DEVFS, "/dev", 0, 0); // 挂载设备文件系统
    ASSERT(fs != (fs_t *)0);
}

```

​	设备文件系统并不对应于某个实际的硬件设备，而是抽像出来的用于管理所有硬件设备的一种文件系统。

![image-20250709164645079](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250709164645079.png)

# 3.打开/dev/tty0文件

## 3.1只打开devfs中的文件

定义设备文件系统的类型描述符以及全局设备类型表

```c
/**
 * 设备文件系统类型,tty设备,磁盘磁盘设备
 */
typedef struct _devfs_type_t
{
    const char *name;
    int dev_type;
    int file_type;
} devfs_type_t;
/**
 * 支持的文件系统的类型
 */
static devfs_type_t devfs_type_list[] = {
    {
        .name = "tty",
        .dev_type = DEV_TTY,
        .file_type = FILE_TTY,
    }, // tty设备
};
```

​	完善`devfs_open`

```c
/**
 * @brief        : 打开某文件系统下的指定路径的文件
 * @param         {_fs_t} *fs: 指定文件系统的指针
 * @param         {char *} path: 文件的路径
 * @param         {file_t *} file: 需要打开的文件
 * @return        {int} : 成功返回0,失败返回-1
 **/
int devfs_open(struct _fs_t *fs, const char *path, file_t *file)
{
    // 遍历设备类型表找到相关类型
    for (int i = 0; i < sizeof(devfs_type_list) / sizeof(devfs_type_list[0]); i++)
    {
        devfs_type_t *dev_type = devfs_type_list + i;      // 遍历到的设备
        int type_name_len = kernel_strlen(dev_type->name); // 类型名称长度

        if (kernel_strncmp(path, dev_type->name, type_name_len) == 0) // 找到了某一特定类型的设备
        {
            int minor = 0;                                                                            // 记录次设备号
            if ((kernel_strlen(path) > type_name_len) && (path_to_num(path + type_name_len, &minor))) // 获取次设备号
            {
                log_printf("get device num failed , %s \n", path); // 打开失败
                break;
            }
            int dev_id = dev_open(dev_type->dev_type, minor, (void *)0); // 打开该设备
            if (dev_id < 0) // 打开失败
            {
                log_printf("open device failed.\n");
                break;
            }
            // 初始化操作
            file->dev_id = dev_id;
            file->fs = fs;
            file->pos = 0;
            file->size = 0;
            file->type = dev_type->file_type;
            return 0;
        }
    }
    return -1;
}
```

`sys_open()`系统调用

```c
/**
 * @brief        : 打开文件
 * @param         {char} *path: 文件路径
 * @param         {int} flags: 标志
 * @return        {int} : 若成功返回文件描述符,失败返回-1
 **/
int sys_open(const char *path, int flags, ...)
{
    if (kernel_strncmp(path, "/dev", 4) == 0) // 是否为tty设备
    {
        if (!is_path_valid(path))
        {
            log_printf("path is not valid.\n");
            return -1;
        }
        int fd = -1;                 // 记录文件描述符在进程文件表中对应的索引
        file_t *file = file_alloc(); // 分配一个文件描述符
        if (file != (file_t *)0)     // 成功分配
        {
            fd = task_alloc_fd(file); // 添加该文件到进程文件表中
            if (fd < 0)               // 添加失败
            {
                goto sys_open_failed; // 错误处理
            }
        }
        else
        {
            goto sys_open_failed;
        }
        const char *name = path_next_child(path); // 下一个路径

        // 相关字段初始化
        file->dev_id = -1;                                                    // 记录设备id
        file->mode = 0;                                                       // 打开模式
        file->pos = 0;                                                        // 文件读写位置
        file->ref = 1;                                                        // 打开次数
        file->type = FILE_TTY;                                                // 文件类型
        kernel_memcpy((void *)file->file_name, (void *)path, FILE_NAME_SIZE); // 设置文件名

        int err = devfs_op.open((fs_t *)0, name, file);
        return fd; // 返回文件描述符在进程文件表中对应的索引
    sys_open_failed:
        if (file) // 文件已经打开
        {
            file_free(file); // 释放文件
        }
        if (fd >= 0)
        {
            task_remove_fd(fd); // 从进程文件表释放该文件
        }
        return -1;
    }
    else
    {
        if (path[0] == '/')
        {
            // log_printf("Opening file: %s\n", path);
            // 暂时直接从扇区5000上读取, 读取大概40KB，足够了
            read_disk(5000, 80, (uint8_t *)TEMP_ADDR);
            temp_pos = (uint8_t *)TEMP_ADDR;
            return TEMP_FILE_ID;
        }
    }
    return -1;
}
```

```c
/**
 * @brief        : 获取下一个字路径
 * @param         {char *} path: 传入的路径
 * @return        {const char *} : 下一个路径开始的指针
 **/
const char *path_next_child(const char *path)
{
    const char *c = path;
    while ((*c) && (*c++ == '/')) // 跳过'/'
        ;
    while ((*c) && (*c++ != '/')) // 跳到 '/'后面一个字符
        ;
    return *c ? c : (const char *)0;
}
```

## 3.2更通用的打开方式

​	调整`sys_open`系统调用，不在直接调用`dev_open`来打开相关文件，而是通过文件中的`fs_t`结构调用回调函数表中的打开接口，并调整对原有`elf`文件的处理

```c
int sys_open(const char *path, int flags, ...)
{
    // 判断是否为shell.elf
    if (kernel_strncmp(path, "/shell.elf", 4) == 0)
    {
        // log_printf("Opening file: %s\n", path);
        // 暂时直接从扇区5000上读取, 读取大概40KB，足够了
        read_disk(5000, 80, (uint8_t *)TEMP_ADDR);
        temp_pos = (uint8_t *)TEMP_ADDR;
        return TEMP_FILE_ID;
    }
    if (!is_path_valid(path)) // 路径是否有效
    {
        log_printf("path(%s) is not valid.\n", path);
        return -1;
    }
    int fd = -1;                 // 记录文件描述符在进程文件表中对应的索引
    file_t *file = file_alloc(); // 分配一个文件描述符
    if (file == (file_t *)0)     // 分配失败
    {
        return -1;
    }
    fd = task_alloc_fd(file); // 添加该文件到进程文件表中
    if (fd < 0)               // 添加失败
    {
        goto sys_open_failed; // 错误处理
    }
    fs_t *fs = (fs_t *)0;                          // 记录对应的文件系统的指针
    list_node_t *node = list_first(&mounted_list); // 取出挂载的第一个文件系统的结点
    while (node)
    {
        fs_t *curr = list_node_parent(node, fs_t, node);
        if (path_begin_with(path, curr->mount_point)) // 找到了对应的文件系统
        {
            fs = curr; // 记录
            break;
        }
        node = list_node_next(node); // 下一个结点
    }
    const char *name = (const char *)0;
    if (fs) // 找到了
    {
        name = path_next_child(path); // 下一个路径
    }
    else // 没有找到
    {
    }
    // 相关字段初始化
    file->mode = flags;                                                   // 打开模式
    file->fs = fs;                                                        // 记录文件系统
    kernel_memcpy((void *)file->file_name, (void *)name, FILE_NAME_SIZE); // 设置文件名
    fs_protect(fs);                                                       // 进入保护
    int err = fs->op->open(fs, name, file);                               // 通过文件系统打开该文件
    if (err < 0)                                                          // 打开失败
    {
        fs_unprotect(fs); // 退出保护
        log_printf("open %s file system failed.\n", name);
        goto sys_open_failed;
    }
    fs_unprotect(fs); // 退出保护
    return fd;        // 返回文件描述符在进程文件表中对应的索引
sys_open_failed:
    file_free(file); // 释放文件
    if (fd >= 0)
    {
        task_remove_fd(fd); // 从进程文件表释放该文件
    }
    return -1;
}
```

​	对于`sys_close`需要特殊处理，需判断其是否只打开了一次，若只打开了一次，需要释放相关的资源，若非一个，直接在进程的文件表中释放即可

```c
/**
 * @brief        : 关闭某个打开的文件
 * @param         {int} file: 操作的文件
 * @return        {int} : 成功关闭返回0,失败返回-1
 **/
int sys_close(int file)
{
    if (file == TEMP_FILE_ID)
    {
        return 0;
    }
    if (is_fd_bad(file)) // 参数不合法
    {
        log_printf("close param valid\n");
        return -1;
    }
    file_t *curr_file = task_file(file); // 获取当前文件
    if (curr_file == (file_t *)0)
    {
        log_printf("get file error.\n");
        return -1;
    }
    ASSERT(curr_file->ref > 0); // 文件一定是被打开过的
    if (curr_file->ref == 1)    // 只打开了一次,才需要关闭文件,否则增加引用次数即可
    {
        fs_t *fs = curr_file->fs; // 获取文件系统描述符指针
        fs_protect(fs);           // 进入保护
        fs->op->close(curr_file); // 调用文件系统关闭操作
        fs_unprotect(fs);         // 退出保护
        file_free(curr_file);     // 释放当前文件结构描述符
    }
    task_remove_fd(file); // 在进程的文件表中释放该文件
    return 0;             // 成功关闭
}
```

# 4.往`/dev/tty0`中写数据

​	`sys_read`、`sys_write`、`sys_lseek`、`sys_isatty`、`sys_fstat`的处理类似。不直接调用`dev_read`，而是通过文件系统结构指针回调函数调用实现更为通用的读写等，以下为`sys_read`的实现

```c
/**
 * @brief        : 读取文件
 * @param         {int} file: 哪一个文件
 * @param         {char} *ptr: 读取到文件的目的地址
 * @param         {int} len: 读取长度
 * @return        {int} 读取成功返回读取长度,失败返回-1
 **/
int sys_read(int file, char *ptr, int len)
{
    if (file == TEMP_FILE_ID) // 读取shell.elf
    {
        kernel_memcpy(ptr, temp_pos, len);
        temp_pos += len;
        return len;
    }
    if (is_fd_bad(file) || !ptr || !len) // 参数不合法
    {
        log_printf("read param valid.\n");
        return 0;
    }

    file_t *cur_file = task_file(file); // 获取当前文件在进程中的文件描述符
    if (cur_file == (file_t *)0)        // 获取为空
    {
        log_printf("file not opened , file is %d\n", file);
        return -1;
    }
    if (cur_file->mode == O_WRONLY) // 只写的方式
    {
        log_printf("file(%s) not allowed read\n", cur_file->file_name);
        return -1;
    }
    fs_t *fs = cur_file->fs;                         // 获取当前文件系统描述符
    fs_protect(fs);                                  // 进入保护
    int read_len = fs->op->read(ptr, len, cur_file); // 读取操作
    fs_unprotect(fs);                                // 退出保护
    return read_len;                                 // 返回读取长度
}
```


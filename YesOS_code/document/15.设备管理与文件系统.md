# 1.设备管理框架简介

​	在计算机系统中，往往有很多种不同类型的设备，`OS`需要堆这些设备统一进行管理。

![image-20250706173401694](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706173401694.png)

​	为每种类型都提供一套操作接口并不现实，且操作系统难以处理。

![image-20250706173446132](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706173446132.png)

​	为了操作方便，操作系统需要提供一套抽象机制，对所有设备进行抽象管理，以向上屏蔽复杂的硬件细节。![image-20250708100753744](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250708100753744.png)

![image-20250706175543758](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706175543758.png)

​	在`dev`文件夹下创建`dev.h`文件并添加定义设备描述符``dev.h`文件中：

```c
/**
 * 描述一种具体的设备
 */
typedef struct _device_t
{
    struct _dev_desc_t *desc; // 设备的相关描述
    int mode;                 // 模式
    int minor;                // 次设备号
    void *data;               // 存放的参数
    int open_count;           // 打开次数
} device_t;
/**
 * 设备类型
 */
enum
{
    DEV_UNKNOWN = 0,// 未知设备
    DEV_TTY,         // tty设备类型
};
/**
 * 描述某一种类型设备的结构
 */
typedef struct _dev_desc_t
{
    char name[DEV_NAME_SIZE]; // 设备名
    int major;                // 主设备号
    /**
     * @brief        : 打开某一设备的函数接口
     * @param         {device_t *} dev: 打开的设备
     * @return        {int} : 若成功打开返回0，否则返回-1
     **/
    int (*open)(device_t *dev); // 打开设备的接口
    /**
     * @brief        : 读取设备的数据
     * @param         {device_t} *dev: 具体的设备的指针
     * @param         {int} addr: 从设备的何处读取
     * @param         {char *} buf: 读取到哪里
     * @param         {int} size: 读取的数据量
     * @return        {int} : 返回0
     **/
    int (*read)(device_t *dev, int addr, char *buf, int size); 
    /**
     * @brief        : 往设备写入数据
     * @param         {device_t} *dev: 写入数据的设备
     * @param         {int} addr: 从设备的哪里开始写
     * @param         {char} *buf: 写入的数据的起始地址
     * @param         {int} size: 写入的数据量
     * @return        {int} : 返回0
     **/
    int (*write)(device_t *dev, int addr, char *buf, int size); 

    /**
     * @brief        : 控制设备
     * @param         {device_t *} dev: 具体的设备描述指针
     * @param         {int} cmd: 控制命令
     * @param         {int} arg0: 命令的参数1
     * @param         {int} arg1: 命令的参数2
     * @return        {int} : 返回0
     **/
    int (*control)(device_t *dev, int cmd, int arg0, int arg1);
    /**
     * @brief        : 关闭设备
     * @param         {device_t *} dev: 具体的设备描述的指针
     * @return        {void}
     **/
    void (*close)(device_t *dev);
} dev_desc_t;

```

# 2.添加tty设备

由于键盘和显示器密切相关，因此将二者抽象为一种硬件设备tty。

![image-20250706175723427](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706175723427.png)

![image-20250708102824520](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250708102824520.png)

定义`tty`设备，并在`tty.c`添加相关接口

```c
/**
 * @brief        : 打开tty设备,对设备进行初始化
 * @param         {device_t *} dev: 打开的tty设备
 * @return        {int} : 若成功打开返回0，否则返回-1
 **/
int tty_open(device_t *dev)
{
    return 0;
}
/**
 * @brief        : 往设备写入数据
 * @param         {device_t} *dev: 写入数据的设备
 * @param         {int} addr: 从设备的哪里开始写
 * @param         {char} *buf: 写入的数据的起始地址
 * @param         {int} size: 写入的数据量
 * @return        {int} : 成功则返回写入的数据量,否则返回-1
 *
 **/
int tty_write(device_t *dev, int addr, char *buf, int size)
{
    return size;
}
/**
 * @brief        : 读取设备的数据
 * @param         {device_t} *dev: 具体的设备的指针
 * @param         {int} addr: 从设备的何处读取
 * @param         {char *} buf: 读取到哪里
 * @param         {int} size: 读取的数据量
 * @return        {int} : 成功读取的数据量,失败返回-1
 **/
int tty_read(device_t *dev, int addr, char *buf, int size)
{
    return len;
}
/**
 * @brief        : 控制设备
 * @param         {device_t *} dev: 具体的设备描述指针
 * @param         {int} cmd: 控制命令
 * @param         {int} arg0: 命令的参数1
 * @param         {int} arg1: 命令的参数2
 * @return        {int} : 返回0
 **/
int tty_control(device_t *dev, int cmd, int arg0, int arg1)
{
    return 0;
}
/**
 * tty设备描述
 */
dev_desc_t dev_tty_desc = {
    .name = "tty_device",
    .major = DEV_TTY,
    .open = tty_open,
    .read = tty_read,
    .write = tty_write,
    .control = tty_control,
    .close = tty_close,
};
```

​	最后在定义设备操作接口(`dev_open`、`dev_read`、`dev_write`、`dev_control`、`dev_close`)

```c
/**
 * 静态设备类型表
 */
static dev_desc_t *dev_desc_table[] = {
    &dev_tty_desc,
};
/**
 * 设备实例表
 */
static device_t dev_table[DEV_TABLE_SIZE];
/**
 * @brief        : 设备的打开
 * @param         {int} major: 主设备号,标识设备类型
 * @param         {int} minor: 次设备号,用于标识同类型设备的不同实例
 * @param         {void *} data: 传递给设备的初始化数据
 * @return        {int} : 成功时返回设备在dev_table中的索引(>=0)，失败时返回-1
 **/
int dev_open(int major, int minor, void *data)
{
    return -1; 
}
/**
 * @brief        : 判断设备id是否合法
 * @param         {int} dev_id: 设备索引(id)
 * @return        {int} 若合法返回0,非法返回1
 **/
static int is_dev_id_bad(int dev_id)
{
    if ((dev_id < 0) || (dev_id >= DEV_TABLE_SIZE)) // 不合法
    {
        return 1;
    }
    if (dev_table[dev_id].desc == (dev_desc_t *)0) // 设备描述为空
    {
        return 1;
    }
    return 0; // 合法
}
/**
 * @brief        : 从设备读取数据
 * @param         {int} dev_id: 设备Id
 * @param         {int} addr: 从哪个地址开始读取
 * @param         {char} *buf: 数据存放位置
 * @param         {int} size: 读取数据量
 * @return        {int} : 若读取成功则返回读取的数据量,否则返回-1
 **/
int dev_read(int dev_id, int addr, char *buf, int size)
{
    return  size;
}
/**
 * @brief        : 往设备写入数据
 * @param         {int} dev_id: 设备Id
 * @param         {int} addr: 写入的地址
 * @param         {char} *buf: 从哪里取数据写
 * @param         {int} size: 写入的数据量
 * @return        {int} : 写入的数据量
 **/
int dev_write(int dev_id, int addr, char *buf, int size)
{
  
    return size;
}
/**
 * @brief        : 控制设备
 * @param         {int} dev_id: 设备Id
 * @param         {int} cmd: 控制命令
 * @param         {int} arg0: 控制参数1
 * @param         {int} arg1: 控制参数2
 * @return        {int} : 若成功返回0,失败返回-1
 **/
int dev_control(int dev_id, int cmd, int arg0, int arg1)
{
   
    return 0;
}
/**
 * @brief        : 关闭设备
 * @param         {int} dev_id: 设备Id
 * @return        {void}
 **/
void dev_close(int dev_id)
{
}
```

# 3.实现dev层的接口操作

​	首先是`dev_open`,第一次扫描：查找已存在的设备或空闲槽位；第二次扫描：查找设备类型描述符.

> 主设备号 → 设备类型描述符（驱动程序）
> 次设备号 → 具体设备实例

```c

/**
 * @brief        : 设备的打开
 * @param         {int} major: 主设备号,标识设备类型
 * @param         {int} minor: 次设备号,用于标识同类型设备的不同实例
 * @param         {void *} data: 传递给设备的初始化数据
 * @return        {int} : 成功时返回设备在dev_table中的索引(>=0)，失败时返回-1
 **/
int dev_open(int major, int minor, void *data)
{
    irq_state_t irq_state = irq_enter_protection(); // 进入临界区
    device_t *free_dev = (device_t *)0;             // 记录找到的空闲设备位置

    // 第一次扫描：在设备实例表中查找
    for (int i = 0; i < sizeof(dev_table) / sizeof(dev_table[0]); i++)
    {
        device_t *dev = dev_table + i;
        if (dev->open_count == 0) // 找到空闲设备槽位
        {
            free_dev = dev;
        }
        else if ((dev->desc->major == major) && (dev->minor == minor)) // 设备已存在且已打开
        {
            dev->open_count++;               // 增加打开次数
            irq_leave_protection(irq_state); // 离开临界区
            return i;                        // 返回设备索引
        }
    }
    // 没有找到空闲设备
    // 第二次扫描：在设备类型表中查找匹配的设备类型
    dev_desc_t *desc = (dev_desc_t *)0;
    for (int i = 0; i < sizeof(dev_desc_table) / sizeof(dev_desc_table[0]); i++)
    {
        dev_desc_t *dev = dev_desc_table[i];
        if (dev->major == major) // 找到匹配的设备类型
        {
            desc = dev;
            break;
        }
    }

    // 如果找到了设备类型且有空闲槽位，则初始化新设备
    if (desc && free_dev)
    {
        // 初始化设备实例
        free_dev->minor = minor;
        free_dev->data = data;
        free_dev->desc = desc;
        int err = desc->open(free_dev); // 调用设备特定的打开函数
        if (err == 0)                   // 设备打开成功
        {
            free_dev->open_count = 1;
            irq_leave_protection(irq_state); // 离开临界区
            return free_dev - dev_table;     // 返回设备在表中的索引
        }
    }
    irq_leave_protection(irq_state); // 退出临界区
    return -1;                       // 打开失败
}

```

​	然后是`dev_read`，读取前先进行判断。

```c
/**
 * @brief        : 判断设备id是否合法
 * @param         {int} dev_id: 设备索引(id)
 * @return        {int} 若合法返回0,非法返回1
 **/
static int is_dev_id_bad(int dev_id)
{
    if ((dev_id < 0) || (dev_id >= DEV_TABLE_SIZE)) // 不合法
    {
        return 1;
    }
    if (dev_table[dev_id].desc == (dev_desc_t *)0) // 设备描述为空
    {
        return 1;
    }
    return 0; // 合法
}
/**
 * @brief        : 从设备读取数据
 * @param         {int} dev_id: 设备Id
 * @param         {int} addr: 从哪个地址开始读取
 * @param         {char} *buf: 数据存放位置
 * @param         {int} size: 读取数据量
 * @return        {int} : 若读取成功则返回读取的数据量,否则返回-1
 **/
int dev_read(int dev_id, int addr, char *buf, int size)
{
    if (is_dev_id_bad(dev_id)) // 设备id是否合法
    {
        return -1;
    }
    device_t *dev = dev_table + dev_id;           // 具体的设备
    return dev->desc->read(dev, addr, buf, size); // 调用该设备的读取数据接口
}
```

​	然后是`dev_control`、`dev_close`、`dev_write`，直接调用对应的接口即可。

```c
/**
 * @brief        : 控制设备
 * @param         {int} dev_id: 设备Id
 * @param         {int} cmd: 控制命令
 * @param         {int} arg0: 控制参数1
 * @param         {int} arg1: 控制参数2
 * @return        {int} : 若成功返回0,失败返回-1
 **/
int dev_control(int dev_id, int cmd, int arg0, int arg1)
{
    if (is_dev_id_bad(dev_id)) // 设备id是否合法
    {
        return -1;
    }
    device_t *dev = dev_table + dev_id;              // 具体的设备
    return dev->desc->control(dev, cmd, arg0, arg1); // 调用该设备的控制接口
}
/**
 * @brief        : 往设备写入数据
 * @param         {int} dev_id: 设备Id
 * @param         {int} addr: 写入的地址
 * @param         {char} *buf: 从哪里取数据写
 * @param         {int} size: 写入的数据量
 * @return        {int} : 写入的数据量
 **/
int dev_write(int dev_id, int addr, char *buf, int size)
{
    if (is_dev_id_bad(dev_id)) // 设备id是否合法
    {
        return -1;
    }
    device_t *dev = dev_table + dev_id;            // 具体的设备
    return dev->desc->write(dev, addr, buf, size); // 调用该设备的写数据接口
}
/**
 * @brief        : 关闭设备
 * @param         {int} dev_id: 设备Id
 * @return        {void}
 **/
void dev_close(int dev_id)
{
    if (is_dev_id_bad(dev_id)) // 设备id是否合法
    {
        return ;
    }
    device_t *dev = dev_table + dev_id;         // 具体的设备
    irq_state_t state = irq_enter_protection(); // 进入临界区
    if (--dev->open_count == 0)
    {
        dev->desc->close(dev);                           // 调用该设备的关闭接口
        kernel_memset((void *)dev, 0, sizeof(device_t)); // 清空该设备
    }
    irq_leave_protection(state);
}
```

# 4.为TTY设备添加结构描述

​	可以将`32KB`显存分成8块，每块分别用于控制显示虚拟的控制台界面。

![image-20250706200621852](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706200621852.png)

​	`CPU`的运行速度很快，但设备的速度较快，所以一般要在设备驱动中配置缓存，用于解决这种速度不匹配的问题。

![image-20250706200957441](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706200957441.png)

​	修改`log.c`文件，将原有的调用控制台输出`console_write`改成设备输出`dev_wirte`

```c
    dev_write(log_dev_id, 0, str_buf, kernel_strlen(str_buf)); // 使用tty设备输出数据
```

​	添加`tty_t`的设备结构

```c
typedef struct _tty_t
{
    char o_buf[TTY_O_BUF_SIZE]; // 具体存放输出数据
    tty_fifo_t O_fifo;          // 输出缓存队列
    char i_buf[TTY_I_BUF_SIZE]; // 具体存放数入数据
    tty_fifo_t I_fifo;          // 输入缓存队列
    int console_index;          // 那一块显示区域
    sem_t o_sem;                // 输出信号量
    sem_t i_sem;                // 输入信号量
    int i_flags;                // 输入标志位
    int o_flags;                // 输出标志位
} tty_t;
```

​	缓存队列：

```c
/**
 * tty队列
 */
typedef struct _tty_fifo_t
{
    char *buf; // 指向输入或输出缓存数组
    int size;  // 大小
    int read;  // 读的位置
    int wirte; // 写的位置
    int count; // 有效数据量
} tty_fifo_t;
```



# 4.实现tty设备的打开

​	为方便期间，将tty的缓冲区设计为循环队列

![image-20250706202816010](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706202816010.png)

​	循环队列中，write指向下一待写入数据的位置，read指向下一数据读取的位置。

![image-20250706202909364](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706202909364.png)

​	tty设备的打开有`tty_open()`控制,具体实现如下：

```c
/**
 * @brief        : 打开tty设备,对设备进行初始化
 * @param         {device_t *} dev: 打开的tty设备
 * @return        {int} : 若成功打开返回0，否则返回-1
 **/
int tty_open(device_t *dev)
{
    int index = dev->minor;             // 取当前tty设备索引(ID号)
    if (index < 0 || (index >= TTY_NR)) // 索引(ID号)不合法
    {
        log_printf("open tty device failed. incorrect tty index = %d\n", index);
        return -1;
    }
    tty_t *tty = tty_device_table + index;                   // 取当前tty设备指针
    tty->o_flags = TTY_OCRLF;                                // 打开回车换行功能
    tty->i_flags = TTY_INCLR | TTY_IECHO;                    // 输入设置
    tty_fifo_init(&tty->O_fifo, tty->o_buf, TTY_O_BUF_SIZE); // 初始化输出缓冲区
    sem_init(&tty->o_sem, TTY_O_BUF_SIZE);                   // 初始化输出信号量
    sem_init(&tty->i_sem, 0);                                // 初始化输入信号量
    tty_fifo_init(&tty->I_fifo, tty->i_buf, TTY_I_BUF_SIZE); // 初始化输入缓冲区
    tty->console_index = index;                              // 指定显示器
    console_init(index);                                     // 初始化控制台
    kbd_init();                                              // 初始化键盘
    return 0;
}
```

​	对缓冲队列的初始化：

```c
/**
 * @brief        : 初始化输入输出缓冲队列
 * @param         {tty_fifo_t} *fifo: 输入输出队列结构指针
 * @param         {char} *buf: 管理的数据队列
 * @param         {int} size: 大小
 * @return        {void}
 **/
void tty_fifo_init(tty_fifo_t *fifo, char *buf, int size)
{
    fifo->buf = buf;
    fifo->count = 0;
    fifo->size = size;
    fifo->read = fifo->wirte = 0;
}
```

​	修改控制台初始化，通过tty设备的序号进行初始化：

```c
/**
 * @brief        : 初始化控制台
 * @param         {int} index : 初始化控制台的索引
 * @return        {int} :返回0
 **/
int console_init(int index)
{

    console_t *console = console_buff + index; // 第几个控制台
    console->display_cols = CONSOLE_COL_MAX;   // 行数
    console->display_rows = CONSOLE_ROW_MAX;   // 列数
    console->foreground = COLOR_White;
    console->background = COLOR_Black;
    console->disp_base = (disp_char_t *)CONSOLE_DISP_ADDR + index * (CONSOLE_COL_MAX * CONSOLE_ROW_MAX);
    if (index == 0) // 第0块屏幕
    {
        int cursor_pos = read_cursor_pos();                       // 读取光标位置
        console->cursor_row = cursor_pos / console->display_cols; // 当前关标行号
        console->cursor_col = cursor_pos % console->display_cols; // 当前光标列号
    }
    else
    {
        // 从头开始
        console->cursor_row = 0;
        console->cursor_col = 0;
        clear_display(console);     // 清空屏幕
        update_cursor_pos(console); // 更新光标位置
    }
    console->old_cursor_col = console->cursor_col;
    console->old_cursor_row = console->cursor_row; // 保存关标的位置
    console->write_state = CONSOLE_WRITE_NORMAL;   // 初始状态写普通字符
    // clear_display(console);
    return 0;
}
```

​	键盘作为tty设备的一种，但是我们全局只有一个键盘，只需要初始化依次即可。通过定义一个全局的静态变量进行判断，详见下述：

```c
/**
 * @brief        : 初始化
 * @return        {*}
 **/
void kbd_init(void)
{
    static int inited = 0; // 是否已经被初始化
    if (!inited)           // 已经初始化
    {
        kernel_memset((void *)&kbd_state, 0, sizeof(kbd_state_t));
        irq_install(IRQ1_KEYBOARD, (irq_handler_t)exception_handler_kbd); // 安装键盘处理程序
        irq_enable(IRQ1_KEYBOARD);                                        // 打开键盘中断
        inited = 1;                                                       // 初始化次数为1
    }
}
```



# 5.通过tty设备写显示数据

​	循环队列中，`write`指向下一待写入数据的位置，`read`指向下一数据读取的位置。

![image-20250706213819207](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706213819207.png)

​	最简单的方式，进程向硬件写入数据，然后等待硬件发送完成，再写入数据，如此反复，直到所有数据发送完毕。整个过程效率非常低。

![image-20250706214147075](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706214147075.png)

​	一般情况下，进程负责向缓存写入数据，然后启动硬件发送机制，之后由硬件自动完成所有数据的发送，从而完成高效率地数据 发送机制。相比查询来说，速度要更快，进程不必等待。

![image-20250706214414841](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706214414841.png)

实现`tty_write`函数

```c
/**
 * @brief        : 获取对应的tty设备
 * @param         {device_t *} dev: 某一种类型的设备号
 * @return        {tty_t *} : tty设备的指针
 **/
static tty_t *get_tty(device_t *dev)
{
    int tty_id = dev->minor;
    if ((tty_id < 0) || (tty_id >= TTY_NR) || (!dev->open_count))
    {
        log_printf("tty device open failed. tty id is %d\n", tty_id);
        return (tty_t *)0;
    }
    return tty_device_table + tty_id;
}
/**
 * @brief        : 往设备写入数据
 * @param         {device_t} *dev: 写入数据的设备
 * @param         {int} addr: 从设备的哪里开始写
 * @param         {char} *buf: 写入的数据的起始地址
 * @param         {int} size: 写入的数据量
 * @return        {int} : 成功则返回写入的数据量,否则返回-1
 *
 **/
int tty_write(device_t *dev, int addr, char *buf, int size)
{
    if (size < 0) // 写入大小不正确
    {
        return -1;
    }
    tty_t *tty = get_tty(dev); // 获取对应的tty设备
    if (tty == (tty_t *)0)     // 获取失败
    {
        return -1;
    }
    int len = 0; // 记录写入的数据量
    // 先将所有数据写入缓存中
    while (size) // 往tty设备写入数据
    {
        char c = *buf++; // 取出buf中的数据

        // 如果遇到\n，根据配置决定是否转换成\r\n
        if (c == '\n' && (tty->o_flags & TTY_OCRLF))
        {
            sem_wait(&tty->o_sem);
            int err = tty_fifo_put(&tty->O_fifo, '\r');
            if (err < 0)
            {
                break;
            }
        }

        sem_wait(&tty->o_sem);                   // 等信号量
        int err = tty_fifo_put(&tty->O_fifo, c); // 往输出缓冲队列写数据
        if (err < 0)                             // 写失败
        {
            break;
        }
        len++;
        size--;
        // if(显示器是不是忙)
        // {
        //     continue;
        // }
        // else
        // {
        //     启动硬件发送显示
        // }
        console_write(tty);
    }
    return size;
}
```

​	对缓存的操作：`tty_fifo_put`以及`tty_fifo_get`的实现：

```c
/**
 * @brief        : 将一字节数据输入到数据输出缓冲队列中
 * @param         {tty_fifo_t *} tty_fifo: 对应的输出缓冲队列
 * @param         {char} c : 输入到输出队列的数据
 * @return        {int}
 **/
int tty_fifo_put(tty_fifo_t *tty_fifo, char c)
{
    irq_state_t state = irq_enter_protection(); // 开中断保护
    if (tty_fifo->count >= tty_fifo->size)      // 输出队列已满
    {
        irq_leave_protection(state); // 关中断返回
        return -1;
    }
    tty_fifo->buf[tty_fifo->wirte++] = c;
    if (tty_fifo->wirte >= tty_fifo->size) // 写指针到队列尾部
    {
        tty_fifo->wirte = 0; // 回到起点
    }
    tty_fifo->count++;           // 数据量增加
    irq_leave_protection(state); // 关中断返回
    return 0;
}
/**
 * @brief        : 将数一字节据从输出缓冲队列中取出
 * @param         {tty_fifo_t *} tty_fifo: 对应的输出缓冲队列
 * @param         {char *} c : 取出的数据的指针
 * @return        {int}  若成功返回0,失败返回-1
 **/
int tty_fifo_get(tty_fifo_t *tty_fifo, char *c)
{
    irq_state_t state = irq_enter_protection(); // 开中断保护
    if (tty_fifo->count <= 0)                   // 输出队列为空
    {
        irq_leave_protection(state); // 关中断返回
        return -1;
    }
    *c = tty_fifo->buf[tty_fifo->read++];
    if (tty_fifo->read >= tty_fifo->size) // 读指针到队列尾部
    {
        tty_fifo->read = 0; // 回到起点
    }
    tty_fifo->count--;           // 数据减少
    irq_leave_protection(state); // 关中断返回
    return 0;
}
```

​	然后修改`console_write`函数

```c
/**
 * @brief        : 往控制台写数据
 * @param         {tty_t *} tty: tty设备的指针
 * @return        {int} 返回写入的长度
 **/
int console_write(tty_t *tty)
{
    console_t *console = console_buff + tty->console_index; // 获取当前控制台;

    int len = 0; // 记录写出数据的长度
    do
    {
        char ch;                                   // 记录读取数据
        int err = tty_fifo_get(&tty->O_fifo, &ch); // 从输出缓冲队列读取数据
        if (err < 0)                               // 读取失败
        {
            break;
        }
        sem_signal(&tty->o_sem); //  取完了,发信号量
        switch (console->write_state)
        {
        case CONSOLE_WRITE_NORMAL: // 写普通字符
            write_normal(console, ch);
            break;
        case CONSOLE_WRITE_ESC: // 写特殊字符
            write_esc(console, ch);
            break;
        case CONSOLE_WRITE_SQUARE: // 写esc参数列表
            write_esc_square(console, ch);
        default:
            break;
        }
        len++;
        // @todo
    } while (1);
    update_cursor_pos(console); // 更新光标位置
    return len;
}
```

# 6.文件系统简介及初始化

​	操作系统使用文件系统对磁盘上的存储进行管理，给应用程序提供以文件组织的视图。

![image-20250708143115058](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250708143115058.png)

​	在文件系统中，通常将文件和目录按树形的方式组织起可以组织成在一顆树下，也可以按C:D：等磁盘分区进行组织。

![image-20250708143157091](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250708143157091.png)

​	在Unix,无论是磁盘上的数据文件、目录、还是设备，均被视为文件，并提供一组文件相关的操作接口。

![image-20250708143235215](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250708143235215.png)

​	在`file.h`中添加相关文件结构以及函数接口：

```c
#define FILE_NAME_SIZE 64    // 文件大小
#define FILE_TABLE_SIZE 2048 // 文件表大小
/**
 * 文件类型
 */
typedef enum _file_type_t
{
    FILE_UNKNOWN = 0,
    FILE_TTY,
} file_type_t;
/**
 * 文件描述结构
 */
typedef struct _file_t
{
    char file_name[FILE_NAME_SIZE]; // 文件名
    file_type_t type;               // 文件类型
    uint32_t size;                  // 文件大小
    int ref;                        // 打开次数
    int dev_id;                     // 所属设备id
    int pos;                        // 读取到的位置
    int mode;                       // 读写模式
} file_t;

/**
 * @brief        : 对文件表初始化
 * @return        {void}
 **/
void file_table_init(void);
/**
 * @brief        : 从文件表中分配一个空闲表项
 * @return        {file_t*} : 分配的表项的指针
 **/
file_t *file_alloc(void);
/**
 * @brief        : 从文件表释放文件
 * @param         {file_t *} file: 要释放的文件
 * @return        {void}
 **/
void file_free(file_t *file);
```

​	定义全局的文件描述分配结构

```c
static file_t file_table[FILE_TABLE_SIZE];
static mutex_t file_alloc_mutex; //  文件分配互斥锁
/**
 * @brief        : 从文件表中分配一个空闲表项
 * @return        {file_t*} : 分配的表项的指针
 **/
file_t *file_alloc(void)
{
    file_t *file = (file_t *)0;    // 记录找到的空闲表项的指针
    mutex_lock(&file_alloc_mutex); // 上锁
    // 遍历表项
    for (int i = 0; i < FILE_TABLE_SIZE; i++)
    {
        file_t *cur_file = file_table + i; // 当前表项
        if (cur_file->ref == 0)            // 当前文件没有被打开过
        {
            kernel_memset((void *)cur_file, 0, sizeof(cur_file)); // 清空该表项;
            cur_file->ref = 1;
            file = cur_file;
            break;
        }
    }
    mutex_unlock(&file_alloc_mutex); // 解锁
    return file;
}
/**
 * @brief        : 从文件表释放文件
 * @param         {file_t *} file: 要释放的文件
 * @return        {void}
 **/
void file_free(file_t *file)
{
    mutex_lock(&file_alloc_mutex); // 上锁
    if (file->ref)                 // 文件打开次数减1
    {
        file->ref--;
    }
    mutex_unlock(&file_alloc_mutex); // 解锁
}
/**
 * @brief        : 对文件表初始化
 * @return        {void}
 **/
void file_table_init(void)
{
    mutex_init(&file_alloc_mutex);                            // 初始化互斥锁
    kernel_memset((void *)file_table, 0, sizeof(file_table)); // 清空文件表
}
```

# 7.为进程添加文件打开表

​	在实际应用场合中，往往同时运行着很多应用程序，每个应用程序都可能会进行文件的读写操作。

![image-20250708143739194](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250708143739194.png)

​	为了实现文件打开的共享，每个进程只保存一个指针表，其中每项指向自己所打开的文件描述符。

![image-20250708144024701](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250708144024701.png)

```c
typedef struct _task_t
{
    file_t *file_table[TASK_OPEN_FILE_NR]; // 当前进程打开的文件
} task_t;
```

​	在进程初始化直接清空即可。相关函数接口及实现

```c
/**
 * @brief        : 分配一个文件描述符
 * @param         {file_t} *file: 对应文件指针
 * @return        {int} : 成功则返回进程文件表分配给文件描述符的表项对应的索引,否则返回-1
 **/
int task_alloc_fd(file_t *file)
{
    task_t *task = task_current();              // 获取当前进程
    for (int i = 0; i < TASK_OPEN_FILE_NR; i++) // 扫描当前进程文件表
    {
        file_t *cur_file = task->file_table[i]; // 对应文件描述符
        if (cur_file == (file_t *)0)            // 空闲表项
        {
            task->file_table[i] = file; // 将该表项分配给该文件描述符
            return i;
        }
    }
    return -1; // 失败返回-1
}
/**
 * @brief        : 释放进程文件表中的文件
 * @param         {int} fd: 对应文件的索引
 * @return        {void}
 **/
void task_remove_fd(int fd)
{
    if ((fd >= 0) && (fd < TASK_OPEN_FILE_NR)) // 索引合法
    {
        task_current()->file_table[fd] = (file_t *)0; // 清空该表项
    }
}
/**
 * @brief        : 返回表项对应的指针
 * @param         {int} fd: 文件描述索引
 * @return        {file_t *} : 文件描述符指针(成功),失败返回0.
 **/
file_t *task_file(int fd)
{
    file_t *file = (file_t *)0;                // 记录当前
    if ((fd >= 0) && (fd < TASK_OPEN_FILE_NR)) // 索引合法
    {
        file = task_current()->file_table[fd]; // 取当前文件指针
    }
    return file;
}
```

# 8.打开`TTY`设备并向其写入数据

​	重写`sys_open`、`sys_write`、`sys_read`系统调用，

```c
/**
 * @brief        : 判断文件路径是否有效
 * @param         {char *} path: 文件路径指针
 * @return        {int} 若有效返回1,无效返回0
 **/
static int is_path_valid(const char *path)
{
    if ((path == (const char *)0) || (path[0] == '\0')) // 路径为空
    {
        return 0; // 无效
    }
    return 1; // 有效
}
/**
 * @brief        : 打开文件
 * @param         {char} *path: 文件路径
 * @param         {int} flags: 标志
 * @return        {int} : 若成功返回文件描述符,失败返回-1
 **/
int sys_open(const char *path, int flags, ...)
{
    if (kernel_strncmp(path, "tty", 3) == 0) // 是否为tty设备
    {
        if (!is_path_valid(path))
        {
            log_printf("path is not valid.\n");
            return -1;
        }
        int fd = -1;                 // 记录文件描述符在进程文件表中对应的索引
        file_t *file = file_alloc(); // 分配一个文件描述符
        if (file != (file_t *)0)     // 成功分配
        {
            fd = task_alloc_fd(file); // 添加该文件到进程文件表中
            if (fd < 0)               // 添加失败
            {
                goto sys_open_failed; // 错误处理
            }
        }
        else
        {
            goto sys_open_failed;
        }
        if (kernel_strlen(path) < 5) // 判断路径长度是否合法
        {
            goto sys_open_failed;
        }
        int num = path[4] - '0';                // 获取该tty设备的序号
        int dev_id = dev_open(DEV_TTY, num, 0); // 打开该设备
        if (dev_id < 0)                         // 大开失败
        {
            goto sys_open_failed;
        }
        file->dev_id = dev_id;                                                // 记录设备id
        file->mode = 0;                                                       // 打开模式
        file->pos = 0;                                                        // 文件读写位置
        file->ref = 1;                                                        // 打开次数
        file->type = FILE_TTY;                                                // 文件类型
        kernel_memcpy((void *)file->file_name, (void *)path, FILE_NAME_SIZE); // 设置文件名
        return fd;                                                            // 返回文件描述符在进程文件表中对应的索引
    sys_open_failed:
        if (file) // 文件已经打开
        {
            file_free(file); // 释放文件
        }
        if (fd >= 0)
        {
            task_remove_fd(fd); // 从进程文件表释放该文件
        }
        return -1;
    }
    else
    {
        if (path[0] == '/')
        {
            log_printf("Opening file: %s\n", path);
            // 暂时直接从扇区5000上读取, 读取大概40KB，足够了
            read_disk(5000, 80, (uint8_t *)TEMP_ADDR);
            temp_pos = (uint8_t *)TEMP_ADDR;
            return TEMP_FILE_ID;
        }
    }
    return -1;
}
/**
 * @brief        : 读取文件
 * @param         {int} file: 哪一个文件
 * @param         {char} *ptr: 读取到文件的目的地址
 * @param         {int} len: 读取长度
 * @return        {int} 读取成功返回读取长度,失败返回-1
 **/
int sys_read(int file, char *ptr, int len)
{
    if (file == TEMP_FILE_ID)
    {
        kernel_memcpy(ptr, temp_pos, len);
        temp_pos += len;
        return len;
    }
    else
    {
        file_t *cur_file = task_file(file); // 获取当前文件在进程中的文件描述符
        if (cur_file == (file_t *)0)        // 获取为空
        {
            log_printf("file not opened , file is %d\n", file);
            return -1;
        }
        return dev_read(cur_file->dev_id, 0, ptr, len); // 调用设备读取数据接口
    }
    return -1;
}
/**
 * @brief        : 写文件
 * @param         {int} file: 写入的文件
 * @param         {char} *ptr: 写入的内容的起始地址
 * @param         {int} len: 写入长度
 * @return        {int} : 若成功返回写入长度,失败返回-1
 **/
int sys_write(int file, char *ptr, int len)
{
    file_t *cur_file = task_file(file); // 获取当前文件在进程中的文件描述符
    if (cur_file == (file_t *)0)        // 获取为空
    {
        log_printf("file not opened , file is %d\n", file);
        return -1;
    }
    return dev_write(cur_file->dev_id, 0, ptr, len); // 调用设备写接口
}
```

> 问题`sys_write`传递的`file`的值为0而不是1

# 9.从`tty`读取键值字符串并显示

```c
/**
 * @brief        : tty设备读入数据
 * @param         {char} ch: 读入的数据
 * @return        {void}
 **/
void tty_in(char ch)
{
    tty_t *tty = tty_device_table + curr_tty_index; // 对应的tty设备
    if (sem_count(&tty->i_sem) >= TTY_I_BUF_SIZE)   // 缓冲区已满
    {
        return; // 直接返回
    }
    // 缓冲区未满
    tty_fifo_put(&tty->I_fifo, ch); // 将读入的数据添加到输入缓冲队列
    sem_signal(&tty->i_sem);        //  已经写入一个数据到缓冲区,发信号
}
```

# 10.打开标准输出及错误输出文件

​	在使用`C`标准库里，需要打开三个文件`stdin`（标准输入）、`stdout`（标准输出）、`stderr`（标准误输出）。并且其对应的文件 id分别为0、1、2。

​	更为简单的方法是，将`stdin/stdout/stderr`指向同一文件。

![image-20250708150010616](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250708150010616.png)

​	实现`dup`系统调用以达到下述效果：

```c
open("tty:0",0);// int fd = 0, stdin => tty0
dup(0) ;// int fd = 1 , stdout => tty0
dup(0) ;// int fd = 2 , stderr => tty0
```

```c
/**
 * @brief        : 复制文件描述符
 * @param         {int} file: 要复制的文件描述符索引
 * @return        {int} 新的文件描述符，失败返回-1
 **/
int sys_dup(int file)
{
    if ((file < 0) || (file >= TASK_OPEN_FILE_NR)) // 文件描述符是否合法
    {
        log_printf("file %d id not valid.\n" ,file);
        return -1;
    }
    file_t *cur_file = task_file(file); // 当前文件描述符
    if (cur_file == (file_t *)0)        // 获取失败
    {
        log_printf("file not opened.\n");
        return -1;
    }
    int fd = task_alloc_fd(cur_file); // 分配一个新表项
    if (fd < 0)                       // 分配失败
    {
        log_printf("no task file available.");
        return -1;
    }
    cur_file->ref++; // 增加打开次数
    return fd;
}
```

# 11.允许切换`tty`窗口

​	创建多个虚拟的`tty`

![image-20250708150847450](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250708150847450.png)

​	修改功能键，通过`ctrl+F1~F8`键切换，共八个窗口

```c
/**
 * @brief        : 处理ctrl+f功能键
 * @param         {int} key: f功能键键值f1-f8
 * @return        {void}
 **/
void do_fx_key(int key)
{
    int index = key - KEY_F1;                           // 转换成tty设备(屏幕)索引
    if (kbd_state.lctrl_press || kbd_state.rctrl_press) // ctrl键按下
    {
        tty_select(index);
    }
}
/**
 * @brief        : 处理单字符的标准键
 * @param         {uint8_t} raw_code: 键盘原始值
 * @return        {void}
 **/
static void
do_normal_key(uint8_t raw_code)
{
    char key = get_key(raw_code); // 去掉最高位
    int is_make = is_make_code(raw_code);
    switch (key)
    {
    case KEY_ALT:
        kbd_state.lalt_press = is_make;
        break;
    case KEY_CTRL:
        kbd_state.lctrl_press = is_make;
        break;
        //@todo 功能键：写入键盘缓冲区，后续完善
    case KEY_F1:
    case KEY_F2:
    case KEY_F3:
    case KEY_F4:
    case KEY_F5:
    case KEY_F6:
    case KEY_F7:
    case KEY_F8:
        do_fx_key(key); // 特殊功能键
        break;
            // .... 后续代码
    }
}

```

​	`tty`设备的切换

```c
/**
 * @brief        : 选择哪一个tty设备输出数据
 * @param         {int} tty: tty设备的序号
 * @return        {void}
 **/
void tty_select(int tty)
{
    if (tty != curr_tty_index)
    {
        console_select(tty);  // 切换显示数据
        curr_tty_index = tty; // 设置为新的tty设备
    }
}
```

​	控制台的切换

```c
/**
 * @brief        : 切换特定显示数据
 * @param         {int} tty_index: 指定tty设备索引
 * @return        {void}
 **/
void console_select(int tty_index)
{
    console_t *console = console_buff + tty_index; // 获取当前的tty显示设备
    if (console->disp_base == 0)                   // 当前设备还未打开
    {
        console_init(tty_index); // 打开并初始化当前tty设备
    }
    uint16_t pos = tty_index * console->display_rows * console->display_cols; // 当前控制台显示的地址
    outb(0x3D4, 0xC);                                                         // 往0x3D4写入数据
    outb(0x3D5, (uint8_t)((pos >> 8) & 0xFF));                                // 往0x3D5先写入高8位
    outb(0x3D4, 0xD);                                                         // 往0x3D4写入数据
    outb(0x3D5, (uint8_t)(pos & 0xFF));                                       // 往0x3D5写入低8位

    update_cursor_pos(console); // 更新光标到当前屏幕
    char num = tty_index + '0';
    show_char(console, num);
}
```

​	修改光标的显示

```c
/**
 * @brief        : 写入光标的位置
 * @return        {int} : 光标的索引
 **/
static int update_cursor_pos(console_t *console)
{
    uint16_t pos = (console - console_buff) * console->display_cols * console->display_rows; // 用于记录关标位置
    pos += console->cursor_row * console->display_cols + console->cursor_col;                // 获取光标位置
    irq_state_t state = irq_enter_protection();                                              // 开中断保护
    outb(0x3D4, 0xF);
    outb(0x3D5, (uint8_t)(pos & 0xFF));
    outb(0x3D4, 0xE);
    outb(0x3D5, (uint8_t)((pos >> 8) & 0xFF));
    irq_leave_protection(state); // 关中断返回
    return pos;
}
```

# 12 .为每个tty窗口创建进程并保护

​	修改`first_task.c`文件，添加创建多个tty窗口并执行的相关代码

```c
/**
 * @FilePath     : /code/source/kernel/init/first_task.c
 * @Description  : first_task进程代码
 * @Author       : ys 2900226123@qq.com
 * @Version      : 0.0.1
 * @LastEditors  : ys 2900226123@qq.com
 * @LastEditTime : 2025-07-08 09:48:32
 * @Copyright    : G AUTOMOBILE RESEARCH INSTITUTE CO.,LTD Copyright (c) 2025.
 **/
#include "applib/lib_syscall.h"
#include "dev/tty.h"
int first_task_main(void)
{
    for (int i = 0; i < TTY_NR; i++)
    {
        int pid = fork();
        if (pid < 0)
        {
            print_msg("create shell failed. pid is %d\n", pid);
            break;
        }
        else if (pid == 0) // 子进程
        {
            char tty_num[5] = "tty:?";
            tty_num[4] = i + '0';
            char *argv[] = {tty_num, (char *)0};
            execve("/shell.elf", argv, (char **)0);
            print_msg("create shell proc failed\n", 0);
        }
    }
    while (1)
    {
        // log_printf("first task is running . Now cnt is %d",cnt++);
        msleep(10000);
        // print_msg("cnt = %d\n", cnt++);
    }

    return 0;
}
```

`main.c`文件

```c
/**
 * @FilePath     : /code/source/shell/main.c
 * @Description  :  shell实现文件
 * @Author       : ys 2900226123@qq.com
 * @Version      : 0.0.1
 * @LastEditors  : ys 2900226123@qq.com
 * @LastEditTime : 2025-07-06 17:03:12
 * @Copyright    : G AUTOMOBILE RESEARCH INSTITUTE CO.,LTD Copyright (c) 2025.
 **/
#include "lib_syscall.h"
#include <stdio.h>
char cmd_buf[256]; // 输入缓冲区
int main(int argc, char **argv)
{
#if 0
    printf("\0337Hello,word!\0338123\n"); // ESC 7,8 输出123lo,word!
    printf("\033[31;42mHello,word!\033[39;49m123\n"); // ESC [pn m, Hello,world红色，>其余绿色
    printf("123\033[2DHello,word!\n");                // 光标左移2，1Hello,word!
    printf("123\033[2CHello,word!\n");                // 光标右移2，123 Hello,word!
    printf("\033[31m");                               // ESC [pn m, Hello,world红色，其余绿色
    printf("\033[10;10H test!\n");                    // 定位到10, 10，test!
    printf("\033[20;20H test!\n");                    // 定位到20, 20，test!
    printf("\033[32;25;39m123\n");                    // ESC [pn m, Hello,world红色，其余绿色
    for (int i = 0; i < argc; i++)
    {
        printf("arg %s\n", (int)argv[i]);
    }
    fork();
    yield();
    printf("abef\b\b\b\bcd\n");
    printf("abcd\x7F:fg\n");
    printf("this is a\n");
    printf("this is b\n");
#endif
    open(argv[0],0); // int fd = 0 , stdin
    dup(0);          // 标准输出
    dup(0);          // 标准错误输出
    printf("Hello from shell\n");
    while (1)
    {
        gets(cmd_buf);
        puts(cmd_buf);
        // printf("shell pid=%d\n", getpid());
        // msleep(10000);
    }
    return 0;
}

```

​	在相关临界区添加中断保护机制，确保正确访问，
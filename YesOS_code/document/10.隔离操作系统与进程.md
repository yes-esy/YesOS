# 1.代码分离

![image-20250628154803811](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250628154803811.png)

三个任务：

- 建立进程运行空间
- 代码拷贝至指定区域
- 从操作系统跳至进程运行

在`kernel/init`目录下新建`first_task.c`,`first_task.S`文件内容如下：

```c
/**
 * @FilePath     : /code/source/kernel/init/first_tack.c
 * @Description  : first_task进程代码
 * @Author       : ys 2900226123@qq.com
 * @Version      : 0.0.1
 * @LastEditors  : ys 2900226123@qq.com
 * @LastEditTime : 2025-06-27 17:08:48
 * @Copyright    : G AUTOMOBILE RESEARCH INSTITUTE CO.,LTD Copyright (c) 2025.
**/
#include "core/task.h"
#include "tools/log.h"
int first_task_main(void)
{
    int cnt = 0;
    while(1)
    {
        log_printf("first task is running . Now cnt is %d",cnt++);
        sys_sleep(10000);
    }
    return 0;
}
```

```assembly
/*
 * @FilePath     : /code/source/kernel/init/first_task.S
 * @Description  :  
 * @Author       : ys 2900226123@qq.com
 * @Version      : 0.0.1
 * @LastEditors  : ys 2900226123@qq.com
 * @LastEditTime : 2025-06-27 17:32:38
 * Copyright    : G AUTOMOBILE RESEARCH INSTITUTE CO.,LTD Copyright (c) 2025.
 */
	.text # 代码
	.global first_task_entry
	.extern first_task_main

first_task_entry:
	# 重新加载所有的数据段描述符
	mov %ss, %ax
	mov %ax, %ds
	mov %ax, %es
	mov %ax, %fs
	mov %ax, %gs

	# 长跳转进入first_task_main
	jmp first_task_main
```

同时修改`CMakeLists.txt`确保`.S`被编译。修改如下：

```cmake
# 注意保证start.asm在最前头，这样对应的程序会放在bin文件开头，从而在加载到0x7c00时能在开头处
file(GLOB_RECURSE C_LIST "*.c" "*.h" "*.S")
```

修改`task.c`中`task_first_init()`函数

```c
/**
 * @brief        : 初始化OS中的第一个任务
 * @return        {*}
 **/
void task_first_init(void)
{
    void first_task_entry(void);
    uint32_t first_start = (uint32_t)first_task_entry;
    task_init(&task_manager.first_task, "first task", first_start, 0); // 指定起始地址
    write_tr(task_manager.first_task.tss_sel);
    task_manager.curr_task = &task_manager.first_task;
    mmu_set_page_dir(task_manager.first_task.tss.cr3); // 切换页目录表
}

```

在`init.c`文件中实现跳转，`init_main()`中实现`move_to_first_task()`

```c
/**
 * @brief        : 跳转到第一个进程
 * @return        {*}
**/
void move_to_first_task(void)
{
    task_t *curr = task_current(); // 取当前进程
    ASSERT(curr != 0); // 不为空
    tss_t *tss = &(curr->tss);
    __asm__ __volatile__(
        "jmp *%[ip]"::[ip]"r"(tss->eip)
    );
}

```



# 2.地址分离

为`kernel`添加链接脚本文件`lds`

![image-20250628160619330](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250628160619330.png)

`ELF`解析过程

![image-20250628160820990](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250628160820990.png)

在ELF程序投中包含两种不同的地址：`p_vaddr和p_paddr`

![image-20250628160900408](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250628160900408.png)

> `vaddr`:虚拟地址，`paddr`:物理地址
>
> 现要求加载到物理内存的某个地址中，然后运行时应该加载到什么`vaddr`

![image-20250628162850097](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250628162850097.png)

​	使用链接脚本对地址进行设置规划

![image-20250628162934107](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250628162934107.png)

```cmake
SECTIONS {
    PROVIDE(kernel_base = .);
    . = 0x00010000;
    PROVIDE(s_text = .);
    .text : {
        *(EXCLUDE_FILE(*first_task*).text)
    }
    .rodata :{
        *(.rodata)
    }
    PROVIDE(e_text = .);
    . = ALIGN(4096);
    PROVIDE(s_data = .);
    .data :{
        *(.data)
    }

    .bss : {
        *(.bss)
    }
    e_data = .;

    . = 0x80000000;
    .first_task :AT(e_data) {
        *first_task_entry*(.text .rodata .bss .data)
        *first_task*(.text .rodata .bss .data)
    }
    e_first_task = LOADADDR(.first_task) + SIZEOF(.first_task);
    PROVIDE(mem_free_start = e_first_task );
}
```

> **内核区域 (0x00010000 开始)**
>
> **代码段 (.text)**
>
> ```linkerscript
> . = 0x00010000;
> PROVIDE(s_text = .);
> .text : {
>     *(EXCLUDE_FILE(*first_task*).text)
> }
> ```
>
> - 内核代码从物理地址 0x10000 开始
> - `EXCLUDE_FILE(*first_task*)` 排除了所有包含 "`first_task`" 的文件的代码段
> - `s_text` 标记代码段开始地址
>
> **只读数据段 (.rodata)**
>
> ```linkerscript
> .rodata :{
>     *(.rodata)
> }
> PROVIDE(e_text = .);
> ```
>
> - 存放常量数据
> - `e_text` 标记只读区域结束
>
> **数据段 (.data) 和 BSS 段 (.bss)**
>
> ```linkerscript
> . = ALIGN(4096);
> PROVIDE(s_data = .);
> .data :{
>     *(.data)
> }
> .bss : {
>     *(.bss)
> }
> e_data = .;
> ```
>
> - 按 4KB 对齐（页面边界）
> - `.data` 存放初始化的全局变量
> - `.bss` 存放未初始化的全局变量
> - `e_data` 标记数据区结束
>
> **第一个用户任务区域 (0x80000000)**
>
> ```linkerscript
> . = 0x80000000;
> .first_task :AT(e_data) {
>     *first_task_entry*(.text .rodata .bss .data)
>     *first_task*(.text .rodata .bss .data)
> }
> ```
>
> **关键特性：**
>
> 1. **虚拟地址**: 0x80000000 (用户空间起始地址)
> 2. **物理地址**: `AT(e_data)` 指定加载到内核数据段之后
> 3. **内容**: 包含所有 `first_task` 相关文件的所有段
>
> **内存管理符号**
>
> ```linkerscript
> e_first_task = LOADADDR(.first_task) + SIZEOF(.first_task);
> PROVIDE(mem_free_start = e_first_task);
> ```
>
> - `e_first_task` 计算第一个任务的物理结束地址
> - `mem_free_start` 提供给内核的空闲内存起始地址
>
> 这个布局实现了：
>
> 1. **内核与用户分离**: 内核在低地址，用户任务在高地址
> 2. **物理内存连续**: 所有代码和数据在物理内存中连续存放
> 3. **虚拟地址映射**: 第一个任务使用虚拟地址，便于后续的内存管理和进程切换

# 3.代码搬运

​	对于代码的搬运，我们的实现是通过分页机制将用户程序映射到`0x80000000`(线性地址)以上的区域。

![image-20250628174210297](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250628174210297.png)

- 起始结束区域
- 分配内存
- 代码搬运

实现：

```c
/**
 * @brief        : 为当前进程的虚拟地址区域分配页表内存空间
 * @param         {uint32_t} addr: 需要分配内存的虚拟起始地址
 * @param         {uint32_t} size: 需要分配的内存空间大小（字节）
 * @param         {int} perm: 页面权限标志（如可读、可写、用户态等）
 * @return        {int} : 成功返回0，失败返回错误码
 **/
int memory_alloc_page_for(uint32_t addr, uint32_t size, int perm)
{
    uint32_t page_dir = task_current()->tss.cr3;                  // 取当前页目录表地址
    return memory_alloc_page_for_dir(page_dir, addr, size, perm); // 为当前页目录表分配页表
}

/**
 * @brief        : 为指定页目录的虚拟地址区域分配页表内存空间
 * @param         {uint32_t} page_dir: 页目录表的物理地址
 * @param         {uint32_t} vaddr: 需要分配内存的虚拟起始地址
 * @param         {uint32_t} size: 需要分配的内存空间大小（字节）
 * @param         {int} perm: 页面权限标志（如可读、可写、用户态等）
 * @return        {int} : 成功返回0，失败返回错误码
 **/
int memory_alloc_page_for_dir(uint32_t page_dir, uint32_t vaddr, uint32_t size, int perm)
{
    uint32_t curr_vaddr = vaddr;                               // 线性地址
    int page_count = up2(size, MEM_PAGE_SIZE) / MEM_PAGE_SIZE; // 需要分配的物理页数量
    vaddr = down2(vaddr, MEM_PAGE_SIZE);                       // 向下对齐到整数倍
    for (int i = 0; i < page_count; i++)                       // 逐页分配内存,然后建立映射关系
    {
        uint32_t paddr = addr_alloc_page(&paddr_alloc, 1); // 分配一页物理内存
        if (paddr == 0)                                    // 分配失败
        {
            log_printf("mem alloc failed. non memory");
            return 0;
        }
        int err = memory_create_map((pde_t *)page_dir, curr_vaddr, paddr, 1, perm); // 建立映射关系
        if (err < 0)                                                                // 建立映射关系失败
        {
            log_printf("create memory failed. err=%d", err);
            // 释放全部已建立映射关系的页
            addr_free_page(&paddr_alloc, vaddr, i + 1);
            return -1;
        }
        curr_vaddr += MEM_PAGE_SIZE; // 处理下一页
    }
    return 0;
}

/**
 * @brief        : 初始化OS中的第一个任务
 * @return        {void}
 **/
void task_first_init(void)
{
    void first_task_entry(void);                                  // 第一个任务入口 线性地址
    extern uint8_t s_first_task[], e_first_task[];                // 物理起始地址与结束地址
    uint32_t copy_size = (uint32_t)(e_first_task - s_first_task); // 搬运大小
    uint32_t alloc_size = 10 * MEM_PAGE_SIZE;
    ASSERT(copy_size < alloc_size);
    uint32_t first_start = (uint32_t)first_task_entry;
    task_init(&task_manager.first_task, "first task", first_start, 0); // 指定起始地址
    write_tr(task_manager.first_task.tss_sel);
    task_manager.curr_task = &task_manager.first_task;
    mmu_set_page_dir(task_manager.first_task.tss.cr3); // 切换页目录表

    // 切换页目录表后,分配页表空间
    memory_alloc_page_for(first_start, alloc_size, PTE_P | PTE_W);
    // 分配完后拷贝
    kernel_memcpy((void *)first_start, s_first_task, copy_size);
}
```

# 4.调整应用的特权级

## 4.1 应用的四种特权级

![image-20250629150104676](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250629150104676.png)

​	x86芯片支持四种特权级：

- 第0级权限最高，用于运行操作系统
-  第3级权限最低，用于运行应用程序
-  其余两级用于运行操作系统服务(可选)。

​	数据段访问相关的3种权限相关的配置位：段描述符DPL(Descriptor privilege level)、选择子(Request privilege level)、段寄存器CS中的CPL(Current privilege)。权限错误将产生段保护异常。

![image-20250629150835517](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250629150835517.png)

​	访问数据段(DS、ES、FS、GS)时，仅当DPL$\geq$Max(CPL,RPL)时才能访问，即本身的特权级要够大，且不能以过低的特权级请求去访问。当访问SS时，要求CPL=DPL=RPL。

![image-20250629151333338](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250629151333338.png)

​	代码段访问相关的3种与权限相关的配置位：段描述符DPL（Descriptor privilege level）和C位、选择子RPL（Requested privilege level)、段寄存器CS中的CPL（privilege level）。

![image-20250629151538853](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250629151538853.png)

​	访问非一直代码段时(C=0)，CPL=DPL，且RPL$\leq$CPL，即权限一样。

​	访问一直代码段时(C=1)，CPL$\geq$DPL，RPL不检查，即访问者的权限要与被访问的代码要相等或更低。

​	我们的设计：由于采用了平坦模型，所以分段保护做不到真正的保护。

![image-20250629151938553](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250629151938553.png)

​	故我们使用分页机制实现保护机制。低权限的应用程序执行时，没有办法访问需要高特权级访问的操作系统的代码。

![image-20250629152154366](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250629152154366.png)

​	我们的设计：简化处理，操作系统运行特权级0，应用进程运行特权级3，全部使用非一致性代码段，CPL = RPL

![image-20250629152231245](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250629152231245.png)

​	修改`task_manager_t`,添加`app_code_sel`(代码段选择子)，`app_data_sel`。

```c
/**
 * 任务管理器
 */
typedef struct _task_manager_t
{
    list_t ready_list; // 就绪队列
    list_t task_list;  // 所有已经创建的任务
    task_t first_task; // 第一个任务
    task_t *curr_task; // 当前运行的任务
    list_t sleep_list; // 进程睡眠队列
    task_t idle_task; // 空闲进程
    int app_code_sel; // 代码段选择子
    int app_data_sel; // 数据段选择子
} task_manager_t;
```

​	同时修改`task_manager_init()`,添加对数据段、代码段的设置。

```c
static int tss_init (task_t * task, uint32_t entry, uint32_t esp) {
    // 为TSS分配GDT
    int tss_sel = gdt_alloc_desc();
    if (tss_sel < 0) {
        log_printf("alloc tss failed.\n");
        return -1;
    }

    segment_desc_set(tss_sel, (uint32_t)&task->tss, sizeof(tss_t),
            SEG_P_PRESENT | SEG_DPL0 | SEG_TYPE_TSS);

    // tss段初始化
    kernel_memset(&task->tss, 0, sizeof(tss_t));

    int code_sel, data_sel;
    // 注意加了RP3,不然将产生段保护错误
    code_sel = task_manager.app_code_sel | SEG_RPL3; //SEG_RPL3为3<<0

    data_sel = task_manager.app_data_sel | SEG_RPL3;

    task->tss.eip = entry;
    task->tss.esp = task->tss.esp0 = esp;
    task->tss.ss0 = data_sel;
    task->tss.eip = entry;
    task->tss.eflags = EFLAGS_DEFAULT| EFLAGS_IF;
    task->tss.es = task->tss.ss = task->tss.ds = task->tss.fs 
            = task->tss.gs = data_sel;   // 全部采用同一数据段
    task->tss.cs = code_sel; 
    task->tss.iomap = 0;

    // 页表初始化
    uint32_t page_dir = memory_create_uvm();
    if (page_dir == 0) {
        gdt_free_sel(tss_sel);
        return -1;
    }
    task->tss.cr3 = page_dir;

    task->tss_sel = tss_sel;
    return 0;
}
```

​	经此调整`first_task`运行到特权级0，`idle_task`运行在权限3.

## 4.2调整异常处理函数

​	发生异常时，会自动跳转到操作系统的异常处理程序中(DPL = 0)。由于权限切换(CPL = 0) , 所以栈也会发生变化。

![image-20250630160704546](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250630160704546.png)

​	不能将`task->tss.ss0`设置为`data_sel`，`data_sel`是特权级3下的栈，可将其修改成内核数据选择子`KERNEL_SELECTOR_DS`，修改后既可正常进入异常处理程序。

```c
/**
 * @brief        : 对指定任务的TSS进行初始化包括设置GDT表项,寄存器设置,任务入口地址
 * @param         {task_t *} task: 需要运行的任务
 * @param         {int} flag: 1为系统进程,0为普通进程
 * @param         {uint32_t} entry: 入口地址
 * @param         {uint32_t} esp: 栈顶指针
 * @return        {int} 成功为0 ,失败为-1
 **/
static int tss_init(task_t *task, int flag, uint32_t entry, uint32_t esp)
{
    int tss_sel = gdt_alloc_desc(); // 分配一个空闲表项,
    if (tss_sel < 0)
    {
        log_printf("alloc tss failed!!!\n");
        return -1;
    }
    segment_desc_set(tss_sel, (uint32_t)&task->tss, sizeof(tss_t),
                     SEG_P_PRESENT | SEG_DPL0 | SEG_TYPE_TSS); // 为该表项设置属性

    int code_sel, data_sel;
    if (flag & TASK_FLAGS_SYSTEM)
    {
        code_sel = KERNEL_SELECTOR_CS; // 设置代码段权限
        data_sel = KERNEL_SELECTOR_DS; // 设置数据段权限
    }
    else
    {
        code_sel = task_manager.app_code_sel | SEG_CPL3; // 设置代码段权限
        data_sel = task_manager.app_data_sel | SEG_CPL3; // 设置数据段权限
    }
    kernel_memset(&task->tss, 0, sizeof(tss_t)); // 清零 , 第一次运行无关紧要
    uint32_t kernel_stack = memory_alloc_page(); // 分配内核栈空间
    if (kernel_stack == 0)
    {
        goto tss_init_failed;
    }
    task->tss.eip = entry; // 当前任务没有运行过,所以eip为当前任务的入口地址
    task->tss.esp = esp;   // esp特权级3 , 设置栈地址
    task->tss.esp0 = kernel_stack + MEM_PAGE_SIZE;

    // 平坦模型只有两个段cs和ds 其中ss , es , ds , fs , gs 设置为ds
    task->tss.ss = data_sel;
    task->tss.ss0 = KERNEL_SELECTOR_DS;
    task->tss.es = task->tss.ds = task->tss.fs = task->tss.gs = data_sel;

    // 设置cs
    task->tss.cs = code_sel;
    task->tss.iomap = 0;
    // eflags
    task->tss.eflags = EFLAGS_DEFAULT | EFLAGS_IF;
    uint32_t page_dir = memory_create_uvm(); // 页目录表
    if (page_dir == 0)
    {
        goto tss_init_failed;
    }
    task->tss.cr3 = page_dir;
    task->tss_sel = tss_sel;
    return 0;
tss_init_failed:
    gdt_free_sel(tss_sel);
    return -1;
}
```

![image-20250630161758032](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250630161758032.png)	

​	同时进一步修改异常处理函数，发生页异常`cr2`指出发生异常的地址，发生GP异常时，错误信息如下图。

![image-20250630161900092](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250630161900092.png)

```c
/**
 * @brief        : 段保护异常处理函数
 * @param         {exception_frame_t} *frame: 保存在寄存器中的异常信息结构体
 * @return        {*}
 **/
void do_handler_general_protection(exception_frame_t *frame)
{
    log_printf("--------------------------------");
    log_printf("IRQ/Exception happend: General Protection.");
    if (frame->error_code & ERR_EXT)
    {
        log_printf("the exception occurred during delivery of an "
                   "event external to the program, such as an interrupt"
                   "or an earlier exception.");
    }
    else
    {
        log_printf("the exception occurred during delivery of a"
                   "software interrupt (INT n, INT3, or INTO).");
    }

    if (frame->error_code & ERR_IDT)
    {
        log_printf("the index portion of the error code refers "
                   "to a gate descriptor in the IDT");
    }
    else
    {
        log_printf("the index refers to a descriptor in the GDT");
    }

    log_printf("segment index: %d", frame->error_code & 0xFFF8);

    dump_core_regs(frame);
    while (1)
    {
        hlt();
    }
}
/**
 * @brief        : 页异常处理函数
 * @param         {exception_frame_t} *frame: 保存在寄存器中的异常信息结构体
 * @return        {*}
 **/
void do_handler_page_fault(exception_frame_t *frame)
{
    log_printf("--------------------------------");
    log_printf("IRQ/Exception happend: Page fault.");
    if (frame->error_code & ERR_PAGE_P)
    {
        log_printf("\tpage-level protection violation: 0x%x.", read_cr2());
    }
    else
    {
        log_printf("\tPage doesn't present 0x%x", read_cr2());
    }

    if (frame->error_code & ERR_PAGE_WR)
    {
        log_printf("\tThe access causing the fault was a read.");
    }
    else
    {
        log_printf("\tThe access causing the fault was a write.");
    }

    if (frame->error_code & ERR_PAGE_US)
    {
        log_printf("\tA supervisor-mode access caused the fault.");
    }
    else
    {
        log_printf("\tA user-mode access caused the fault.");
    }

    dump_core_regs(frame);
    while (1)
    {
        hlt();
    }
}

```

## 4.3 修改任务的特权级

​	空闲任务`idle_task`代码量小，执行特殊指令

![image-20250630165419379](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250630165419379.png)

​	加入标志位`flag`，初始化时使用确定其特权级。

```c
static int tss_init(task_t *task, int flag, uint32_t entry, uint32_t esp)
{
    ...原有代码...
    int code_sel, data_sel;
    if (flag & TASK_FLAGS_SYSTEM) // 特权级0
    {
        code_sel = KERNEL_SELECTOR_CS; // 设置代码段权限
        data_sel = KERNEL_SELECTOR_DS; // 设置数据段权限
    }
    else // 特权级3
    {
        code_sel = task_manager.app_code_sel | SEG_CPL3; // 设置代码段权限
        data_sel = task_manager.app_data_sel | SEG_CPL3; // 设置数据段权限
    }
    ...原有代码...
}
```

## 4.3 切换至应用进程的特权级为最低

​	如何实现特权级0转移到特权级3？

​	要实现低特权级返回，需要使用`IRET`指令。

![image-20250630170122736](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250630170122736.png)

```c
/**
 * @brief        : 跳转到第一个进程
 * @return        {*}
 **/
void move_to_first_task(void)
{
    task_t *curr = task_current(); // 取当前进程
    ASSERT(curr != 0);             // 不为空
    tss_t *tss = &(curr->tss);
    __asm__ __volatile__(
        "push %[ss]\n\t"
        "push %[esp]\n\t"
        "push %[eflags]\n\t"
        "push %[cs]\n\t"
        "push %[eip]\n\t"
        "iret" ::[ss] "r"(tss->ss),
        [esp] "r"(tss->esp),
        [eflags] "r"(tss->eflags),
        [cs] "r"(tss->cs),
        [eip] "r"(tss->eip));
}

```

这里使用压栈+iret指令是为了实现从内核态到用户态的特权级切换。让我解释一下原因：

## 特权级切换的需要

1. **当前状态**：`init_main()`运行在内核态（Ring 0）
2. **目标状态**：第一个用户进程需要运行在用户态（Ring 3）

## iret指令的作用

`iret`（中断返回）指令专门用于从中断/异常处理程序返回，它会：

1. **自动恢复CPU状态**：从栈中弹出EIP、CS、EFLAGS等寄存器
2. **特权级检查**：如果CS段选择子指示不同特权级，会自动切换栈并恢复SS、ESP
3. **原子操作**：整个过程是原子的，避免了手动设置寄存器的复杂性

**压栈顺序的意义**

```c
"push %[ss]\n\t"      // 用户态栈段选择子
"push %[esp]\n\t"     // 用户态栈指针
"push %[eflags]\n\t"  // 标志寄存器
"push %[cs]\n\t"      // 用户态代码段选择子  
"push %[eip]\n\t"     // 用户进程入口地址
"iret"                // 中断返回
```

这个顺序模拟了CPU在中断时自动压栈的格式，让`iret`能够正确解析。

**为什么不直接跳转**

直接的`jmp`指令无法实现特权级切换，而`iret`是x86架构中实现Ring 0到Ring 3切换的标准方法。这样确保了：
- 正确的特权级转换
- 用户态栈的正确设置
- CPU状态的完整恢复

## 4.4 为进程添加特权级0的栈

​	目前进程特权级0和特权级3使用的是同一个栈，因此需要额外创建一个栈，以便不同特权级栈的分离。

![image-20250630171953580](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250630171953580.png)

​	各特权级栈空间的设置如下：

​	对于`first_task`将其的栈空间设置为起始地址设置为`first_start + alloc_size`(由高地址往低地址增长)

```c
/**
 * @brief        : 初始化OS中的第一个任务
 * @return        {void}
 **/
void task_first_init(void)
{
    void first_task_entry(void);                                  // 第一个任务入口 线性地址
    extern uint8_t s_first_task[], e_first_task[];                // 物理起始地址与结束地址
    uint32_t copy_size = (uint32_t)(e_first_task - s_first_task); // 搬运大小
    uint32_t alloc_size = 10 * MEM_PAGE_SIZE;
    ASSERT(copy_size < alloc_size);
    uint32_t first_start = (uint32_t)first_task_entry;
    task_init(&task_manager.first_task, "first task",
              0, first_start,
              first_start + alloc_size); // 指定起始地址,first_start + alloc_size为栈低(由高向低增长)
    write_tr(task_manager.first_task.tss_sel);
    task_manager.curr_task = &task_manager.first_task;
    mmu_set_page_dir(task_manager.first_task.tss.cr3); // 切换页目录表

    // 切换页目录表后,分配页表空间
    memory_alloc_page_for(first_start, alloc_size, PTE_P | PTE_W | PTE_U);
    // 分配完后拷贝
    kernel_memcpy((void *)first_start, s_first_task, copy_size);
}
```

​	对于特权级为0的栈空间，重新申请一页内存空间用于异常发生，中断等发生时用的栈空间。

```c
/**
 * @brief        : 对指定任务的TSS进行初始化包括设置GDT表项,寄存器设置,任务入口地址
 * @param         {task_t *} task: 需要运行的任务
 * @param         {int} flag: 1为系统进程,0为普通进程
 * @param         {uint32_t} entry: 入口地址
 * @param         {uint32_t} esp: 栈顶指针
 * @return        {int} 成功为0 ,失败为-1
 **/
static int tss_init(task_t *task, int flag, uint32_t entry, uint32_t esp)
{
    int tss_sel = gdt_alloc_desc(); // 分配一个空闲表项,
    if (tss_sel < 0)
    {
        log_printf("alloc tss failed!!!\n");
        return -1;
    }
    segment_desc_set(tss_sel, (uint32_t)&task->tss, sizeof(tss_t),
                     SEG_P_PRESENT | SEG_DPL0 | SEG_TYPE_TSS); // 为该表项设置属性

    int code_sel, data_sel;
    if (flag & TASK_FLAGS_SYSTEM) // 特权级0
    {
        code_sel = KERNEL_SELECTOR_CS; // 设置代码段权限
        data_sel = KERNEL_SELECTOR_DS; // 设置数据段权限
    }
    else // 特权级3
    {
        code_sel = task_manager.app_code_sel | SEG_CPL3; // 设置代码段权限
        data_sel = task_manager.app_data_sel | SEG_CPL3; // 设置数据段权限
    }
    kernel_memset(&task->tss, 0, sizeof(tss_t)); // 清零 , 第一次运行无关紧要
    uint32_t kernel_stack = memory_alloc_page(); // 分配内核栈空间
    if (kernel_stack == 0)
    {
        goto tss_init_failed;
    }
    task->tss.eip = entry;                         // 当前任务没有运行过,所以eip为当前任务的入口地址
    task->tss.esp = esp;                           // esp特权级3 , 设置栈底地址
    task->tss.esp0 = kernel_stack + MEM_PAGE_SIZE; // esp0特权级0 , 设置栈底地址

    // 平坦模型只有两个段cs和ds 其中ss , es , ds , fs , gs 设置为ds
    task->tss.ss = data_sel;
    task->tss.ss0 = KERNEL_SELECTOR_DS;
    task->tss.es = task->tss.ds = task->tss.fs = task->tss.gs = data_sel;

    // 设置cs
    task->tss.cs = code_sel;
    task->tss.iomap = 0;
    // eflags
    task->tss.eflags = EFLAGS_DEFAULT | EFLAGS_IF;
    uint32_t page_dir = memory_create_uvm(); // 页目录表
    if (page_dir == 0)
    {
        goto tss_init_failed;
    }
    task->tss.cr3 = page_dir;
    task->tss_sel = tss_sel;
    return 0;
tss_init_failed:
    gdt_free_sel(tss_sel);
    return -1;
}

```

内存释放于申请函数：

```c
/**
 * @brief        : 分配一页物理内存
 * @return        {uint32_t}
 **/
uint32_t memory_alloc_page(void)
{
    uint32_t addr = addr_alloc_page(&paddr_alloc, 1);
    return addr;
}
/**
 * @brief        : 释放一页物理内存
 * @param         {uint32_t} addr:
 * @return        {*}
 **/
void memory_free_page(uint32_t addr)
{
    if (addr < MEMORY_TASK_BASE) // 地址小于进程起始空间,直接释放
    {
        addr_free_page(&paddr_alloc, addr, 1);
    }
    else // 超过进程起始空间,线性地址(虚拟地址)
    {
        pte_t *pte = find_pte(curr_page_dir(), addr, 0); // 对于的页表项
        ASSERT((pte != (pte_t *)0) && pte->present);
        addr_free_page(&paddr_alloc, pte_paddr(pte), 1); // 释放该表项
        pte->v = 0;                                      // 清楚映射关系,表项清空
    }
}
```


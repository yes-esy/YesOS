# 1.添加任务管理器

​	目前的`OS`的实现只支持两个任务，当任务数量多了以后，需要统一管理。

- 只支持两个任务
- 需要进程自己主动切换
- 不支持延时等功能

```c
init_main();
first_task();		
```

​	系统中将创建任务/进程管理器负责对就绪、已经创建、延时状态的进程进行统一管理。

![image-20250426160634252](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250426160634252.png)

![image-20250426162703531](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250426162703531.png)

**任务管理器结构：**

```c
typedef struct _task_manager_t {
    task_t * curr_task;         // 当前运行的任务
	list_t ready_list;			// 就绪队列
	list_t task_list;			// 所有已创建任务的队列
	task_t first_task;			// 内核任务
}task_manager_t;
```

- 就绪队列`ready_list`：放置就绪任务，即进程已经就绪，只差`cpu`
- 进程队列`task_list`：系统中所有已经创建好的任务都将放入其中。
- `first_task`：==进程用于完成某些初始化工作，也是将来计算机从无操作系统运行到有操作系统运行切换时，运行的第一个进程。==

​	相应需要对该结构进行初始化，具体如下：

```
/**
 * @file task.c 
 * @brief 任务管理器初始化
 */
void task_manager_init (void) {
    // 各队列初始化
    list_init(&task_manager.ready_list);
    list_init(&task_manager.task_list);

    task_manager.curr_task = (task_t *)0;
}

```



# 2.将任务加入就绪队列

​	当任务初始化完成时，就进入`created`状态，当加入就绪队列时，则进入`ready`状态。

![image-20250505161726481](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250505161726481.png)

**进程控制块：**

```c
/**
 * @brief 任务(进程)控制块结构
 */
typedef struct _task_t {
    enum{
        TASK_CREATED, // 创建
        TASK_RUNNING, // 运行
        TASK_SLEEP,   // 延时
        TASK_READY,   // 就绪
        TASK_WAIT,    // 等待
    } state;
    char name[TASK_NAME_SIZE];		// 任务名
    tss_t tss;				// 任务的TSS段
    uint16_t tss_sel;		// tss选择子
    list_node_t run_node;		// 运行相关结点
    list_node_t all_node;		// 所有队列结点
}task_t;
```

- 在加入就绪队列时，使用`run_node`插入到就绪队列中，将来从就绪队列中取出的也是该节点。
- 在`task_t`结构中添加进程状态`state`用于表明当前状态进程。

> `run_node`：用来将任务链接到与任务运行状态相关的列表中的节点：
>
> 1. 当任务处于"就绪"状态时，这个节点会被用来将任务插入到任务管理器中的`ready_list`（就绪队列）中。
> 2. 当任务状态发生变化（比如从`RUNNING`变为`READY`，或从`SLEEP`变为`READY`）时，系统会操作这个节点来调整任务在相应队列中的位置。
> 3. 这个节点使得调度器能够快速遍历所有准备运行的任务，进行任务调度。
>
> `all_node`：是用来将任务链接到任务管理器`task_list`（所有已创建的队列）中的结点：
>
> 1. 无论任务处于什么状态（运行、就绪、睡眠等），它都会通过这个节点被链接到`task_list`中。
> 2. 这使得系统可以跟踪和管理所有已创建的任务，不管它们当前是否活跃。
> 3. 对于任务统计、任务查找、资源管理等功能非常重要。

同样在进程初始化时需要将`run_node`，`all_node`进行初始化

```c

/**
 * task.c中task_init.c函数相应修改
 * @brief 初始化任务
 */
int task_init (task_t *task, const char * name, uint32_t entry, uint32_t esp) {
    ASSERT(task != (task_t *)0);
    int err = tss_init(task, entry, esp);
    if (err < 0) {
        log_printf("init task failed.\n");
        return err;
    }
    // 任务字段初始化
    kernel_strncpy(task->name, name, TASK_NAME_SIZE);
    task->state = TASK_CREATED;
    list_node_init(&task->all_node); //初始化
    list_node_init(&task->run_node);

    // 插入就绪队列中和所有的任务队列中
    task_set_ready(task); 
    list_insert_last(&task_manager.task_list, &task->all_node);
    return 0;
}

/**
 * @brief 将任务插入就绪队列
 */
void task_set_ready(task_t *task) {
    list_insert_last(&task_manager.ready_list, &task->run_node);
    task->state = TASK_READY;
}
```

# 3.让进程主动放弃`CPU`

​	目前的实现中，`cpu`总是被用于安排运行处于就绪队列头部的进程的代码，所以导致如果该进程始终处于头部，那么气候的任务将迟迟得不到运行的机会，出现饥饿现象。

​	我们的解决方法为：<span style="color:red">让进程主动放弃`CPU`,自觉移到队列尾部，从而给其它进程留出运行的机会。</span>

​	为实现该功能，我们主要做了以下两点：

- 进程将自己移动到队列尾部
- 调用`task_dispatch`获取下要运行的任务并切换。

​	其中`task_dispatch()`的功能比较简单，只是获取处于就绪队列头部的进程，然后切换过去。

​	而在高级一些的操作系统中，并不会这么简单，它会给进程添加不同的优先级，并且放置于多种队列中。类似task_dispatch()功能的函数，实现起来更为复杂。

```c
/**
 * @brief 当前任务主动放弃CPU
 */
int sys_yield (void) {
    if (list_count(&task_manager.ready_list) > 1) {
        task_t * curr_task = task_current();
        // 如果队列中还有其它任务，则将当前任务移入到队列尾部
        task_set_block(curr_task);
        task_set_ready(curr_task);
        // 切换至下一个任务，在切换完成前要保护，不然可能下一任务
        // 由于某些原因运行后阻塞或删除，再回到这里切换将发生问题
        task_dispatch();
    }
    return 0;
}
/**
 * @brief 将任务从就绪队列移除
 */
void task_set_block (task_t *task) {
    list_remove(&task_manager.ready_list, &task->run_node);
}
/**
 * @brief 进行一次任务调度
 */
void task_dispatch (void) {
    task_t * to = task_next_run();
    if (to != task_manager.curr_task) {
        task_t * from = task_manager.curr_task;
        task_manager.curr_task = to;
        to->state = TASK_RUNNING;
        task_switch_from_to(from, to);
    }
}
```



# 4.简单的调度算法：时间片轮转

​	由于是需要强制处于队列头部的任务放弃`CPU`，因此必须借助中断才能强制中断当前进程的运行。而中断中，只有定时器最合适，因此我们借助定时器强制剥夺进程的CPU使用权。

![image-20250505203031204](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250505203031204.png)

​	具体实现：以周期性的定时中断为基准，给每个任务相同的`CPU`的使用时长，一旦超过时长则被强制剥夺进程的CPU使用权进入队尾。

​	相关处理：

```c
/**
 * core/task.h
 * @brief 任务控制块结构
 */
typedef struct _task_t {
    enum {
		TASK_CREATED,
		TASK_RUNNING,
		TASK_SLEEP,
		TASK_READY,
		TASK_WAITING,
	}state;

    char name[TASK_NAME_SIZE];		

	int time_slice;			// 新增时间片
	int slice_ticks;		// 新增递减时间片

	tss_t tss;				
	uint16_t tss_sel;		
	
	list_node_t run_node;		
	list_node_t all_node;		
}task_t;

/**
 * dev/time.c中
 * 定时器中断处理函数
 */
void do_handler_timer (exception_frame_t *frame) {
    sys_tick++;

    // 先发EOI，而不是放在最后
    // 放最后将从任务中切换出去之后，除非任务再切换回来才能继续噢应
    pic_send_eoi(IRQ0_TIMER);
    task_time_tick(); // 每一次时间中断调用
}


/**
 * tack.c中实现
 * @brief 时间处理
 * 该函数在中断处理函数中调用
 */
void task_time_tick (void) {
    task_t * curr_task = task_current();
    // 时间片的处理
    if (--curr_task->slice_ticks == 0) {
        // 时间片用完，重新加载时间片
        // 对于空闲任务，此处减未用
        curr_task->slice_ticks = curr_task->time_slice;
        // 调整队列的位置到尾部，不用直接操作队列
        task_set_block(curr_task);
        task_set_ready(curr_task);
        task_dispatch();
    }
}
```

# 5.临界资源及简单保护

## 5.1 并发与并行	

​	引入操作系统后，计算机中程序的运行方式发了很大的变化，不再是单个程序在跑，而是可能多个程序程序“同时“在跑。同时这个词实际上并不严谨，具体可以分为并发与并行。

> ==并发==，在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。

​	这个概念，对应到我们前面写过的代码上，体现如下图所示。可以看到，在并发运行模式下，并不是多个进程真的在同时运行，而是让CPU来回的在不同进程之间快速切换执行。由于这种速度很快，给用户的感觉就是每个进程一直在执行。而之所以有并发的存在，是因为处理器的数量限制，在这里只有一个。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1666002307410-3539e9c7-3a06-43a1-96c9-2d00f6e407f7.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)



> 当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1666002414186-1e7529bb-5f7b-470f-b410-790fa43a2292.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

## 5.2 临界资源与临界区

​	当多进程运行起来后，由于系统中一些资源数量有限，比如`log_printf`使用的串口，所以当多个进程同时使用`log_printf`时，就有可能出现冲突的情况，导致输出的情况出现混乱。

- ==临界区：访问临界资源的程序片段==

- ==临界资源：临界资源是一次仅允许一个进程使用的共享资源==

​	下图所示即为临界资源(访问串口)。

![image-20250506214846653](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250506214846653.png)

## 5.3解决访问冲突的方法

​	在多进程的情况下，进程的切换是有可能发生在任何时间点和代码位置的，也就是说一个进程在执行临界区中的代码时，可能会被打断切换到另一个进程执行。另一个进程也操作这个资源。为了避免这种问题的发生，可以使用这种方法：==一次只让一个进程执行临界区中的代码。==

​	而目前我们的代码中，<span style="color:skyblue">进程之间是按时间片运行，由定时器中断处理程序中完成。因此，可以简单的将中断给禁用(关中断)掉就可以防止定时中断处理程序被调用，进而防止任务切换的发生。</span>

`cpu/irq.c`中

```c
/**
 * @brief        : 进入临界区,读取eflags的值，关中断
 * @return        {irq_state_t}eflags的值
 **/
irq_state_t irq_enter_protection(void)
{

    irq_state_t state = read_eflags();

    irq_disable_global();

    return state;
}
/**
 * @brief        : 退出临界区,将eflags原来的值写回
 * @param         {irq_state_t} state: 原eflags的值
 * @return        {*}
 **/
void irq_leave_protection(irq_state_t state)
{
    write_eflags(state);
}

```

# 6.为任务增加延时接口

## 6.1延时原理

​	延时的实现原理比较简单：**将进程从就绪队列中移除，这样`OS`就不用安排`CPU`运行这个进程的代码。之后，等指定的时间结束后，再将进程插入到就绪队列，这样进程又可以继续运行。**

​	由于系统中可能会有多个进程同时延时 ，为了将这些进程有效的管理，额外实现了一个延时队列，将需要延时的进程插入到延时队列中，同时在进程的`task_t`结构中记录进程延时时间`sleep_ticks`。



```c
/**
 * 进程控制块结构
 */
typedef struct _task_t
{
    enum
    {
        TASK_CREATED, // 创建
        TASK_RUNNING, // 运行
        TASK_SLEEP,   // 延时
        TASK_READY,   // 就绪
        TASK_WAIT,    // 等待
    } state;

    int time_ticks;            // 进程运行时间片
    int slice_ticks;           // 进程已运行时间
    
    // 新增
    int sleep_ticks;           // 进程睡眠时间
    char name[TASK_NAME_SIZE]; // 任务名

    list_node_t run_node; // 运行相关结点
    list_node_t all_node; // 所有队列结点

    // uint32_t * stack;
    tss_t tss;        // 任务的tss段
    uint32_t tss_sel; // tss选择子
} task_t;		
```

​	之后在每个定时中断发生时，扫描延时队列。当发现某个进程延时到达时，将其从队列中移除插回就绪队列。

![image-20250507200256562](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250507200256562.png)

​	使用sys_sleep()进行延时，实际延时是有误差的，不会准确的延时指定的时间。这个误导致的原因可能是因为：调用延时函数的时机、延时到达后进程还要继续等待才能有机会运行。对于比较短小的延时，误差就误得比较明显。而当延时比较长，如几十秒、几分钟这种，这种误差看起来影响则没那么大。

# 7.让所有任务都延时

​	当系统中所有任务都尝试延时时，系统将崩溃。这是因为当所有任务都延时时，操作系统将不知道做什么，目前代码也不知道如何处理。

​	因此我们的解决方法时增加一个==空闲进程==。这个进程是在其他所有进程都不需要运行的时候才运行。

```c
static void idle_task_entry()
{
    log_printf("idle task running");
    for (;;)
    {
        hlt();
    }
}
```

​		同时，在进程调度，进程就绪，进程阻塞等等实现都要加上判断当前进程是否为空闲进程。

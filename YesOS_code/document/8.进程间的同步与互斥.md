# 1.计数信号量及其初始化

![image-20250507210326782](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250507210326782.png)

信号量**提供了一种让进程能够暂停运行直至等待某种事件发生/某种资源可用等事件，再继续往下运行的功能**

> [信号量](https://so.csdn.net/so/search?q=信号量&spm=1001.2101.3001.7020)是由操作系统提供的一种用于进程间同步和互斥的工具

```c
typedef struct _sem_t
{
    int count;        // 可以使用的临界资源的数量
    list_t wait_list; // 等待队列
} sem_t;

```




```c
/**
 * kernel/ipc/sem.c
 * @brief        : 信号量初始化，初始化等待队列，计数值等
 * @param         {sem_t} *sem: 待初始化的信号量
 * @param         {int} init_count: 初始计数值
 * @return        {*}
 **/
void sem_init(sem_t *sem, int init_count)
{
    sem->count = init_count;
    list_init(&sem->wait_list);
}
```

## 1.1发信号与等信号

​	由于事件发生的娥次数可能不止一次，或者资源可用数量可能不止一个，因此信号量内部维护一个计数器，用于表示某种事件发生的次数或者某种资源可用的数量。

​	同时信号量至少提供两种操作，一种是等信号(`p,wait`)，一种是发信号(`v,signal`)

### 1.1.2等信号

​	对于进程而言，如果某些临界资源已被占用导致没有资源可用，即信号量的计数值为0，则进程需要等待；反之，有临界资源可以使用，即信号量的计数值大于0，将信号量的计数值减一继续执行即可即可。

```c
/**
 * kernel/ipc/sem.c
 * @brief        : 等信号，如果当前信号量的计数值为0，则当前进程需等待，调度下一进程执行；反之。计数值减一，并继续执行
 * @param         {sem_t} *sem: 信号量
 * @return        {*}
 **/
void sem_wait(sem_t *sem)
{
    irq_state_t state = irq_enter_protection();
    if (sem->count > 0)
    {
        sem->count--;
    }
    else
    {
        task_t *curr = task_current();
        task_set_block(curr);                                // 阻塞当前进程
        list_insert_last(&sem->wait_list, &curr->wait_node); // 插入到等待队列中
        task_dispatch();                                     // 调度下一进程
    }
    irq_leave_protection(state);
}
```

### 1.1.3发信号

​	当进程需要使用的临界资源已经空闲，或者有新的临界资源可以使用，就可以上信号量通知正在等待的进程，告知进程等待的事件或资源已发生或到达，可以继续运行。此时，信号量的计数值不变，相当于该进程获得了事件或资源的处理权。

​	若没有正在等待的进程，则将信号量的计数值加1，表示新的资源或事件可用。

> 若有进程等待，则唤醒进程执行；否则，信号量计数值加1。

```c
/**
 * kernel/ipc/sem.c
 * @brief        : 发信号（v,signal），某些事件完成或某些资源到达，等待队列中有进程则插入就绪队列，否则，信号量计数值加1，
 * @return        {*}
 **/
void sem_signal(sem_t *sem)
{
    irq_state_t state = irq_enter_protection();
    if (list_count(&sem->wait_list)) // 等待队列中是否有进程在等待
    {
        list_node_t *node = list_remove_first(&sem->wait_list);   // 有则将取出等待队列中第一个进程
        task_t *task = list_node_parent(node, task_t, wait_node); // 找到该进程
        task_set_ready(task);                                     // 插入就绪队列
        task_dispatch();                                          // 调度下一个进程
    }
    else // 等待队列没有进程等待
    {
        sem->count++; // 计数值++，表示有新的资源
    }
    irq_leave_protection(state);
}
```

## 1.2使用信号量

```c
void init_main()
{
    log_printf("Kernel is running . . .");
    log_printf("Version:%s", OS_VERSION);
    task_init(&first_task, "init task", (uint32_t)first_task_entry, (uint32_t)&first_task_stack[1024]); // x86栈地址由高到低增长 ,同时init_task需要一个单独的栈空间。
    task_first_init();
    sem_init(&sem,0); //初始化信号量
    int count = 0;
    for (;;)
    {
        log_printf("init main , count is %d", count++);
        sem_signal(&sem); // 打印完了，发信号，通知下一进程可以使用串口
        sys_sleep(10000);
    }
}

void first_task_entry(void)
{
    int count = 0;
    for (;;)
    {
        sem_wait(&sem); // 等信号，不知道是相关事件或临界资源已到达
        log_printf("first_task_entry , count is %d", count++);
        sys_sleep(1000);
    }
}
```

# 2.互斥锁及其初始化

## 2.1开关中断的问题

​	我们在前面实现了开关中断的方法，通过处理器的`cli/sti`指令可以快速的开关中断，进而关掉定时中断，防止切换进程。但是这种方法任然出在问题，即中断响应也会被关闭。而有时候，一些中断是非常紧急，需要立即处理，所以关中断很多时候并不合适。

## 2.2互斥锁

​	所谓的互斥锁，可将它理解为一把锁，利用这把锁可以将资源（如内存、外部设备）锁起来，只有拥有这把锁的人才能使用资源。这样就避免了多个同时去使用，实现互相排斥。锁+互斥，就是互斥锁。

​	操作系统中，进程在进入临界区时，首先要获取这把锁，然后才能进入临界区。如果这把锁被其它进程占用了，那么此时就会类似信号量那样，在锁上进行等待；直到其它进程释放了锁之后，进程获得锁，才能继续往下运行。

![image-20250510174418359](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250510174418359.png)

```c
typedef struct _mutex_t
{
    list_t wait_list; // 等待队列
    task_t *owner;    // 锁的拥有进程
    int locked_count; // 上锁次数
} mutex_t;
```

### 2.2.1初始化：

```c
void mutex_init(mutex_t *mutex)
{
    mutex->locked_count = 0;
    mutex->owner = (task_t *)0;
    list_init(&mutex->wait_list);
}
```

### 2.2.2上锁

​	上锁过程的实现为：如果已经上锁，则等待其它进程释放锁，当其它进程释放锁时，将锁据为已有。如果没有上锁，则获得这把锁。

​	在等待锁时，类似于在信号量上等，在互斥锁上也需要配置等待队列。当进程需要等待时，将进程从就绪队列中移除插入到等等队列。

![image-20250510175051514](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250510175051514.png)

```c
/**
 * kernel/ipc/mutex.c
 * @brief        : 对互斥锁进行上锁，未上锁则上锁（次数加1，拥有者为上锁进程）；已上锁，且为当前进程上的锁，次数增加即可；已上锁，但非当前进程所上的，
 * @param         {mutex_t} *mutex: 需要上锁的互斥锁
 * @return        {*}
**/
void mutex_lock(mutex_t *mutex)
{
    irq_state_t state = irq_enter_protection();
    task_t *curr = task_current();
    if (mutex->locked_count == 0) // 未上锁
    {
        mutex->locked_count++; // 上锁
        mutex->owner = curr;   // 锁的拥有者为当前执行的进程
    }
    else if (mutex->owner == curr) // 已经上锁，且为当前进程再次上锁
    {
        mutex->locked_count++; // 上锁次数增加即可
    }
    else // 已经上锁，但锁的拥有者非当前进程，需阻塞当前进程
    {
        task_set_block(curr);                                  // 当前进程需要等待，等待锁释放
        list_insert_last(&mutex->wait_list, &curr->wait_node); // 插入到等待队列
        task_dispatch();                                       // 调度下一个任务
    }
    irq_leave_protection(state);
}
```

### 2.2.3解锁

​	释放锁的过程较简单，和发送信号量类似。如果有进程等待，则唤醒进程继续执行，将其从等待队列中移除插入到就绪队列中，此时锁就被这个新就绪的进程所拥有。如果没有进程等，则只是将锁释放掉。

![image-20250510195131702](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250510195131702.png)

```c

/**
 * @brief        : 对互斥锁进行解锁操作
 * @details      : 释放当前进程持有的互斥锁。如果是可重入锁，则减少锁计数；
 *                 当计数为0时完全释放锁并唤醒等待队列中的第一个进程。
 *                 只有锁的持有者才能成功解锁。
 * @param         {mutex_t} *mutex: 待解锁的互斥锁
 * @return        {void}
 * @note         : 此函数在中断保护状态下执行，确保操作的原子性
 **/
void mutex_unlock(mutex_t *mutex)
{
    irq_state_t state = irq_enter_protection();

    task_t *curr = task_current(); // 获取当前进程

    if (mutex->owner == curr) // 只有锁的持有者才能解锁
    {
        if (--mutex->locked_count == 0) // 锁完全释放
        {
            mutex->owner = (task_t *)0; // 锁的拥有者清空

            if (list_count(&mutex->wait_list)) // 等待队列非空
            {
                list_node_t *task_node = list_remove_first(&mutex->wait_list); // 取出等待队列头节点（第一个进程）

                task_t *task = list_node_parent(task_node, task_t, wait_node); // // 从节点获取对应的进程

                task_set_ready(task); // // 将任务从阻塞状态改为就绪状态

                mutex->locked_count = 1; // 当前进程获得该所，即上锁一次

                mutex->owner = task; // 更新锁的拥有者为当前进程

                task_dispatch(); // 调度该进程
            }
        }
    }

    irq_leave_protection(state);
}
```

## 2.3应用互斥锁

### 2.3.1 互斥锁的应用限制

​	互斥锁的使用仅限于解决多进程访问共享资源时的冲突问题，并没有涉及中断。如果此时还有中断也有可能访问临界资源，那么使用互斥锁就不行了，它没办法禁止中断的发生。因此，此时必须使用开关中断。

### 2.3.2 一定要使用互斥锁吗？

​	不一定。如果多个进程均以只读的方式访问共享资源（比如内存），那么此时不需要进行保护，因为资源的状态（如内存值）总是不变的，同时访问不会有什么问题。


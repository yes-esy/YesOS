# 1.创建`GDT`表及其表项

## 1.1 系统架构

![image-20250413141553927](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250413141553927.png)

​	`GDT`是一个配置表，里面存储了有关存储访问相关的配置信息，也即`x86-32`位最核心的配置数据。在进入保护模式后，所有有关内存访问操作，都需要经过`GDT`,`GDT`中每项称为段描述符(Segment descriptors)。其具体格式如下：

![image-20250413141632276](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250413141632276.png)

​	大体分为三部分：

- `base addr`(基地址)
- `limit`(界限)
- `attr`(属性)

​	整个`GDT`表最大位`64KB`，每个表项为`8`字节，所以表项数最大为`8192`个。

​	在`GDT`表设置好以后，需要通过`lgdt()`来将该表的信息加载到`GDTR`寄存器中。`GDTR`是一个48位寄存器，包含`limit`和`base`两部分，如下图所示：

![image-20250413142157420](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250413142157420.png)

​	其中`base address`是`32`位，`limit`是`16`位。`limit`保存的`GDT`表项的字节大小，当其值为`0`时，表示其字节数为`1`；当`GDT`表项的数量为`N`时，`limit`的值设置成`8 * N - 1`。

> **全局描述符表GDT（Global Descriptor Table）**在整个系统中，全局描述符表GDT只有一张(一个处理器对应一个GDT)，GDT可以被放在内存的任何位置，但CPU必须知道GDT的入口，也就是基地址放在哪里，Intel的设计者门提供了一个**寄存器[GDTR](https://zhida.zhihu.com/search?content_id=2533962&content_type=Article&match_order=1&q=GDTR&zhida_source=entity)**用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过**[LGDT指令](https://zhida.zhihu.com/search?content_id=2533962&content_type=Article&match_order=1&q=LGDT指令&zhida_source=entity)**将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。GDTR中存放的是GDT在内存中的基地址和其表长界限。

https://zhuanlan.zhihu.com/p/25867829

# 2.保护模式下的内存管理简介

## 2.1 IA32内存管理机制概览

​	IA32将内存管理分为两部分：段式存储和页式存储，目前我们只考虑段式存储。由于这种处理，所以得出三种类型的地址：逻辑地址、线性地址、物理地址。

- 物理地址：实际的物理内存中的地址
- 逻辑地址：使用段+偏移表示的地址
- 线性地址：将段+偏移进行转换后的地址，也是我们程序中所使用的地址。如果分页机制未开启，则线性地址=物理地址。

其中段式存储特点如下：

- 将线性地址空间转变成多个段（segments）
- 每个段带有相关的保护机制
- 有多种类型的段：数据、代码、栈、门、tss
- 使用的地址为逻辑地址，即段选择子+偏移

页式存储的特点如下：

- 将线性地址转换为逻辑地址
- 在较小的内存上实现更大的虚拟内容
- 按需加载等功能

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1652416187360-c31dfce7-c4ec-4457-bca1-8dfef1a1aaa0.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

## 2.2平坦模型

​	`IA32`中段式存储比较复杂，本项目使用的是基础平坦模型，特点如下：

- 只使用了两个段：代码段和数据段
- 段起始地址均为0，大小为`4GB`。即不管实际有没有那么大的内存空间，都设置成那么大。访问不存在的区域会产生保护异常。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1652416508631-2b1e37da-6073-4c50-9330-35c305845446.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

​	即采用上述模型中，我们不使用`limit`界限检查，也不使用段的基地址功能，这样程序处理会更为简单。

![img](https://xiaoeeyu.github.io/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/c0fd4ef83504728378d25175bacdc8ed.png)

## 2.3 逻辑地址到线性地址的转换

​	在程序进行内存访问时，会进行逻辑地址的转换，转换到线性地址（暂不考虑分页机制)，转换过程如下：

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1652416852346-a8f794d7-c8cb-4973-807e-9d454a390283.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

# 3.重新加载GDT

## 3.1GDT表格式

![image-20250413145202154](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250413145202154.png)

以下仅界限表项的属性部分：

- S：1-代码段或数据段，0 - 系统段
- DPL：特权级，取值0-3
- P：段是否存在，1存在，0不存在
- D/B：指示代码或栈的大小是32位还是16位，1 - 32位，0-16位
- G：段界限的单位。1 - 界限的单位是4KB，0 - 字节。
- L和AVL：我们不没有用到，使用0即可。
- type：见下表，用于描述段的具体类型

![image-20250413145419137](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250413145419137.png)

`GDT`表类型

```c
typedef struct _segment_desc_t
{
    uint16_t limit15_0;
    uint16_t base15_0;
    uint8_t base23_16;
    uint16_t attr;
    uint8_t base31_24;
} segment_desc_t;
```

相关属性部分：

`/code/source/kernel/include/os_cfg.h`

```c
#define KELNER_SELECTOR_CS (1 * 8)   // 内核代码段描述符
#define KELNER_SELECTOR_DS (2 * 8)   // 内核数据段描述符
#define KERNEL_STACK_SIZE (8 * 1024) // 内核栈
```

`/code/source/kernel/include/cpu/cpu.h`

```c
#define SEG_G (1 << 15)        // 段界限的单位。1 - 界限的单位是4KB，0 - 字节。
#define SEG_D (1 << 14)        // 指示代码或栈的大小是32位还是16位，1 - 32位，0-16位
#define SEG_P_PRESENT (1 << 7) // 段是否存在，1存在，0不存在

#define SEG_DPL0 (0 << 5) // 特权级0
#define SEG_DPL3 (3 << 5) // 特权级3

#define SEG_S_SYSTEM (0 << 4) // 是否位系统段,如调用门或者中断
#define SEG_S_NORMAL (1 << 4) // 普通的代码段或数据段

#define SEG_TYPE_CODE (1 << 3) // 指定其为代码段
#define SEG_TYPE_DATA (0 << 3) // 指定其为数据段
#define SEG_TYE_RW (1 << 1)    // 是否可写可读,不设置为只读
```

**设置GDT表项：**

```c
void segment_desc_set(int selector, uint32_t base, uint32_t limit, uint16_t attr)
{
    segment_desc_t *desc = gdt_table + (selector >> 3);

    // 如果界限比较长，将长度单位换成4KB
    if (limit > 0xFFFFF)
    {
        attr |= 0x8000;
        limit /= 0x1000;
    }

    desc->limit15_0 = limit & 0xFFFF;
    desc->base15_0 = base & 0xFFFF;
    desc->base23_16 = (base >> 16) & 0xFF;
    desc->attr = attr | (((limit >> 16) & 0xF) << 8);
    desc->base31_24 = (base >> 24) & 0xFF;
}
```



## 3.2 GDTR寄存器

​	使用LGDT指令，可以将GDT表相关的信息加载到GDTR寄存器中。后续对寄存器的访问，都会通过其指向的GDT表。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1652420955398-2d727ad4-6259-418e-ac13-13e8ecb8f48a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_11%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

​	在重新设置后，需要使用`jmp$` 选择子, `$offset`跳转。有的同学认为，可以不跳转，因为`CS`的值为8，新表中代码段描述符对应的选择子也为8，二者相等，无需跳转。

​	之所以要重新跳转，是为了使`CS`寄存器重新加载新`GDT`表中相应的信息。如下图所求，`CS`寄存器除了保存选择子信息外，还会在内部自动保存从GDT表中加载的基地址、界限、属性等相关信息。当使用`jmp $`选择子, `$offset`进行跳转后，`CS`将从新表中加载新的信息，这样就避免了仍然使用原来的信息。所以，最好是重新加载，以使用新的信息。

![image-20250413145749666](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250413145749666.png)	

​	当然，在目前的工程中，由于新表中代码段相关的信息和旧表中的相同，所以不重新加载也不影响程序的运行。

> 在该部分实现中由于`_segment_desc_t`的定义时未设置结构体按1字节对齐导致qemu运行到`/code/source/init/start.S`中`jmp $KERBEL_SELECTOR_CS,$gdt_reload`后qemu重启

# 4.触发异常与异常简介

## 4.1 中断和异常

无论是中断和异常，都指的是在程序运行中发生的一些事情，只不过有些是`CPU`内部产生，一些则是`CPU`外部。

- 异常：由于`CPU`内部事件所引起的中断，如程序出错(非法指令，地址越界、除0异常)。通常由执行了现行指令所引起的。
- 中断：由于外部设备事件所引起的中断，通常是磁盘中断、打印机中断等与现行指令无关，由外部事件所引起。

## 4.2处理流程

基本的处理流程与其它类型的`CPU`上是一样的，大致流程为：

- 打断当前正在运行的程序
- 从向量表中取出处理程序的首地址，跳转到首地址运行；有些CPU中，向量表中存储的是跳转指令，则跳转到该指令处运行
- 执行完程序程序后，继续从之前中断地位置运行。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1652753545661-0dba36d6-babf-4312-921f-1426b5a1620d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

# 5.添加中断门描述符

​	进入`32`位保护模式后，向量表需要重新配置，不能再使用`BIOS`提供的表，因进入保护模式后，这些向量表不再可用。

## 5.1 IDT表

​	进入保护模式后，需要使用新的向量表，即`IDT`表。其配置类似于`GDT`,由`IDTR`寄存器指向该表。

![image-20250415184729291](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250415184729291.png)

​	`IDT`表项有多种类型，本项目只使用其中的`interrupt gate`。其中`interrupt gate`中`segment selector`指定了代码段的选择子，`offset`指定了偏移。即二者结合，指定了个表项对应的异常/中断处理程序的首地址。

![image-20250415185125173](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250415185125173.png)

​	地址生成如下：

- 根据向量号取IDT中的对应表项，
- 从IDT表项取选择子
- 用选择子从GDT表中查找段的首地址，
- 将段首地址+IDT表项中的偏移量，生成处理程序的首地址
- 跳转至首地址运行。

![image-20250415191045507](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250415191045507.png)

# 6.初始化`IDT`表

```c
/**
 * @brief        : 对中断门类型的表项进行设置
 * @param         {gate_desc_t} *desc: 指定的表项
 * @param         {uint16_t} selector: 对应的处理程序所在的代码段的选择子
 * @param         {uint32_t} offset: 地址偏移量
 * @param         {uint16_t} attr: 属性
 * @return        {*}
**/
void gate_desc_set(gate_desc_t *desc, uint16_t selector, uint32_t offset, uint16_t attr)
{
    desc->offset15_0 = offset & 0xFFFF;
    desc->selector = selector;
    desc->attr = attr;
    desc->offset31_16 = (offset >> 16) & 0xFFFF;
}
```



# 7.捕获除0异常

## 7.1 `IDT`表项的设置

​	在前面已经重新设置了`GDT`表，且已经知道所采用的段管理模式为平坦模型，即提供了两个段，代码段和数据段。

​	代码具体如下，可以看到其选择子分别为：`KERNEL_SELECTOR_DS`和`KERNEL_SELECTOR_CS`。这两段起始地址均从0开始。

```c
    // 数据段
    segment_desc_set(KERNEL_SELECTOR_DS, 0x00000000, 0xFFFFFFFF,
                     SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYE_RW | SEG_D | SEG_G);
    // 代码段
    segment_desc_set(KERNEL_SELECTOR_CS, 0x00000000, 0xFFFFFFFF,
                     SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE | SEG_TYE_RW | SEG_D | SEG_G);
    // 加载gdt
    lgdt((uint32_t)gdt_table, sizeof(gdt_table));
```

​	因此，根据上述配置和下面的图示，可知在配置`IDT`表项时，需要将`IDT`表项中的segment selector 设置为`KERNEl_SELECTOR_DS`，偏移量设置为函数入口地址即可。

## 7.2中断现场保护

​	在本项目中，为了简单起见，直接将所有的寄存器进行压栈保护，压入方法为中断发生时，`CPU`会自动保存一部分，其余在中断程序中，通过`push`指令压入一部分。

```assembly
# 保护现场
    pusha 
    push %ds
    push %es
    push %fs
    push %gs

    call do_handler_unknown

    # 恢复现场
    pop %gs
    pop %fs
    pop %es
    pop %ds
    popa
    iret
```

# 8.解析栈异常信息

## 8.1异常发生时压入栈中的内容

​	发生异常时，硬件会自动压入一部分数据到栈中，如下图所示。根据特权级变化，有两种不同类型的压入方法。本项目讨论无特权变化的压入方法，即图中上半部分。

![image-20250416170738796](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250416170738796.png)

此外，在异常处理函数中，还使用了pusha指令压入了各种寄存器的值，压入的顺序为： `AX, CX, DX, BX, original SP, BP, SI, and DI`，以及通过`push es`等指令压入了其它段寄存器的值。因此，当异常发生后到进入异常处理函数的这个过程中，压入的栈如下：

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1653014165564-a999fdb2-1b74-4e96-ad76-e463d0956b6c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

## 8.2 参数的映射

​	结合boot部分的实现，我们知道从`do_handler_unknown()`看来，压入这些寄存器，相当于是给这个函数传递参数。问题在于压入栈中的寄存器数量太多，如果简单将这些寄存器值全部映射到`do_handler_unknown()`参数中，则函数的参数将非常多。

​	所以这里我们采用一个结构体`exception_frame_t`类型的指针，从而能方便地直接从结构体中读取这些寄存器地值。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1653014227509-82b512aa-675b-4b91-9579-65aae7e69ed7.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

```c
/** 
* 保存异常信息的结构体类型
**/
typedef struct _exception_frame_t
{
    uint32_t gs, fs, es, ds;
    uint32_t edi, esi, ebp, esb, ebx, edx, ecx, eax;
    uint32_t num, error_code;
    uint32_t eip, cs, eflags;
} exception_frame_t;

```

## 9利用宏重用异常处理代码

### 9.1 `as`汇编支持的宏格式

​	如果要定义宏，要使用`.macro`和`.endm`伪指令。其基本示例如下：

```assembly
.macro 宏的名称  参数0 , 参数1
	汇编代码
.endm		
```

​	其中参数是可选的，也给参数一个缺省值，例如：

```assembly
.macro comm   -- 定义一个comm宏，不需要参数
.macro plus1 p, p1 -- 定义一个plus1宏，带参数p和p1
.macro plus1 p p1 -- 定义一个plus1宏，带参数p和p1(即参数可用空格分隔)
.macro reserve_str p1=0 p2 -- 定义一个reserve宏，带p1和p2参数，其中p1的缺省值为0	
```

​	在宏的内部，可以通过`\`参数名的方式去引用参数，如：

```assembly
.macro  sum from=0, to=5
	.long   \from
    .if     \to-\from
    	sum     "(\from+1)",\to
    .endif
.endm
```

```assembly
# code/source/init/start.S
# 相当于c语言中的宏其中 num为中断向量号, with_err_code 为错误码
.macro exception_handler name num with_err_code
    .text
    .extern do_handler_\name
    .global exception_handler_\name

exception_handler_\name:
    .if \with_err_code == 0
        push $0
    .endif
    # 压入中断号
    push $\num

    # 保护现场
    pusha 
    push %ds
    push %es
    push %fs
    push %gs

    push %esp # 相当于给do_handler_unknown 传递参数
    
    call do_handler_\name # 调用特定c处理函数

    # esp出栈
    add $(1*4) , %esp 
    
    # 恢复现场
    pop %gs
    pop %fs
    pop %es
    pop %ds
    popa
    
    add $(2*4) , %esp

    iret
.endm
```



## 10 处理其他类型的异常

### 10.1 异常类型表

![image-20250416191420435](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250416191420435.png)

![image-20250416191444087](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250416191444087.png)

```assembly
# # code/source/init/start.S
exception_handler unknown            , -1    , 0 # 未知异常
exception_handler divider            ,  0    , 0 # 除0异常
exception_handler Debug              ,  0    , 0 # Debug异常
exception_handler NMI                ,  2    , 0 #
exception_handler breakpoint         ,  3    , 0 # 断点异常
exception_handler overflow           ,  4    , 0 # 溢出
exception_handler bound_range        ,  5    , 0 # 越界
exception_handler invalid_opcode     ,  6    , 0 # 无效操作码
exception_handler device_unavailable ,  7    , 0 # 设备不可用
exception_handler double_fault       ,  8    , 1 #
exception_handler invalid_tss        ,  10   , 1 # 无效TSS
exception_handler segment_not_present,  11   , 1 # 段不存在
exception_handler stack_segment_fault,  12   , 1 #
exception_handler general_protection ,  13   , 1 #
exception_handler page_fault         ,  14   , 1 # 页错误
exception_handler fpu_error          ,  16   , 0 # 浮点运算单元
exception_handler alignment_check    ,  17   , 1 # 对齐检查
exception_handler machine_check      ,  18   , 0 #
exception_handler smd_exception      ,  19   , 0 #
exception_handler virtual_exception  ,  20   , 0 #
exception_handler control_exception  ,  21   , 1 #
```

```c
// 安装异常处理函数
    irq_install(IRQ0_DE, (irq_handler_t)exception_handler_divider); // 除0异常
    irq_install(IRQ1_DB, (irq_handler_t)exception_handler_Debug);
    irq_install(IRQ2_NMI, (irq_handler_t)exception_handler_NMI);
    irq_install(IRQ3_BP, (irq_handler_t)exception_handler_breakpoint);
    irq_install(IRQ4_OF, (irq_handler_t)exception_handler_overflow);
    irq_install(IRQ5_BR, (irq_handler_t)exception_handler_bound_range);
    irq_install(IRQ6_UD, (irq_handler_t)exception_handler_invalid_opcode);
    irq_install(IRQ7_NM, (irq_handler_t)exception_handler_device_unavailable);
    irq_install(IRQ8_DF, (irq_handler_t)exception_handler_double_fault);
    irq_install(IRQ10_TS, (irq_handler_t)exception_handler_invalid_tss);
    irq_install(IRQ11_NP, (irq_handler_t)exception_handler_segment_not_present);
    irq_install(IRQ12_SS, (irq_handler_t)exception_handler_stack_segment_fault);
    irq_install(IRQ13_GP, (irq_handler_t)exception_handler_general_protection);
    irq_install(IRQ14_PF, (irq_handler_t)exception_handler_page_fault);
    irq_install(IRQ16_MF, (irq_handler_t)exception_handler_fpu_error);
    irq_install(IRQ17_AC, (irq_handler_t)exception_handler_alignment_check);
    irq_install(IRQ18_MC, (irq_handler_t)exception_handler_machine_check);
    irq_install(IRQ19_XM, (irq_handler_t)exception_handler_smd_exception);
    irq_install(IRQ20_VE, (irq_handler_t)exception_handler_virtual_exception);

```

相关中断处理程序见`kernel/cpu/irq.c`不再赘述

# 11.初始化中断控制

## 11.1 8259功能和结构

​	8259用于管理中断，最大支持对8个中断进行管理。具体来说，外设的中断请求信号连接到`IRQ`，然后再由8259进行处理，最后通过`INT`信号传递给处理器，产生中断请求信号。处理器在接收到`INT`的请求信号后，跳转到对应的中断处理程序中执行。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1653358653696-6c867806-cb98-4c4d-8e3b-46d7c72fa6b7.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

​	硬件部分上，计算机内部已经配置完毕，使用两片8259级联，最多管理15种类型的中断。我们没有办法进行干预，所以只能关注对其相应的寄存器进行配置。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1653358812478-a520f301-a907-4b6d-8f8e-cebd540c0e6e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_34%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_760%2Climit_0)

​	在对寄存器初始化时，需要分配对上述中的`master`和`slave`进行初始化。其中`master`对应端口起始地址为`0x20`，`slave`对应的端口起始地址为`0xA0`。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1653358998807-edc18797-0da5-4f75-bc68-1e25b32c4de6.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

`8259`的工作模式较为复杂，本项目只做了非常简单的配置，不考虑中断嵌套、优先级等问题。具体配置如下：

- 主片：边缘触发，级联、起始中断序号为`0x20`，`IRQ2`上有从片，普通全嵌套、非缓冲、非自动结束、`8086`模式

- 从片：边缘触发，级联、起始中断序号为`0x28`，连接到主片的`IRQ2`上，普通全嵌套、非缓冲、非自动结束、`8086`模式

```c
/**
 * @brief        : 初始化8259芯片,实现定时器中断。
 * @return        {*}
 **/
static void init_pic()
{
    // 第一块8259配置 边缘触发,级联需要配置icw4，8086模式
    outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
    outb(PIC0_ICW2, IRQ_PIC_START); // 起始序号从0x20开始
    outb(PIC0_ICW3, 1 << 2); // 主片PIC0_ICW3 有从片
    outb(PIC0_ICW4, PIC_ICW4_8086); // 普通全嵌套、非缓冲、自动结束8086模式

    // 第二块8259配置
    outb(PIC1_ICW1, PIC_ICW1_ICW4 | PIC_ICW1_ALWAYS_1);
    outb(PIC1_ICW2, IRQ_PIC_START + 8); // 从0x28开始
    outb(PIC1_ICW3, 2); // 没有从片，连接到主片的IRQ2上
    outb(PIC1_ICW4, PIC_ICW4_8086); // 普通全嵌套、非缓冲、非自动结束、8086模式

    // // 禁止所有中断, 允许从PIC1传来的中断
    outb(PIC0_IMR, 0xFF & ~(1 << 2));
    outb(PIC1_IMR, 0xFF);
}
```

# 12.中断的打开与关闭

中断控制受两部分控制，首先是`8259`中断控制器控制着外设的中断信号是否允许到达`CPU`,这项功能由其内部寄存器IMR控制，该控制器为`8`位，其中第`0`位控制该芯片的`IRQ0`,第一位控制`IRQ1`，以此类推。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1653360541980-0f6d3882-03f0-408b-8a5b-2987c072e02a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

​	另外，cpu内部的EFLAGS标志寄存器中的IF位控制CPU是否响应着任意来自8259的中断信号，如果为1，则允许，否则禁止。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1653360567298-285c15c4-41d2-4954-aecf-5e197fafbe7f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

# 13.启动定时器并打开中断

## 13.18253整体结构

​	`8253`是一颗带有3个内部计数器的定时器的芯片，用于为计算机提供相关的定时和计数功能。其中，我们主要关心定时器/计数器0，因其余两个一般用于其它用途。
​	定时器0可单独计数，其输入的时钟频率为`1.193182 MHz`。在每个时钟节拍的作用下，进行递减计数。当减至0时，通过`8259`的`IRQ0`向`CPU`发出中断请求，`CPU`将进入中断服务程序运行。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1653364244475-bf56db05-0ee9-4741-a4a8-606af09eae8a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

​	为实现对8253进行配置，可以通过如下端口进行设置。

```
端口地址         名称
0x40			定时器0数据端口
0x41			定时器1数据端口
0x42			定时器2数据端口
0x43			模式和命令端口
```

```c
/**
 * @brief        : 开启特定中断
 * @param         {int} irq_num: 特定中断号
 * @return        {*}
 **/
void irq_enable(int irq_num)
{
    if (irq_num < IRQ_PIC_START)
    {
        return;
    }
    irq_num -= IRQ_PIC_START;
    if (irq_num < 8)
    {
        // 第一块8259中的中断
        uint8_t mask = inb(PIC0_IMR) & ~(1 << irq_num);
        outb(PIC0_IMR, mask);
    }
    else
    {
        // 第二块8259的中断
        irq_num -= 8;
        uint8_t mask = inb(PIC1_IMR )& ~(1 << irq_num);
        outb(PIC1_IMR, mask);
    }
}

/**
 * @brief        : 关闭特定中断
 * @param         {int} irq_num: 特定中断号
 * @return        {*}
 **/
void irq_disable(int irq_num)
{
    if (irq_num < IRQ_PIC_START)
    {
        return;
    }
    irq_num -= IRQ_PIC_START;
    if (irq_num < 8)
    {
        // 第一块8259中的中断
        uint8_t mask = inb(PIC0_IMR) | (1 << irq_num);
        outb(PIC0_IMR, mask);
    }
    else
    {
        // 第二块8259的中断
        irq_num -= 8;
        uint8_t mask = inb(PIC1_IMR) | (1 << irq_num);
        outb(PIC1_IMR, mask);
    }
}

/**
 * @brief        : 全局中断关闭eflags置0
 * @return        {*}
 **/
void irq_disable_global(void)
{
    cli();
}

/**
 * @brief        : 全局中断开启eflags置1
 * @return        {*}
 **/
void irq_enable_global(void)
{
    sti();
}

```



## 11.2定时器0的配置

我们只需要一个可以周期性产生中断的定时器，无需考虑各种硬件方面的东西。因此，只需要将定时器设置成自动周期性触发中断即可，而模式3可以方便的实现此功能，因此选用的模式3。
其它模式较为复杂，有的需要和硬件配合，有的需要在中断中重新配置定时器，所以没有使用这些模式。

```c
static uint32_t sys_tick;

/**
 * @brief        : 定时器中断处理函数
 * @param         {exception_frame_t} *frame: 异常信息
 * @return        {*}
**/
void do_handler_timer(exception_frame_t *frame)
{
    sys_tick++;

    pic_send_eoi(IRQ0_TIMER);
}

/**
 * @brief        :
 * @return        {*}
 **/
static void init_pit()
{
    uint32_t reload_count = PIT_OSC_FREQ / (1000.0 * OS_TICKS_MS);

    outb(PIT_COMMAND_MODE_PORT, PIT_CHANNEL0 | PIT_LOAD_LOHI | PIT_MODE3);

    outb(PIT_CHANNEL0_DATA_PORT, reload_count & 0xFF); // 加载低8位

    outb(PIT_CHANNEL0_DATA_PORT, (reload_count >> 8) & 0xFF); // 加载高8位

    irq_install(IRQ0_TIMER, (irq_handler_t)exception_handler_timer);
    irq_enable(IRQ0_TIMER);
}

/**
 * @brief        : 定时器初始化函数
 * @return        {*}
 **/
void time_init(void)
{
    sys_tick = 0;
    init_pit();
}
```


# 1.创建调用门

​	当前应用进程工作在特权级3的模式下时，`CPU`将禁止其直接访问需要高特权级权限才能访问的操作系统代码和数据；否则，将产生异常。那么应用进程需要调用`OS`的一些功能(延时、)该如何实现呢？

![image-20250630193349991](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250630193349991.png)

​	由于采用了平坦模型，所以需要进一步借助分页机制的`U/S`位实现保护

![image-20250630193628179](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250630193628179.png)

​	切换特权级的几种方法：

- 调用门：用于系统调用
- 任务门：用于任务切换
- 中断门：用于中断和异常
- 陷进门：用于中断和异常

我们的实现：

- 特权级0-->特权级3(往栈中压入数据，然后iret，实现特权级切换)
- 特权级3-->特权级0(中断和异常触发时，通过IDT表中设置了相关特权级)

![image-20250630193938689](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250630193938689.png)

​	应用程序可通过调用门接口，实现在低特权级的情况下对操作系统提供的接口函数进行调用。

![image-20250630195920351](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250630195920351.png)

​	调用门描述符：

![image-20250630200406055](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250630200406055.png)

​	调用门工作流程：

![image-20250630200653048](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250630200653048.png)

​	权限检查：
![image-20250630201037010](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250630201037010.png)

​	我们只设置一个调用门描述符，通过这一个接口访问操作系统的所有接口。

在GDT表中添加调用门描述符。在`init_gdt()`函数中添加对调用门描述符的设置，具体如下：

```c
gate_desc_set((gate_desc_t *)(gdt_table + (SELECTOR_SYSCALL >> 3)), // gdt表
                  KERNEL_SELECTOR_CS,                                 // 段
                  (uint32_t)exception_handler_syscall,
                  GATE_P_PRESENT | GATE_DPL3 | GATE_TYPE_SYSCALL | SYSCALL_PARAM_COUNT // 系统调用门：DPL=3，用户态可以调用
    );
```

​	声明`exception_handler_syscall`函数，同时在`init.S`汇编文件中 添加实现：

```assembly
    .global exception_handler_syscall
exception_handler_syscall:
	ret
```

# 2.实现系统调用的调用和返回

## 2.1 创建函数口用于调用系统调用

在`applib\libsyscall.h`中添加

```c
/**
 * @brief        : 延时系统调用
 * @param         {int} ms: 睡眠的毫秒数
 * @return        {void}
 **/
static inline void msleep(int ms)
{
    if (ms < 0) // 小于0不需要延时
    {
        return;
    }
    syscall_args_t args;
    args.id = SYS_sleep; // 设置调用id
    args.arg0 = ms;      // 设置延时时长
    sys_call(&args);     // 通用系统调用接口,并传递参数
}
```

​	定义`syscall_args_t`用于传递参数。

```
typedef struct _syscall_args_t
{
    int id;   // 根据id确定调用函数
    int arg0; // 参数1
    int arg1; // 参数2
    int arg2; // 参数3
    int arg3; // 参数4
} syscall_args_t;
```



```c
/**
 * @brief        : 通用系统调用接口
 * @param         {syscall_args_t} *args: 传递给系统调用的参数
 * @return        {int} : 系统调用的返回值
 **/
static inline int sys_call(syscall_args_t *args)
{
    int ret;
    uint32_t addr[] = {0, SELECTOR_SYSCALL | 0}; // RPL<=DPL ,RPL设置为0
    __asm__ __volatile__(
        "push %[arg3]\n\t"
        "push %[arg2]\n\t"
        "push %[arg1]\n\t"
        "push %[arg0]\n\t"
        "push %[id]\n\t"
        "lcalll *(%[a])"
        : "=a"(ret)
        : [arg3] "r"(args->arg3),
          [arg2] "r"(args->arg2),
          [arg1] "r"(args->arg1),
          [arg0] "r"(args->arg0),
          [id] "r"(args->id),
          [a] "r"(addr)); // 跳转到exception_handler_syscall
    return ret;
}
```

```assembly
    .global exception_handler_syscall
exception_handler_syscall:
	ret
```

> 系统调用的参数的传递过程：
>
> `"push %[arg3]\n\t"
>  "push %[arg2]\n\t"
>  "push %[arg1]\n\t"
>  "push %[arg0]\n\t"
>  "push %[id]\n\t"`
>
> 这里我们手动将这五个参数压入栈中，当执行到`lcalll`指令时，硬件会自动将参数从用户栈拷贝到内核栈中。
>
> ![image-20250701202633574](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250701202633574.png)
>
> 同时返回时，我们需要使用`retf`，才会涉及到特权级的切换。最后，我们手动压入了五个参数，所以要跳过那5个参数。`retf $(5 * 4)`

# 3.实现`msleep`

![image-20250701203303394](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250701203303394.png)

​	在系统调用内部，使用系统调用表来保存所有系统调用处理函数的入口地址。当发生系统调用时，通过查表来获取跳转点。

​	手动将一些寄存器的值压入栈中，

```assembly
exception_handler_syscall:
    pusha 
    push %ds
    push %es
    push %fs
    push %gs
    pushf # eflags寄存器压栈

    mov %esp , %eax
    push %eax # 实际为传递参数
    call do_handler_syscall
    add $4 , %esp

    popf
    pop %gs
    pop %fs
    pop %es
    pop %ds
    popa
    retf $(5 * 4)
```



> 压栈过程详细解释：
>
> ```
> 内核栈
> +------------------+
> | 用户SS           |
> +------------------+
> | 用户ESP          |
> +------------------+
> | arg3             |
> +------------------+
> | arg2             |
> +------------------+
> | arg1             |
> +------------------+
> | arg0             |
> +------------------+
> | id               |
> +------------------+
> | 用户CS           |
> +------------------+
> | 用户EIP          |
> +------------------+
> | EDI              | ← pusha压入
> +------------------+
> | ESI              | ← pusha压入
> +------------------+
> | EBP              | ← pusha压入
> +------------------+
> | ESP(old)         | ← pusha压入
> +------------------+
> | EBX              | ← pusha压入
> +------------------+
> | EDX              | ← pusha压入
> +------------------+
> | ECX              | ← pusha压入
> +------------------+
> | EAX              | ← pusha压入
> +------------------+
> | DS               | ← push %ds
> +------------------+
> | ES               | ← push %es
> +------------------+
> | FS               | ← push %fs
> +------------------+
> | GS               | ← push %gs
> +------------------+
> | EFLAGS           | ← pushf
> +------------------+ ← ESP现在指向这里
> ```

```c
typedef struct _syscall_frame_t
{
    uint32_t eflags;

    uint32_t gs, fs, es, ds;
    uint32_t edi, esi, ebp, dummy, ebx, edx, ecx, eax;
    uint32_t eip, cs;
    int func_id, arg0, arg1, arg2, arg3;
} syscall_frame_t;
```

> 1. **`mov %esp, %eax`**：
>    - ESP指向完整栈帧的顶部
>    - 将这个地址值复制到EAX寄存器
> 2. **`push %eax`**：
>    - 将栈帧地址作为参数压入栈
>    - 这相当于C函数调用的第一个参数
> 3. **`call do_handler_syscall`**：
>    - 调用C函数，传入栈帧指针
>    - C函数原型：`void do_handler_syscall(syscall_frame_t *frame)`
> 4. **`add $4, %esp`**：
>    - C函数返回后，手动清理栈上的参数
>    - 1个指针参数 = 4字节

系统调用表：

```c
static const sys_handler_t sys_table[] = {
    [SYS_sleep] = (sys_handler_t)sys_sleep,
    [SYS_getpid] = (sys_handler_t)sys_getpid,
    [SYS_print_msg] = (sys_handler_t)sys_print_msg,

};
```

`do_handler_syscall`的实现：

```c
typedef int (*sys_handler_t)(uint32_t arg0, uint32_t arg1, uint32_t arg2, uint32_t arg3);
/**
 * @brief        : 通用系统调用处理函数
 * @param         {syscall_frame_t *} frame: 寄存器信息
 * @return        {void}
 **/
void do_handler_syscall(syscall_frame_t *frame)
{
    if (frame->func_id < sizeof(sys_table) / sizeof(sys_table[0])) // 系统调用号合法
    {
        sys_handler_t handler = sys_table[frame->func_id]; // 系统调用对应的函数

        if (handler)
        {
            int ret = handler(frame->arg0, frame->arg1, frame->arg2, frame->arg3); // 调用该函数
            frame->eax = ret; // 返回值
            return;
        }
    }
    task_t *task = task_current();
    log_printf("task %s, Unknown syscall : %d", task->name, frame->func_id);
    frame->eax = -1; // 出错
}
```

# 4.`getpid()`系统调用

​	与前述类似，但与之不同的是这里需要处理返回值， 在C语言中，函数的返回值会被存储在`eax`寄存器之中。故只需将`eax`的值设置为返回值即可。

```c
 __asm__ __volatile__(
        "push %[arg3]\n\t"
        "push %[arg2]\n\t"
        "push %[arg1]\n\t"
        "push %[arg0]\n\t"
        "push %[id]\n\t"
        "lcalll *(%[a])"
        : "=a"(ret) // 表明从eax寄存器中取出其值
        : [arg3] "r"(args->arg3),
          [arg2] "r"(args->arg2),
          [arg1] "r"(args->arg1),
          [arg0] "r"(args->arg0),
          [id] "r"(args->id),
          [a] "r"(addr)); 
```

```c
/**
 * @brief        : 通用系统调用处理函数
 * @param         {syscall_frame_t *} frame: 寄存器信息
 * @return        {void}
 **/
void do_handler_syscall(syscall_frame_t *frame)
{
    if (frame->func_id < sizeof(sys_table) / sizeof(sys_table[0])) // 系统调用号合法
    {
        sys_handler_t handler = sys_table[frame->func_id]; // 系统调用对应的函数

        if (handler)
        {
            int ret = handler(frame->arg0, frame->arg1, frame->arg2, frame->arg3); // 调用该函数
            frame->eax = ret; // 返回值
            return;
        }
    }
    task_t *task = task_current();
    log_printf("task %s, Unknown syscall : %d", task->name, frame->func_id);
    frame->eax = -1; // 出错
}
```

```assembly
exception_handler_syscall:
    pusha 
    push %ds
    push %es
    push %fs
    push %gs
    pushf # eflags寄存器压栈

    mov %esp , %eax # 将当前栈指针ESP的值复制到EAX
    push %eax # 将EAX(即栈指针)作为参数压入栈
    call do_handler_syscall
    add $4 , %esp # 清理参数(1个指针=4字节)

    popf
    pop %gs
    pop %fs
    pop %es
    pop %ds
    popa
    retf $(5 * 4)
```



> 这里`frame->eax = ret`会将原来存储的`eax`值的内存区域改为`ret`，然后出栈指令，最后`popa`会把修改后的值即`ret`弹出到`eax`寄存器，实现正确返回函数返回值

# 5.`print_msg`系统调用的实现

​	较为简单，不在赘述。

# 6.利用中断的方式（`int $0x80`）实现系统调用

​	具体修改`irq_init()`中添加对该中断门的设置，

```c
gate_desc_set(idt_table + 0x80, KERNEL_SELECTOR_CS, (uint32_t)exception_handler_syscall, GATE_P_PRESENT | GATE_DPL3 | GATE_TYPE_IDT);
```

​	处理函数为`exception_handler_syscall`同时修改权限为`GATE_DPL3`

​	添加该中断处理函数的声明：

`# exception_handler syscall       ,  0x80 , 0 # 系统调用`

修改通用系统调用接口

```c
/**
 * @brief        : 通用系统调用接口
 * @param         {syscall_args_t} *args: 传递给系统调用的参数
 * @return        {int} : 系统调用的返回值
 **/
static inline int sys_call(syscall_args_t *args)
{
    int ret;
    /*int 80的实现方式*/
        __asm__ __volatile__(
        "int $0x80"
        : "=a"(ret)
        : "S"(args->arg3),
          "d"(args->arg2),
          "c"(args->arg1),
          "b"(args->arg0),
          "a"(args->id));
    return ret;
}
```

以及系统调用中断处理函数：

```c
void do_handler_syscall(exception_frame_t *frame)
{
    int func_id = frame->eax;
    int arg0 = frame->ebx;
    int arg1 = frame->ecx;
    int arg2 = frame->edx;
    int arg3 = frame->esi;

    if (func_id < sizeof(sys_table) / sizeof(sys_table[0]))
    {
        sys_handler_t handler = sys_table[func_id];

        if (handler)
        {
            int ret = handler(arg0, arg1, arg2, arg3);
            frame->eax = ret;
            return;
        }
    }
    task_t *task = task_current();
    log_printf("task %s, Unknown syscall : %d", task->name, func_id);
    frame->eax = -1;
}
```


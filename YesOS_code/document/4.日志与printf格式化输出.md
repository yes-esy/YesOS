# 1.创建日志输出接口

```c
// code/source/kernel/include/tools/log.h
void log_init(void); // 日志输出初始化函数
void log_printf(const char * fmt,...);  //日志输出接口
```

```c
// source\kernel\tools\log.c
/**
 * @brief        : 日志输出初始化函数，对相应寄存器进行设置
 * @return        {*}
 **/
void log_init(void)
{

}
/**
 * @brief        : 实现打印的功能(类似printf)
 * @param         {char} *fmt: 格式化字符串
 * @return        {*}
**/
void log_printf(const char *fmt, ...)
{
    
}

```

# 2.实现基本的信息输出

## 2.1RS232串行接口

​	RS232是一种早期PC机提供的串行通信接口，其通过两根信号线：发送信号、接收信号，便能实现与外部的数据输入输出通信。现代的计算机已经不提供这种通信接口了，但是qemu有实现对这种接口的模拟，所以我们仍然可以使用。

![image-20250421213807396](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250421213807396.png)

​	本项目使用RS232串行接口作为临时调试使用，一边将操作系统的运行过程中的信息，能够输出到某个地方，便于及时查看。

## 2.2 换行与回车

`\r` 与 `\n`

- `\r` 将光标移动到下一行，列号不变
- `\n`将光标移动到本行开头。

​	不过，不同的显示终端对于`\n`的解释不同。在`windows`中编程时，使用`printf`输出，其会将`\n`自动转换成`\r\n`，所以我们会发现`printf("abcd\nefg")`即能实现显示完`abcd`后，进入到下一行开头再显示`efg`。而在qemu窗口中，需要使用`\r\n`才能实现类似的效果。



如果在`qemu`中没有看到`serial0`的菜单项（如上所示），可能是`qemu`的启动脚本配置问题。
在工程中找到`qemu-debug-win.bat`文件，找到如下配置项，删除项中的`-serial stdio`即可。

```bash
qemu-system-i386  -m 128M -s -S -serial stdio -drive file=disk1.dmg,index=0,media=disk,format=raw -drive file=disk2.dmg,index=2,media=disk,format=raw -d pcall,page,mmu,cpu_reset,guest_errors,page,trace:ps2_keyboard_set_translation
```

另外，在`Ubuntu`环境下，由于系统和`QEMU`的配置，不支持`-serial stdio`选项。因此无法在`VSCode`中查看输出，而只能在`QEMU`的Serial窗口中查看串口的输出。

具体实现：

```c
void log_init(void)
{
    outb(COM1_PORT + 1, 0x00); // 中断相关
    outb(COM1_PORT + 3, 0x80); // 发送速度
    outb(COM1_PORT + 0, 0x3);
    outb(COM1_PORT + 1, 0x00);
    outb(COM1_PORT + 3, 0x03);
    outb(COM1_PORT + 2, 0xC7);
    outb(COM1_PORT + 4, 0x0F);
}
```

```c
void log_printf(const char *fmt, ...)
{
    char str_buf[128];
    va_list args;                                  // 可变参数存储变量
    kernel_memset(str_buf, '\0', sizeof(str_buf)); // 清空缓冲区
    va_start(args, fmt);                           // 将fmt后的可变参数存储到args中
    kernel_vsprintf(str_buf, fmt, args);           // 将可变参数放入缓冲区
    va_end(args);
    const char *p = str_buf;
    while (*p != '\0')
    {
        while ((inb(COM1_PORT + 5) & (1 << 6)) == 0) // 正在忙则等待
            ;
        outb(COM1_PORT, *p++); // 发送数据
    }
    outb(COM1_PORT, '\r');
    outb(COM1_PORT, '\n');
}

```

# 3.若干字符串和内存操作函数实现

## 3.1为何不使用标准c库中的函数

> 标准`C`库依赖于特定的操作系统平台，所以其很多代码需要在特定的操作系统才能运行。但我们现在是在开发自己的`OS`，是更底层的代码，自然不能使用`C`库的函数。
>
> 同时可能c库中有一些函数并不依赖`OS`，但这只是`C`库中的一部分，还有其他部分，我们要使用一些特定的函数必须将整个C库链接进来，这就导致需要整个C库.

## 3.2 具体实现如下：

```c
/**
 * @FilePath     : /code/source/kernel/tools/klib.c
 * @Description  :  工具库函数实现文件
 * @Author       : ys 2900226123@qq.com
 * @Version      : 0.0.1
 * @LastEditors  : ys 2900226123@qq.com
 * @LastEditTime : 2025-04-21 21:14:35
 * @Copyright    : G AUTOMOBILE RESEARCH INSTITUTE CO.,LTD Copyright (c) 2025.
 **/
 
 
/**
 * @brief        : 字符串复制函数
 * @param         {char *} dest:目的地址
 * @param         {char *} src:源字符串地址
 * @return        {*}
 **/
void kernel_strcpy(char *dest, const char *src)
{
    if (!dest || !src)
    {
        return;
    }
    while (*dest && *src)
    {
        *dest = *src;
    }
    *dest = '\0';
}
/**
 * @brief        : 指定大小字符串复制
 * @param         {char *} dest:目的地址
 * @param         {char *} src:源字符串地址
 * @param         {int} size:大小
 * @return        {*}
 **/
void kernel_strncpy(char *dest, const char *src, int size)
{
    if (!dest || !src || !size)
    {
        return;
    }

    char *d = dest;
    const char *s = src;

    while ((size-- > 0) && (*s))
    {
        *d++ = *s++;
    }

    if (size == 0)
    {

        *(d - 1) = '\0';
    }
    else
    {
        *d = '\0';
    }
}

/**
 * @brief        : 字符串比较函数
 * @param         {char *} s1: 字符串1
 * @param         {char *} s2: 字符串2
 * @param         {int} size: 需要比较的字符串长度
 * @return        {*}相等返回0 ,否则返回-1
 **/
int kernel_strncmp(const char *s1, const char *s2, int size)
{
    if (!s1 || !s2)
    {
        return -1;
    }
    while (*s1 && *s2 && (*s1 == *s2) && size--)
    {
        s1++;
        s2++;
    }
    return !((*s1 == '\0') || (*s2 == '\0') || (*s1 == *s2));
}

/**
 * @brief        : 字符串的长度
 * @param         {char *} str: 字符串
 * @return        {*} 字符串的长度
 **/
int kernel_strlen(const char *str)
{
    if (!str)
    {
        return 0;
    }
    const char *c = str;
    int len = 0;
    while (*c++)
    {
        len++;
    }
    return len;
}

/**
 * @brief        : 内存复制函数
 * @param         {void *} dest: 目的地址
 * @param         {void *} src: 源地址
 * @param         {int} size: 需要复制的字节大小
 * @return        {*}
 **/
void kernel_memcpy(void *dest, void *src, int size)
{
    if (!dest || !src || !size)
    {
        return;
    }

    uint8_t *s = (uint8_t *)src;
    uint8_t *d = (uint8_t *)dest;
    while (size--)
    {
        *d++ = *s++;
    }
}
/**
 * @brief        : 内存设置函数
 * @param         {void *} dest: 目的地址
 * @param         {uint8_t} v: 设置成的数据
 * @param         {int} size: 字节大小
 * @return        {*}
 **/
void kernel_memset(void *dest, uint8_t v, int size)
{
    if (!dest || !size)
    {
        return;
    }
    uint8_t *d = dest;
    while (size--)
    {
        *d++ = v;
    }
}
/**
 * @brief        : 内存比较函数
 * @param         {void *} d1:数据d1的地址
 * @param         {void *} d2:数据d2的地址
 * @param         {int} size: 比较的字节大小
 * @return        {*}d1=d2返回0，相等返回非0;
 **/
int kernel_memcmp(void *d1, void *d2, int size)
{
    if (!d1 || !d2 || !size)
    {
        return 1;
    }
    uint8_t *p_d1 = d1;
    uint8_t *p_d2 = d2;
    while (size--)
    {
        if (*p_d1++ != *p_d2++)
        {
            return 1;
        }
    }
    return 0;
}

```

## 3.3 实现字符串的格式化输出

### 3.3.1 可变参数的使用

​	在c语言中，支持一个函数参数数量没有固定限制，典型的代表就是`printf`

​	在定义这种类型的函数时，使用：函数名（参数1, 参数2, ...)的形式，即在最后有名称的参数后面增加一个...的参数。

​	在函数内部，可以通过一定的方式取出这些没有名称的参数。流程依次为：

- 定义`va_list`类型的变量，如`ap`，用于存放取可变参数的一些信息
- 使用`va_start(ap, 最后一个有名字的参数-参数2)`：初始化`ap`
- 依次使用`va_arg(ap, type)`获取传入的可变部分的参数
- 使用`va_end(ap)`结束可变参数的取参，释放相应的资源

以下述为例，展示C语言中如何使用可变参数：

```c
/* va_arg example */
\#include <stdio.h>      /* printf */
\#include <stdarg.h>     /* va_list, va_start, va_arg, va_end */

int FindMax (int n, ...)
{
  int i,val,largest;
  va_list vl;
  va_start(vl,n);
  largest=va_arg(vl,int);
  for (i=1;i<n;i++)
  {
    val=va_arg(vl,int);
    largest=(largest>val)?largest:val;
  }
  va_end(vl);
  return largest;
}

int main ()
{
  int m;
  m= FindMax (7,702,422,631,834,892,104,772);
  printf ("The largest value is: %d\n",m);
  return 0;
}
```

### 3.3.2 可变参数的处理分析

​	前面我们已经分析过GCC对于函数调用时，参数传递是通过栈传递的，并且是先压最右边的参数，再压最左边的参数，即如下图所示，其对应的函数可能为`func(int b, int a)`.

​	而对于一个具备可变参数的函数而言，例如`func_arg(int a,....)`在进行`func_arg(a,b)`调用时，其栈实际上是和下图完全相同的。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/12764787/1651898430771-ff7a5f6e-8a33-4c29-8901-fe8b10b461df.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_5p2O6L-w6ZOc%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

当有更多参数时，如`func_arg(a, b, c, d, e)`，则栈中压入的参数从上（高地址）到下（低地址）依次为`e, d, c, b , a`。在函数内部，只有`func_arg(int a, ....)`中的a参数有名字可以引用，而要获取其它参数，则需要借助`a`找到对应的栈位置，然后再在栈中依次往上（高地址）逐个去取出相应的参数。因此，在获得参数时：

- 首先，使用`va_list`定义一个变量，如`args`，这个变量会被`va_start()`初始化。猜测，在`va_start()`内部，可能维护了一个指针，指向了栈中参数所在的位置。例如，在调用时`va_start(args, a)`，会将`args`指向了参数a的后一个参数（更高地址）。

- 然后，要获取这个参数，通过`va_arg(args, type)`实现。其会将当前`args`指向的栈单元中的值取出来。取出来后转换成什么类型，则由`type`指定（内部可能做了强制类型转换）。
- 取完之后，`args`内部的指针再继续往一个参数移动。

如此，通过反复地调用`va_arg(args, type)`，`args`内部的指针在栈中不断地移动，就实现了遍历栈中所有参数，然后将参数依次取出来。

### 3.3.3 kernel_vsprintf分析

​	`kernel_vsprintf`内部定义一个简单的状态机对字符串进行格式化，具体为：

- `NORMAL`：表示正在对普通的需要直接显示的字符进行处理，处理方式为直接写入字符串缓存中
- `READ_FMT`：表示正在进行参数的转换处理，例如遇到了`%s`，正在从可变参数列表中取出字符串写入字符串缓存中。

​	具体实现如下：

```c

/**
 * @brief        : 根据格式化字符串将args参数填入buf中
 * @param         {char} *buf: 输出缓冲区
 * @param         {char} *fmt: 格式化字符串
 * @param         {va_list} args: 参数
 * @return        {*}
 **/
void kernel_vsprintf(char *buffer, const char *fmt, va_list args)
{
    enum
    {
        NORMAL,
        READ_FMT
    } state = NORMAL;
    char ch;
    char *curr = buffer;
    while ((ch = *fmt++))
    {
        switch (state)
        {
        // 普通字符
        case NORMAL:
            if (ch == '%')
            {
                state = READ_FMT;
            }
            else
            {
                *curr++ = ch;
            }
            break;
        // 格式化控制字符，只支持部分
        case READ_FMT:
            if (ch == 'd')
            {
                int num = va_arg(args, int);
                kernel_itoa(curr, num, 10);
                curr += kernel_strlen(curr);
            }
            else if (ch == 'x')
            {
                int num = va_arg(args, int);
                kernel_itoa(curr, num, 16);
                curr += kernel_strlen(curr);
            }
            else if (ch == 'c')
            {
                char c = va_arg(args, int);
                *curr++ = c;
            }
            else if (ch == 's')
            {
                const char *str = va_arg(args, char *);
                int len = kernel_strlen(str);
                while (len--)
                {
                    *curr++ = *str++;
                }
            }
            state = NORMAL;
            break;
        }
    }
}
```


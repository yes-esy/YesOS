# 1.初始化命令行解释器

`Shell`俗称壳，即命令行解释器，它允许用户交互式的输入命令并解释执行，并且可以调用出相应的应用程序运行，从而让有户 能够使用内核的功能去操作计算机。

![image-20250709132939739](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250709132939739.png)	

常见的非图形界面的`shell`

![image-20250709133055924](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250709133055924.png)

`shell`也是一门程序语言，其定义了相应的语法规则，允许用户编写脚本。脚本编写后，由`shell`解释执行，不需要编译生成可执行程序。

我们的目标是提供一个命令行的shell，支持执行内置的命令以及加载磁盘上的程序运行。

![image-20250709133141178](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250709133141178.png)

![image-20250708155946413](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250708155946413.png)

​	定义`cli_cmd_t`来描述一条命令，`cli_t`来描述

```c
/**
 * 一条命令的结构
 */
typedef struct _cli_cmd_t
{
    const char *name;                      // 命令名
    const char *usage;                     // 命令帮助
    int (*do_func)(int argc, char **argv); // 命令功能
} cli_cmd_t;

/**
 * 命令表
 */
typedef struct _cli_t
{
    const cli_cmd_t *cmd_start;      // 命令起始
    const cli_cmd_t *cmd_end;        // 命令结束
    const char *promot;              // 命令提示符
    char curr_input[CLI_INPUT_SIZE]; // 命令行输入缓冲区
} cli_t;
/**
 * 命令表
 */
static const cli_cmd_t cmd_list[] = {
    {
        .name = "help",
        .usage = "help --list supported command",
        .do_func = do_help,
    },
    {
        .name = "clear",
        .usage = "clear -- clear screen",
        .do_func = do_clear,
    },
    {
        .name = "echo",
        .usage = "echo [-n count] message -- echo some message",
        .do_func = do_echo,
    },
    {
        .name = "exit",
        .usage = "exit from current task",
        .do_func = do_exit,
    },
};
```

​	初始化命令表`cli_init`

```c
/**
 * @brief        : 命令行程序初始化
 * @param         {char *} promot: 提示符
 * @param         {cli_cmd_t *} cmd_list: 命令表
 * @param         {int} size: 大小
 * @return        {void}
 **/
static void cli_init(const char *promot, const cli_cmd_t *cmd_list, int size)
{
    cli.promot = promot;
    memset((void *)cli.curr_input, 0, CLI_INPUT_SIZE);
    cli.cmd_start = cmd_list;
    cli.cmd_end = cmd_list + size;
}
```

​	显示提示符`show_promot`：

```c
/**
 * @brief        : 打印提示符
 * @return        {*}
 **/
static void show_promot(void)
{
    printf("%s", promot);
    fflush(stdout); // 清空缓存
}
```

> `fflush(stdout); // 清空缓存`这里需要刷新是因为newlib只有遇到`\n`才会输出，`fflush`起到强制刷新，及时输出的效果

# 2.实现`help`命令的解析

```c
int main(int argc, char **argv)
{

    open(argv[0], 0); // int fd = 0 , stdin
    dup(0);           // 标准输出
    dup(0);           // 标准错误输出
    printf(ESC_CLEAR_SCREEN ESC_MOVE_CURSOR(0, 0));
    printf(ESC_COLOR_SUCCESS ESC_COLOR_BOLD "Launched successfully, Welcome to YOS!\n" ESC_COLOR_RESET);
    printf(ESC_COLOR_INFO "Build date: %s\n" ESC_COLOR_DEFAULT, __DATE__);
    cli_init(promot, cmd_list, sizeof(cmd_list) / sizeof(cmd_list[0])); // 命令行解释器初始化
    printf(ESC_COLOR_WARNING "Shell %c is running.\n" ESC_COLOR_DEFAULT, (argv[0][4] + 1));
    printf(ESC_COLOR_HELP "Type 'help' for available commands.\n" ESC_COLOR_DEFAULT);
    while (1)
    {
        show_promot();
        char *input_str = fgets(cli.curr_input, CLI_INPUT_SIZE, stdin);
        if (input_str == (char *)0)
        {
            printf("%s\n", input_str);
            continue;
        }
        char *cr = strchr(cli.curr_input, '\n'); // 找到'\n'字符
        if (cr)                                  // 替换成'\0'
        {
            *cr = '\0';
        }
        cr = strchr(cli.curr_input, '\r'); // 找到'\r'字符
        if (cr)                            // 替换成'\0'
        {
            *cr = '\0';
        }
        int argc = 0;
        char *argv[CLI_MAX_ARG_COUNT];
        const char *space = " ";
        char *token = strtok(cli.curr_input, space); // 将字符串分割成多个字符串
        while (token)
        {
            if (argc >= CLI_MAX_ARG_COUNT) // 不超过最大参数数量
            {
                break;
            }
            argv[argc++] = token;
            token = strtok(NULL, space); // 下一个字符串
        }
        if (argc == 0) // 没有任何输入
        {
            continue;
        }
        const cli_cmd_t *cmd = find_builtin(argv[0]); // 查找内部命令
        if (cmd)
        {
            run_builtin(cmd, argc, argv);
            continue;
        }


    }
    return 0;
}

```

> `fgets`获取输入的字符串，通过两次`strchr`转为干净的字符串通过`strtok`分割，用`argc`记录参数个数`argv`记录参数。

​	`find_buildin()`查找内部命令。

```c
/**
 * @brief        : 查找内置的cmd命令
 * @param         {char} *name: 命令名称
 * @return        {cli_cmd_t *}: 返回找到的命令
 **/
static const cli_cmd_t *find_builtin(const char *name)
{
    for (const cli_cmd_t *cmd = cli.cmd_start; cmd < cli.cmd_end; cmd++) // 查找相关命令
    {
        if (strcmp(cmd->name, name) != 0) // 不是该命令,跳过
        {
            continue;
        }
        return cmd; // 找到了
    }
    return (cli_cmd_t *)0;
}
```

​	`run_buildin`执行内部命令

```c
/**
 * @brief        : 执行内置cmd命令
 * @param         {cli_cmd_t} *cmd: 执行的命令的指针
 * @param         {int} argc: 指明argv中参数的个数
 * @param         {char} *: 传递的参数
 * @return        {*}
 **/
static void run_builtin(const cli_cmd_t *cmd, int argc, char **argv)
{
    int ret = cmd->do_func(argc, argv); // 执行该命令
    if (ret < 0)                        // 执行错误打印错误码
    {
        fprintf(stderr, ESC_COLOR_ERROR "Unknown error: %s\n" ESC_COLOR_DEFAULT, cli.curr_input);
    }
}
```

> 调用命令对应的函数指针即可

​	`help`命令的实现

```c
/**
 * @brief        : help命令
 * @param         {int} argc: argv中的参数个数
 * @param         {char} *: 参数
 * @return        {int} : 执行成功返回0,失败返回-1
 **/
static int do_help(int argc, char **argv)
{
    printf(ESC_COLOR_HELP ESC_COLOR_BOLD "Available Commands:\n" ESC_COLOR_RESET);
    printf(ESC_COLOR_HELP "==================\n" ESC_COLOR_DEFAULT);
    const cli_cmd_t *start = cli.cmd_start;
    while (start < cli.cmd_end)
    {
        printf("%s %s\n", start->name, start->usage);
        start++;
    }
    return 0;
}
```

​	较为简单不过多赘述

# 2.`clear`清屏命令与输出颜色的调整的实现

```c
#define ESC_CMD2(Pn, cmd) "\x1b[" #Pn #cmd
#define ESC_COLOR_ERROR ESC_CMD2(31, m)   // 红色错误
#define ESC_COLOR_SUCCESS ESC_CMD2(32, m) // 绿色成功
#define ESC_COLOR_WARNING ESC_CMD2(33, m) // 黄色警告
#define ESC_COLOR_INFO ESC_CMD2(34, m)    // 蓝色信息
#define ESC_COLOR_PROMPT ESC_CMD2(36, m)  // 青色提示符
#define ESC_COLOR_HELP ESC_CMD2(35, m)    // 紫色帮助
#define ESC_COLOR_DEFAULT ESC_CMD2(39, m) // 默认颜色
#define ESC_COLOR_BOLD ESC_CMD2(1, m)     // 粗体
#define ESC_COLOR_RESET "\x1b[0m"         // 重置所有格式
#define ESC_CLEAR_SCREEN ESC_CMD2(2, J)   // 擦除整屏幕
#define ESC_MOVE_CURSOR(row, col) "\x1b[" #row ";" #col "H"
/**
 * @brief        : clear命令,清空显示屏
 * @param         {int} argc: 参数个数
 * @param         {char} *: 具体参数
 * @return        {int} : 执行成功返回0,失败返回-1
 **/
static int do_clear(int argc, char **argv)
{
    printf("%s", ESC_CLEAR_SCREEN);      // 清屏
    printf("%s", ESC_MOVE_CURSOR(0, 0)); // 设置光标
    return 0;
}
```

> 宏定义较为复杂不深究

# 3.echo命令的实现

```c
/**
 * @brief        : echo命令,打印某些信息
 * @param         {int} argc: 参数个数
 * @param         {char} *: 具体参数
 * @return        {int} : 执行成功返回0,失败返回-1
 **/
static int do_echo(int argc, char **argv)
{
    if (argc == 1) // 只有echo一个参数
    {
        printf(ESC_COLOR_INFO "Enter message: " ESC_COLOR_DEFAULT);
        fflush(stdout);                         // 强制刷新输出缓冲区
        char msg_buf[128];                      // 等待输入缓冲区
        fgets(msg_buf, sizeof(msg_buf), stdin); // 等待用户输入
        msg_buf[strlen(msg_buf) - 1] = '\0';    // 将'\n'替换
        puts(msg_buf);                          // 输出
        return 0;
    }
    int count = 1; // 默认echo一次;
    int ch;
    while ((ch = getopt(argc, argv, "n:h")) != -1)
    {
        switch (ch)
        {
        case 'h':
            // puts("echo message");
            // puts("echo [-n count] message -- echo some message");
            printf(ESC_COLOR_HELP "Usage: echo message\n");
            printf("       echo [-n count] message -- echo some message\n" ESC_COLOR_DEFAULT);
            optind = 1; // getopt需要多次调用，需要重置
            return 0;
        case 'n':
            count = atoi(optarg);
            break;
        case '?':
            if (optarg)
            {
                fprintf(stderr, ESC_COLOR_ERROR "Unknown option: %s\n" ESC_COLOR_DEFAULT, cli.curr_input);
            }
            optind = 1; // getopt需要多次调用，需要重置
            return -1;
        default:
            break;
        }
    }
    if (optind > argc - 1)
    {
        fprintf(stderr, ESC_COLOR_ERROR "message is empty: %s\n" ESC_COLOR_DEFAULT, cli.curr_input);
        optind = 1; // getopt需要多次调用，需要重置
        return -1;
    }
    char *msg = argv[optind];
    for (int i = 0; i < count; i++)
    {
        puts(msg);
    }
    optind = 1; // getopt需要多次调用，需要重置
    return 0;
}
```

# 4.为进程增加系统调用exit

​	在应用程序的执行过程中，程序可能会主动结束执行，或者从main返回，因此需要给进程一个主动退出执行的接口。

![image-20250709143910971](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250709143910971.png)

```c
/**
 * @brief        : 结束当前进程
 * @param         {int} argc: 参数个数
 * @param         {char} *: 传递的参数
 * @return        {int} : 退出的状态
 **/
static int do_exit(int argc, char **argv)
{
    printf(ESC_COLOR_WARNING "Goodbye! Exiting shell...\n" ESC_COLOR_DEFAULT);
    exit(0); // 通知OS退出当前进程
    return 0;
}
```

具体实现

```c
/**
 * @brief        : 退出当前进程
 * @param         {int} status: 状态
 * @return        {void}
 **/
void sys_exit(int status)
{
    task_t *curr_task = task_current(); // 获取当前进程

    for (int fd = 0; fd < TASK_OPEN_FILE_NR; fd++) // 扫描进程文件表并清空
    {
        file_t *file = curr_task->file_table[fd]; // 取出文件指针
        if (file != (file_t *)0)                  // 不为空
        {
            sys_close(fd);                           // 关闭当前文件
            curr_task->file_table[fd] = (file_t *)0; // 清空
        }
    }
    // 处理孤儿进程：将当前进程的所有子进程转交给 first_task 管理
    int child_is_died = 0;         // 标记是否有子进程处于僵尸状态
    mutex_lock(&task_table_mutex); // 访问进程表
    for (int i = 0; i < TASK_NR; i++)
    {
        task_t *task = task_table + i; // 取出当前进程
        if (task->parent == curr_task) // 当前进程的子进程
        {
            task->parent = &task_manager.first_task; // 将当前进程的子进程的父进程设置为first_task
            if (task->state)                         // 当前进程子进程也处于僵死状态
            {
                child_is_died = 1; // 标记有僵尸子进程需要 first_task 回收
            }
        }
    }
    mutex_unlock(&task_table_mutex); // 解锁进程表

    irq_state_t state = irq_enter_protection(); // 关中断保护
    // 如果有僵尸子进程转交给了 first_task，且当前进程的父进程不是 first_task
    task_t *parent_task = curr_task->parent;                        // 取父进程
    if (child_is_died && (parent_task != &task_manager.first_task)) // 子进程处于僵死状态且父进程不为first_task
    {
        if (task_manager.first_task.state == TASK_WAIT) // first_task 正在等待子进程
        {
            task_set_ready(&task_manager.first_task); // 唤醒 first_task 去回收僵尸子进程
        }
    }
    if (parent_task->state == TASK_WAIT) // 如果父进程正在等待当前进程结束7
    {
        task_set_ready(curr_task->parent); // 唤醒父进程
    }

    curr_task->state = TASK_ZOMBIE; // 当前进程濒死
    curr_task->status = status;     // 保存传递的status
    task_set_block(curr_task);      // 将当前进程阻塞
    task_dispatch();                // 切换进程
    irq_leave_protection(state);    // 关中断返回
}

```

# 5.增加wait系统调用

```c
/**
 * @brief        : 回收当前进程的资源
 * @param         {int *} satus: 传入的参数
 * @return        {int} :   返回进程的pid
 **/
int sys_wait(int *status)
{
    task_t *curr_task = task_current(); // 当前进程
    for (;;)
    {
        mutex_lock(&task_table_mutex);    // 上锁
        for (int i = 0; i < TASK_NR; i++) // 遍历进程表
        {
            task_t *task = task_table + i; // 取出该进程
            if (task->parent != curr_task) // 非当前进程子进程,跳过
            {
                continue;
            }

            if (task->state == TASK_ZOMBIE) // 僵尸进程
            {
                int pid = task->pid;                              // 取出进程id
                *status = task->status;                           // 取出状态值
                memory_destory_uvm(task->tss.cr3);                // 释放页表
                memory_free_page(task->tss.esp0 - MEM_PAGE_SIZE); // 释放栈空间
                kernel_memset(task, 0, sizeof(task_t));           // 清空进程
                mutex_unlock(&task_table_mutex);                  // 解锁
                return pid;                                       // 返回子进程pid
            }
        }
        mutex_unlock(&task_table_mutex); // 没有找到,解锁
        // 没有找到处于僵尸状态的子进程,当前进程等待，切换进程
        irq_state_t irq_state = irq_enter_protection(); // 保护
        task_set_block(curr_task);                      // 阻塞当前进程
        curr_task->state = TASK_WAIT;                   // 设置为等待状态
        task_dispatch();                                // 切换另一个进程运行
        irq_leave_protection(irq_state);                // 退出保护
    }

    return 0;
}

```

> ```asciiarmor
> 1. 父进程调用 run_exec_file()
> 2. fork() 创建子进程
> 3. 现在有两个进程同时运行：
>    
>    子进程：                    父进程：
>    ├─ 打印参数0               ├─ 调用 wait() 等待
>    ├─ 睡眠1秒                 ├─ 被阻塞
>    ├─ 打印参数1               ├─ ...
>    ├─ 睡眠1秒                 ├─ ...
>    ├─ ...                    ├─ ...
>    └─ exit(-1) 退出           └─ wait() 返回，打印结果
> ```
>
> - **并发执行**：fork() 后，父子进程同时运行
> - **同步等待**：父进程用 `wait()` 等待子进程完成
> - **状态传递**：子进程的退出状态（-1）传递给父进程
> - **资源清理**：wait() 确保僵尸进程被正确回收
>
> 子进程 exit(-1) → 僵尸状态 → 父进程 wait() → 完全释放
>
> 这样设计是为了：
> 1. 让父进程能获取子进程的退出状态
> 2. 确保资源释放的时机正确
> 3. 避免资源泄漏

# 6.让父进程继承父进程已打开的文件

```c
/**
 * @file		 : kernel/fs/file.c
 * @param         {file_t *} file: 需要增加的文件
 * @return        {void}
 **/
void file_incr_ref(file_t *file)
{
    mutex_lock(&file_alloc_mutex);   // 上锁
    file->ref++;                     // 打开次数增加
    mutex_unlock(&file_alloc_mutex); // 解锁
}
/**
 * @file		 : kernel/core/task.c
 * @brief        : 子进程复制当前进程打开的文件
 * @param         {task_t *} child_task: 子进程
 * @return        {void}
 **/
static void copy_opened_files(task_t *child_task)
{
    task_t *parent_task = task_current();
    for (int i = 0; i < TASK_OPEN_FILE_NR; i++) // 扫描父进程的进程文件表
    {
        file_t *file = parent_task->file_table[i]; // 取出该文件
        if (file != (file_t *)0)                   // 不为空
        {
            file_incr_ref(file);               // 子进程打开该文件增加文件使用次数
            child_task->file_table[i] = file; // 复制到子进程
        }
    }
}
```


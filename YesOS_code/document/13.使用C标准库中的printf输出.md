# 移植`newlib`库，使用标准库

## 1.增加文件系统调用

整理`app`库下面所有的文件

![image-20250706150756210](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706150756210.png)

​	添加`lib_syscall.c`文件，将原有`lib_syscall.h`的系统调用接口转移到此文件。

​	并添加文件相关的系统调用。

```c
int sys_open(const char * path, int flags,...);
int sys_read(int file,char *ptr , int len);
int sys_write(int file,char *ptr , int len);
int sys_lseek(int file,int ptr , int dir);
int sys_close(int file);
int sys_isatty(int file);
int sys_fstat(struct stat * st);
```

​	在`syscall.h`文件中添加相关宏定义，同时在`syscall.c`的系统调用表中添加对应系统调用添加相关。

```c
#define SYS_open            50
#define SYS_read            51
#define SYS_write           52
#define SYS_close           53
#define SYS_lseek           54
#define SYS_isatty          55
#define SYS_sbrk            56
#define SYS_fstat           57
static const sys_handler_t sys_table[] = {
    [SYS_sleep] = (sys_handler_t)sys_sleep,
    [SYS_getpid] = (sys_handler_t)sys_getpid,
    [SYS_print_msg] = (sys_handler_t)sys_print_msg,
    [SYS_fork] = (sys_handler_t)sys_fork,
    [SYS_execve] = (sys_handler_t)sys_execve,
    [SYS_yield] = (sys_handler_t)sys_yield,
    [SYS_open] = (sys_handler_t)sys_open,
    [SYS_read] = (sys_handler_t)sys_read,
    [SYS_write] = (sys_handler_t)sys_write,
    [SYS_close] = (sys_handler_t)sys_close,
    [SYS_lseek] = (sys_handler_t)sys_lseek,
    [SYS_isatty] = (sys_handler_t)sys_isatty,
    [SYS_sbrk] = (sys_handler_t)sys_sbrk,
    [SYS_fstat] = (sys_handler_t)sys_fstat,

};
```

​	最后在`fs.h`中添加相关接口，并在`fs.c`中实现相关函数。

​	编译后提示找不到相关的相关的函数，之前的实现时使用内联函数，会将代码插到对应位置后编译。现在将其分开，头文件放申明，c文件放实现，将这个`applib`编译成库文件。需要将`shell`与applib连接起来。

`./kernel/CMake_lists.txt`文件中添加

```cmake
set(LIBS_FLAGS "-L ${CMAKE_BINARY_DIR}/source/applib/ -lapp")
set(CMAKE_EXE_LINKER_FLAGS "-m elf_i386  -T ${PROJECT_SOURCE_DIR}/kernel.lds ${LIBS_FLAGS}")
```

`./CMakeLists.txt`文件中添加

```cmake
add_dependencies(shell app)
add_dependencies(kernel app)
```

​	编译运行到first_task.c文件中的`getpid()`出现异常。原因：`getpid()`作为系统调用，`first_task`为特权级3的应用程序，无法直接访问。调整链接脚本，将其放在指定位置，指定放在`0x80000000`以上的区域。

```apl
SECTIONS {
    /**
    * 内核代码从物理地址 0x10000 开始
    * EXCLUDE_FILE(*first_task*) 排除了所有包含 "first_task" 的文件的代码段
    * s_text 标记代码段开始地址
    */
    PROVIDE(kernel_base = .);
    . = 0x00010000;
    PROVIDE(s_text = .);
    .text : {
        	*(EXCLUDE_FILE(*first_task* *lib_syscall*) .text)
    }
    /**
    * 存放常量数据
    * e_text 标记只读区域结束
    **/
    .rodata :{
        *(EXCLUDE_FILE(*first_task* *lib_syscall*) .rodata)
    }
    PROVIDE(e_text = .);
    /**
    * 按 4KB 对齐（页面边界）
    * .data 存放初始化的全局变量
    * .bss 存放未初始化的全局变量
    * e_data 标记数据区结束
    **/
    . = ALIGN(4096);
    PROVIDE(s_data = .);
    .data :{
        *(EXCLUDE_FILE(*first_task* *lib_syscall*) .data)
    }
    .bss : {
        *(EXCLUDE_FILE(*first_task* *lib_syscall*) .bss)
    }
    e_data = .;
    /**
    * 虚拟地址: 0x80000000 (用户空间起始地址)
    * 物理地址: AT(e_data) 指定加载到内核数据段之后
    * 内容: 包含所有 first_task 相关文件的所有段
    **/
    . = 0x80000000;
    PROVIDE(s_first_task = LOADADDR(.first_task));
    .first_task :AT(e_data) {
        *first_task_entry*(.text .rodata .bss .data)
        *first_task*(.text .rodata .bss .data)
        *lib_syscall*(.text .data .bss)

    }
    PROVIDE(e_first_task = LOADADDR(.first_task) + SIZEOF(.first_task));
    PROVIDE(mem_free_start = e_first_task );

    /**
    * e_first_task 计算第一个任务的物理结束地址
    * mem_free_start 提供给内核的空闲内存起始地址
    **/
}
```

## 2.导入`newlib` 并调用`printf()`

​	内核中并不导入`newlib`库，只供`shell`使用

![image-20250706154900072](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706154900072.png)

### 2.1`newlib`库简介：

![image-20250706154925590](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706154925590.png)

![image-20250706155011612](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706155011612.png)

​	引入`newlib`库后的整体结构

![image-20250706155041711](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706155041711.png)

​	调整`shell/CMakeLists.txt`

```cmake
set(LIBS_FLAGS "-L ${CMAKE_BINARY_DIR}/source/applib/ -lapp -L ${CMAKE_BINARY_DIR}/../../../newlib/i686-elf/lib -lm -lc")

```

​	以及`./CMakeLists.txt`添加头文件搜索路径。

```cmake
    ${PROJECT_SOURCE_DIR}/../../newlib/i686-elf/include
```

​	编译后提示找不到`sbrk`、`fstat`等函数。需要添加相关实现上述已经添加，下述主要关注这些函数的具体实现。添加后任然无法使用`printf()`函数，需要实现`sbrk()`函数

### 2.2 `sbrk()`函数的实现

​	`maclloc()`负责从堆空间中分配内容给应用程序使用，堆是一个动态增长的存储区域。

![image-20250706160032592](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706160032592.png)

> `sbrk`函数是一种用于在进程地址空间中调整堆空间大小的系统调用。它通过移动堆的边界来增加或减少可用内存的大小。`sbrk`函数通常用于实现`malloc`和`free`等动态内存分配函数，是一种常见的内存管理方式。
>
> ```c
> void*sbrk(intptr_t increment)
> ```
>
> 
>
> - `sbrk`函数的功能是根据所传入的参数增加或减少可用内存的大小。
> - 当调用成功时，`sbrk`函数返回一个指向增加（或减少）后的堆顶地址的指针。若调用失败，则返回`(void *)-1`。

​	小处理：`bss`区的清0，

`applib/main.c`文件中

```c
#include <stdint.h>
int main(int argc, char **argv);
extern uint8_t __bss__start__[], __bss__end__[];
void cstart(int argc, char **argv)
{
    // bss区域清空
    uint8_t *start = __bss__start__;
    uint8_t *end = __bss__end__;
    while (start < end)
    {
        *start++ = 0;
    }
    main(argc, argv); // 跳转至应用程序运行
}

```

`shell/link.lds`文件中添加起始和结束。

```apl
ENTRY(_start)
SECTIONS
{
    . = 0x81000000;
    .text : {
        *(.text)
    }
    .rodata :{
        *(.rodata)
    }
    .data : {
        *(.data)
    }
    .bss : {
        /*bss起始地址*/
        PROVIDE(__bss__start__ = .);
        *(.bss)
        /*bss结束地址*/
        PROVIDE(__bss__end__ = .);
    }
}
```

​	为`task_t`结构中添加堆的起始地址，结束地址，初始化为其设置为0；

```c
typedef struct _task_t
{
    ...原有代码
    uint32_t heap_start; // 堆起始地址
    uint32_t heap_end;   // 堆结束地址
	...原有代码
} task_t;
```

​	对`first_task`初始化时，设置其起始地址，即为其堆的结束地址，大小为0；

​	加载`elf`文件时简单设置`task`的堆的起始地址为虚拟地址加上内存区域对应的大小。指向`bss`的末端地址即`heap`的起始地址。

```c
        // task->heap_start最终指向bss区末端地址
        task->heap_start = elf_phdr.p_vaddr + elf_phdr.p_memsz;
        task->heap_end = task->heap_start; // 堆大小为0 
```

​	具体实现如下：`memory.c`中

```c
/**
 * @brief        : 为当前进程增长指定字节的堆空间
 * @param         {int} incr: 增长的字节量
 * @return        {char *} 增长之前的堆末端地址
 **/
char *sys_sbrk(int incr)
{
    task_t *task = task_current();               // 获取当前进程
    char *pre_heap_end = (char *)task->heap_end; // 当前进程堆末端地址
    int pre_incr = incr;                         // 原始incr
    ASSERT(incr >= 0);
    if (incr == 0)
    {
        log_printf("sbrk(0) : end=0x%x", pre_heap_end);
        return pre_heap_end;
    }
    uint32_t start = task->heap_end;      // 增长的起始地址
    uint32_t end = task->heap_end + incr; // 增长后结束地址

    int start_offset = start & (MEM_PAGE_SIZE - 1); // 获取页边界对齐后的偏移量
    if (start_offset)
    {
        if (start_offset + incr <= MEM_PAGE_SIZE) // 没有超过一页,直接分配
        {
            task->heap_end = end; // 直接调整，因为之前都是一页一页分配的
            incr -= incr;
            return pre_heap_end; // 返回之前堆末端地址
        }
        else // 超过了一页
        {
            uint32_t curr_size = MEM_PAGE_SIZE - start_offset; // 当前页已经分配了,所以只需要分配当前页之外的
            start += curr_size;                                // 调整增长的起始地址
            incr -= curr_size;                                 // 调整分配的大小
        }
    }
    if (incr) // 还没分配完
    {
        uint32_t curr_size = end - start;
        int err = memory_alloc_page_for(start, curr_size, PTE_P | PTE_U | PTE_W); // 分配内存
        if (err < 0)
        {
            log_printf("sbrk: alloc memory failed.");
            return (char *)-1;
        }
    }
    log_printf("sbrk(%d): end = 0x%x", pre_incr, end);
    task->heap_end = end;        // 调整末端地址
    return (char *)pre_heap_end; // 返回之前的末端地址
}
```

## 3.简单的`printf()`调用实现

​	`printf()`最终会通过文件系统的接口，将格式化好的数据写入标准输入输出。

![image-20250706162750723](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250706162750723.png)

完善`sys_write`系统调用：

```c
/**
 * @brief        : 写文件
 * @param         {int} file: 写入的文件
 * @param         {char} *ptr: 写入的内容的起始地址
 * @param         {int} len: 写入长度
 * @return        {int} : 返回-1
 **/
int sys_write(int file, char *ptr, int len)
{
    if (file == 1)
    {
        log_printf("%s", ptr);
    }
    return -1;
}
```


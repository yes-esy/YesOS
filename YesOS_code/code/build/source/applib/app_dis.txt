In archive E:/OS/MyOs/YesOS_code/code/build/source/applib/libapp.a:

crt0.S.obj:     file format elf32-i386
rw-rw-rw- 0/0   1308 Feb 15 12:32 2025 crt0.S.obj
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000010  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000044  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000044  2**0
                  ALLOC
  3 .debug_line   00000062  00000000  00000000  00000044  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_info   00000085  00000000  00000000  000000a6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000014  00000000  00000000  0000012b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000140  2**3
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 g       .text	00000000 _start
00000000         *UND*	00000000 cstart



Disassembly of section .text:

00000000 <_start>:
.text
.global _start
.extern cstart
_start:
    // 需要重新加载各数据段
    mov %ss, %ax
   0:	66 8c d0             	mov    %ss,%ax
    mov %ax, %ds
   3:	8e d8                	mov    %eax,%ds
    mov %ax, %es
   5:	8e c0                	mov    %eax,%es
    mov %ax, %fs
   7:	8e e0                	mov    %eax,%fs
    mov %ax, %gs
   9:	8e e8                	mov    %eax,%gs
    jmp cstart
   b:	e9 fc ff ff ff       	jmp    c <_start+0xc>
			c: R_386_PC32	cstart

cstart.c.obj:     file format elf32-i386
rw-rw-rw- 0/0   7420 Feb 15 12:32 2025 cstart.c.obj
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000003e  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000072  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000072  2**0
                  ALLOC
  3 .debug_info   00000950  00000000  00000000  00000072  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000001cc  00000000  00000000  000009c2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000020  00000000  00000000  00000b8e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_line   000001a6  00000000  00000000  00000bae  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_str    000005c0  00000000  00000000  00000d54  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .comment      00000012  00000000  00000000  00001314  2**0
                  CONTENTS, READONLY
  9 .debug_frame  0000002c  00000000  00000000  00001328  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 cstart.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 g     F .text	0000003e cstart
00000000         *UND*	00000000 __bss_start__
00000000         *UND*	00000000 __bss_end__
00000000         *UND*	00000000 main
00000000         *UND*	00000000 exit



Disassembly of section .text:

00000000 <cstart>:
#include <stdlib.h>
#include "lib_syscall.h"
extern uint8_t __bss_start__[],__bss_end__[];
int main(int argc,char **argv);
void cstart(int argc,char **argv)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 18             	sub    $0x18,%esp
    uint8_t *start = __bss_start__;
   6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			9: R_386_32	__bss_start__
    while(start < __bss_end__)
   d:	eb 0c                	jmp    1b <cstart+0x1b>
        *start++ = 0;
   f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  12:	8d 50 01             	lea    0x1(%eax),%edx
  15:	89 55 f4             	mov    %edx,-0xc(%ebp)
  18:	c6 00 00             	movb   $0x0,(%eax)
    while(start < __bss_end__)
  1b:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
			1e: R_386_32	__bss_end__
  22:	72 eb                	jb     f <cstart+0xf>
    exit(main(argc, argv));
  24:	83 ec 08             	sub    $0x8,%esp
  27:	ff 75 0c             	pushl  0xc(%ebp)
  2a:	ff 75 08             	pushl  0x8(%ebp)
  2d:	e8 fc ff ff ff       	call   2e <cstart+0x2e>
			2e: R_386_PC32	main
  32:	83 c4 10             	add    $0x10,%esp
  35:	83 ec 0c             	sub    $0xc,%esp
  38:	50                   	push   %eax
  39:	e8 fc ff ff ff       	call   3a <cstart+0x3a>
			3a: R_386_PC32	exit

lib_syscall.c.obj:     file format elf32-i386
rw-rw-rw- 0/0  12344 Feb 15 12:32 2025 lib_syscall.c.obj
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002be  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  000002f2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000002f2  2**0
                  ALLOC
  3 .debug_info   00000f62  00000000  00000000  000002f2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000027a  00000000  00000000  00001254  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000020  00000000  00000000  000014ce  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_line   00000279  00000000  00000000  000014ee  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_str    00000799  00000000  00000000  00001767  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .comment      00000012  00000000  00000000  00001f00  2**0
                  CONTENTS, READONLY
  9 .debug_frame  00000258  00000000  00000000  00001f14  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 lib_syscall.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l     F .text	00000053 sys_call
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000053 g     F .text	0000002a msleep
0000007d g     F .text	0000001b getpid
00000098 g     F .text	00000028 print_msg
000000c0 g     F .text	0000001b fork
000000db g     F .text	0000002d execve
00000108 g     F .text	0000001b yield
00000123 g     F .text	00000027 open
0000014a g     F .text	0000002d read
00000177 g     F .text	0000002d write
000001a4 g     F .text	00000021 close
000001c5 g     F .text	0000002d lseek
000001f2 g     F .text	00000021 isatty
00000213 g     F .text	00000027 fstat
0000023a g     F .text	00000021 sbrk
0000025b g     F .text	00000021 dup
0000027c g     F .text	00000021 _exit
0000029d g     F .text	00000021 wait



Disassembly of section .text:

00000000 <sys_call>:
    int arg2;
    int arg3;
} sycall_args_t;

static inline int sys_call(sycall_args_t *args)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	57                   	push   %edi
   4:	56                   	push   %esi
   5:	53                   	push   %ebx
   6:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[] = {0, SELECTOR_SYSCALL | 0};
   9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  10:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%ebp)

    int ret = 0;
  17:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        "push %[arg2]\n\t"
        "push %[arg1]\n\t"
        "push %[arg0]\n\t"
        "push %[id]\n\t"
        "lcall *(%[a])" : "=a"(ret) :
        [arg3] "r"(args->arg3),
  1e:	8b 45 08             	mov    0x8(%ebp),%eax
  21:	8b 40 10             	mov    0x10(%eax),%eax
        [arg2] "r"(args->arg2),
  24:	8b 55 08             	mov    0x8(%ebp),%edx
  27:	8b 52 0c             	mov    0xc(%edx),%edx
        [arg1] "r"(args->arg1),
  2a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  2d:	8b 49 08             	mov    0x8(%ecx),%ecx
        [arg0] "r"(args->arg0),
  30:	8b 5d 08             	mov    0x8(%ebp),%ebx
  33:	8b 5b 04             	mov    0x4(%ebx),%ebx
        [id] "r"(args->id),
  36:	8b 75 08             	mov    0x8(%ebp),%esi
  39:	8b 36                	mov    (%esi),%esi
    __asm__ __volatile__(
  3b:	8d 7d e8             	lea    -0x18(%ebp),%edi
  3e:	50                   	push   %eax
  3f:	52                   	push   %edx
  40:	51                   	push   %ecx
  41:	53                   	push   %ebx
  42:	56                   	push   %esi
  43:	ff 1f                	lcall  *(%edi)
  45:	89 45 f0             	mov    %eax,-0x10(%ebp)
        [a] "r"(addr));
    return ret;
  48:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
  4b:	83 c4 10             	add    $0x10,%esp
  4e:	5b                   	pop    %ebx
  4f:	5e                   	pop    %esi
  50:	5f                   	pop    %edi
  51:	5d                   	pop    %ebp
  52:	c3                   	ret    

00000053 <msleep>:


#include "lib_syscall.h"

void msleep(int ms)
{
  53:	55                   	push   %ebp
  54:	89 e5                	mov    %esp,%ebp
  56:	83 ec 20             	sub    $0x20,%esp
    if (ms <= 0)
  59:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  5d:	7e 1b                	jle    7a <msleep+0x27>
        return;
    sycall_args_t args;
    args.id = SYS_sleep;
  5f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    args.arg0 = ms;
  66:	8b 45 08             	mov    0x8(%ebp),%eax
  69:	89 45 f0             	mov    %eax,-0x10(%ebp)
    sys_call(&args);
  6c:	8d 45 ec             	lea    -0x14(%ebp),%eax
  6f:	50                   	push   %eax
  70:	e8 8b ff ff ff       	call   0 <sys_call>
  75:	83 c4 04             	add    $0x4,%esp
  78:	eb 01                	jmp    7b <msleep+0x28>
        return;
  7a:	90                   	nop
}
  7b:	c9                   	leave  
  7c:	c3                   	ret    

0000007d <getpid>:

int getpid(void)
{
  7d:	55                   	push   %ebp
  7e:	89 e5                	mov    %esp,%ebp
  80:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_getpid;
  83:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
    return sys_call(&args);
  8a:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8d:	50                   	push   %eax
  8e:	e8 6d ff ff ff       	call   0 <sys_call>
  93:	83 c4 04             	add    $0x4,%esp
}
  96:	c9                   	leave  
  97:	c3                   	ret    

00000098 <print_msg>:

void print_msg(const char *fmt, int arg)
{
  98:	55                   	push   %ebp
  99:	89 e5                	mov    %esp,%ebp
  9b:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_printmsg;
  9e:	c7 45 ec 64 00 00 00 	movl   $0x64,-0x14(%ebp)
    args.arg0 = (int)fmt;
  a5:	8b 45 08             	mov    0x8(%ebp),%eax
  a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = arg;
  ab:	8b 45 0c             	mov    0xc(%ebp),%eax
  ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
    sys_call(&args);
  b1:	8d 45 ec             	lea    -0x14(%ebp),%eax
  b4:	50                   	push   %eax
  b5:	e8 46 ff ff ff       	call   0 <sys_call>
  ba:	83 c4 04             	add    $0x4,%esp
}
  bd:	90                   	nop
  be:	c9                   	leave  
  bf:	c3                   	ret    

000000c0 <fork>:
int fork()
{
  c0:	55                   	push   %ebp
  c1:	89 e5                	mov    %esp,%ebp
  c3:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_fork;
  c6:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
    return sys_call(&args);
  cd:	8d 45 ec             	lea    -0x14(%ebp),%eax
  d0:	50                   	push   %eax
  d1:	e8 2a ff ff ff       	call   0 <sys_call>
  d6:	83 c4 04             	add    $0x4,%esp
}
  d9:	c9                   	leave  
  da:	c3                   	ret    

000000db <execve>:

int execve(const char *name, char *const *argv, char *const *env)
{
  db:	55                   	push   %ebp
  dc:	89 e5                	mov    %esp,%ebp
  de:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_execve;
  e1:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
    args.arg0 = (int)name;
  e8:	8b 45 08             	mov    0x8(%ebp),%eax
  eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)argv;
  ee:	8b 45 0c             	mov    0xc(%ebp),%eax
  f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = (int)env;
  f4:	8b 45 10             	mov    0x10(%ebp),%eax
  f7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return sys_call(&args);
  fa:	8d 45 ec             	lea    -0x14(%ebp),%eax
  fd:	50                   	push   %eax
  fe:	e8 fd fe ff ff       	call   0 <sys_call>
 103:	83 c4 04             	add    $0x4,%esp
}
 106:	c9                   	leave  
 107:	c3                   	ret    

00000108 <yield>:

int yield()
{
 108:	55                   	push   %ebp
 109:	89 e5                	mov    %esp,%ebp
 10b:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_yield;
 10e:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%ebp)
    return sys_call(&args);
 115:	8d 45 ec             	lea    -0x14(%ebp),%eax
 118:	50                   	push   %eax
 119:	e8 e2 fe ff ff       	call   0 <sys_call>
 11e:	83 c4 04             	add    $0x4,%esp
}
 121:	c9                   	leave  
 122:	c3                   	ret    

00000123 <open>:

int open(const char *name, int flags, ...)
{
 123:	55                   	push   %ebp
 124:	89 e5                	mov    %esp,%ebp
 126:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_open;
 129:	c7 45 ec 32 00 00 00 	movl   $0x32,-0x14(%ebp)
    args.arg0 = (int)name;
 130:	8b 45 08             	mov    0x8(%ebp),%eax
 133:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)flags;
 136:	8b 45 0c             	mov    0xc(%ebp),%eax
 139:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return sys_call(&args);
 13c:	8d 45 ec             	lea    -0x14(%ebp),%eax
 13f:	50                   	push   %eax
 140:	e8 bb fe ff ff       	call   0 <sys_call>
 145:	83 c4 04             	add    $0x4,%esp
}
 148:	c9                   	leave  
 149:	c3                   	ret    

0000014a <read>:
int read(int file, char *ptr, int len)
{
 14a:	55                   	push   %ebp
 14b:	89 e5                	mov    %esp,%ebp
 14d:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_read;
 150:	c7 45 ec 33 00 00 00 	movl   $0x33,-0x14(%ebp)
    args.arg0 = (int)file;
 157:	8b 45 08             	mov    0x8(%ebp),%eax
 15a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)ptr;
 15d:	8b 45 0c             	mov    0xc(%ebp),%eax
 160:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = (int)len;
 163:	8b 45 10             	mov    0x10(%ebp),%eax
 166:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return sys_call(&args);
 169:	8d 45 ec             	lea    -0x14(%ebp),%eax
 16c:	50                   	push   %eax
 16d:	e8 8e fe ff ff       	call   0 <sys_call>
 172:	83 c4 04             	add    $0x4,%esp
}
 175:	c9                   	leave  
 176:	c3                   	ret    

00000177 <write>:
int write(int file, const char *ptr, int len)
{
 177:	55                   	push   %ebp
 178:	89 e5                	mov    %esp,%ebp
 17a:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_write;
 17d:	c7 45 ec 34 00 00 00 	movl   $0x34,-0x14(%ebp)
    args.arg0 = (int)file;
 184:	8b 45 08             	mov    0x8(%ebp),%eax
 187:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)ptr;
 18a:	8b 45 0c             	mov    0xc(%ebp),%eax
 18d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = (int)len;
 190:	8b 45 10             	mov    0x10(%ebp),%eax
 193:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return sys_call(&args);
 196:	8d 45 ec             	lea    -0x14(%ebp),%eax
 199:	50                   	push   %eax
 19a:	e8 61 fe ff ff       	call   0 <sys_call>
 19f:	83 c4 04             	add    $0x4,%esp
}
 1a2:	c9                   	leave  
 1a3:	c3                   	ret    

000001a4 <close>:
int close(int file)
{
 1a4:	55                   	push   %ebp
 1a5:	89 e5                	mov    %esp,%ebp
 1a7:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_close;
 1aa:	c7 45 ec 35 00 00 00 	movl   $0x35,-0x14(%ebp)
    args.arg0 = (int)file;
 1b1:	8b 45 08             	mov    0x8(%ebp),%eax
 1b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return sys_call(&args);
 1b7:	8d 45 ec             	lea    -0x14(%ebp),%eax
 1ba:	50                   	push   %eax
 1bb:	e8 40 fe ff ff       	call   0 <sys_call>
 1c0:	83 c4 04             	add    $0x4,%esp
}
 1c3:	c9                   	leave  
 1c4:	c3                   	ret    

000001c5 <lseek>:
int lseek(int file, int ptr, int dir)
{
 1c5:	55                   	push   %ebp
 1c6:	89 e5                	mov    %esp,%ebp
 1c8:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_lseek;
 1cb:	c7 45 ec 36 00 00 00 	movl   $0x36,-0x14(%ebp)
    args.arg0 = (int)file;
 1d2:	8b 45 08             	mov    0x8(%ebp),%eax
 1d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)ptr;
 1d8:	8b 45 0c             	mov    0xc(%ebp),%eax
 1db:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = (int)dir;
 1de:	8b 45 10             	mov    0x10(%ebp),%eax
 1e1:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return sys_call(&args);
 1e4:	8d 45 ec             	lea    -0x14(%ebp),%eax
 1e7:	50                   	push   %eax
 1e8:	e8 13 fe ff ff       	call   0 <sys_call>
 1ed:	83 c4 04             	add    $0x4,%esp
}
 1f0:	c9                   	leave  
 1f1:	c3                   	ret    

000001f2 <isatty>:

int isatty(int file)
{
 1f2:	55                   	push   %ebp
 1f3:	89 e5                	mov    %esp,%ebp
 1f5:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_isatty;
 1f8:	c7 45 ec 37 00 00 00 	movl   $0x37,-0x14(%ebp)
    args.arg0 = (int)file;
 1ff:	8b 45 08             	mov    0x8(%ebp),%eax
 202:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return sys_call(&args);
 205:	8d 45 ec             	lea    -0x14(%ebp),%eax
 208:	50                   	push   %eax
 209:	e8 f2 fd ff ff       	call   0 <sys_call>
 20e:	83 c4 04             	add    $0x4,%esp
}
 211:	c9                   	leave  
 212:	c3                   	ret    

00000213 <fstat>:
int fstat(int file, struct stat *st)
{
 213:	55                   	push   %ebp
 214:	89 e5                	mov    %esp,%ebp
 216:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_fstat;
 219:	c7 45 ec 38 00 00 00 	movl   $0x38,-0x14(%ebp)
    args.arg0 = (int)file;
 220:	8b 45 08             	mov    0x8(%ebp),%eax
 223:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)st;
 226:	8b 45 0c             	mov    0xc(%ebp),%eax
 229:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return sys_call(&args);
 22c:	8d 45 ec             	lea    -0x14(%ebp),%eax
 22f:	50                   	push   %eax
 230:	e8 cb fd ff ff       	call   0 <sys_call>
 235:	83 c4 04             	add    $0x4,%esp
}
 238:	c9                   	leave  
 239:	c3                   	ret    

0000023a <sbrk>:

void *sbrk(ptrdiff_t incr)
{
 23a:	55                   	push   %ebp
 23b:	89 e5                	mov    %esp,%ebp
 23d:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_sbrk;
 240:	c7 45 ec 39 00 00 00 	movl   $0x39,-0x14(%ebp)
    args.arg0 = (int)incr;
 247:	8b 45 08             	mov    0x8(%ebp),%eax
 24a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return (void *)sys_call(&args);
 24d:	8d 45 ec             	lea    -0x14(%ebp),%eax
 250:	50                   	push   %eax
 251:	e8 aa fd ff ff       	call   0 <sys_call>
 256:	83 c4 04             	add    $0x4,%esp
}
 259:	c9                   	leave  
 25a:	c3                   	ret    

0000025b <dup>:

int dup(int file)
{
 25b:	55                   	push   %ebp
 25c:	89 e5                	mov    %esp,%ebp
 25e:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_dup;
 261:	c7 45 ec 3a 00 00 00 	movl   $0x3a,-0x14(%ebp)
    args.arg0 = (int)file;
 268:	8b 45 08             	mov    0x8(%ebp),%eax
 26b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return sys_call(&args);
 26e:	8d 45 ec             	lea    -0x14(%ebp),%eax
 271:	50                   	push   %eax
 272:	e8 89 fd ff ff       	call   0 <sys_call>
 277:	83 c4 04             	add    $0x4,%esp
}
 27a:	c9                   	leave  
 27b:	c3                   	ret    

0000027c <_exit>:

void _exit(int status)
{
 27c:	55                   	push   %ebp
 27d:	89 e5                	mov    %esp,%ebp
 27f:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_exit;
 282:	c7 45 ec 3b 00 00 00 	movl   $0x3b,-0x14(%ebp)
    args.arg0 = status;
 289:	8b 45 08             	mov    0x8(%ebp),%eax
 28c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    sys_call(&args);
 28f:	8d 45 ec             	lea    -0x14(%ebp),%eax
 292:	50                   	push   %eax
 293:	e8 68 fd ff ff       	call   0 <sys_call>
 298:	83 c4 04             	add    $0x4,%esp
    while(1);
 29b:	eb fe                	jmp    29b <_exit+0x1f>

0000029d <wait>:
}

int wait(int *status)
{
 29d:	55                   	push   %ebp
 29e:	89 e5                	mov    %esp,%ebp
 2a0:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_wait;
 2a3:	c7 45 ec 3c 00 00 00 	movl   $0x3c,-0x14(%ebp)
    args.arg0 = (int)status;
 2aa:	8b 45 08             	mov    0x8(%ebp),%eax
 2ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return sys_call(&args);
 2b0:	8d 45 ec             	lea    -0x14(%ebp),%eax
 2b3:	50                   	push   %eax
 2b4:	e8 47 fd ff ff       	call   0 <sys_call>
 2b9:	83 c4 04             	add    $0x4,%esp
 2bc:	c9                   	leave  
 2bd:	c3                   	ret    


E:/OS/MyOs/YesOS_code/code/build/source/kernel/kernel.elf:     file format elf32-i386
E:/OS/MyOs/YesOS_code/code/build/source/kernel/kernel.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010000

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x000083f8 memsz 0x000083f8 flags r-x
    LOAD off    0x0000a000 vaddr 0x00019000 paddr 0x00019000 align 2**12
         filesz 0x00000124 memsz 0x00040e90 flags rw-
    LOAD off    0x0000b000 vaddr 0x80000000 paddr 0x00059e90 align 2**12
         filesz 0x000003a1 memsz 0x000003a1 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000070b5  00010000  00010000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00001338  000170c0  000170c0  000080c0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000124  00019000  00019000  0000a000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          0003fe90  0001a000  0001a000  0000a124  2**12
                  ALLOC
  4 .first_task   000003a1  80000000  00059e90  0000b000  2**0
                  CONTENTS, ALLOC, LOAD, CODE
  5 .debug_line   00003d93  00000000  00000000  0000b3a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000e213  00000000  00000000  0000f134  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002e30  00000000  00000000  0001d347  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 00000338  00000000  00000000  00020178  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 000000a8  00000000  00000000  000204b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000026f4  00000000  00000000  00020558  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      00000011  00000000  00000000  00022c4c  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00002a38  00000000  00000000  00022c60  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
000170c0 l    d  .rodata	00000000 .rodata
00019000 l    d  .data	00000000 .data
0001a000 l    d  .bss	00000000 .bss
80000000 l    d  .first_task	00000000 .first_task
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 CMakeFiles/kernel.dir/init/start.S.obj
00010013 l       .text	00000000 gdt_reload
00000000 l    df *ABS*	00000000 memory.c
00010319 l     F .text	0000000b list_node_prev
00010324 l     F .text	0000000a list_node_next
0001032e l     F .text	0000000d down2
0001033b l     F .text	00000017 up2
00010352 l     F .text	0000000c write_cr3
0001035e l     F .text	00000011 mmu_set_page_dir
0001036f l     F .text	0000000b pde_index
0001037a l     F .text	00000010 pte_index
0001038a l     F .text	00000027 pde_paddr
000103b1 l     F .text	00000027 pte_paddr
000103d8 l     F .text	0000000f get_pte_perm
0001a000 l     O .bss	00000028 paddr_alloc
0001b000 l     O .bss	00001000 kernel_page_dir
000103e7 l     F .text	00000055 addr_alloc_init
0001043c l     F .text	00000067 addr_alloc_page
000104a3 l     F .text	00000061 addr_free_page
00010504 l     F .text	00000046 show_mem_info
0001054a l     F .text	00000037 total_mem_size
00017200 l     O .rodata	00000012 __func__.2373
00019000 l     O .data	00000050 kernel_map.2384
00017214 l     O .rodata	0000000c __func__.2404
000109f0 l     F .text	00000013 curr_page_dir
00017220 l     O .rodata	00000011 __func__.2444
00017234 l     O .rodata	00000013 __func__.2450
00017248 l     O .rodata	00000009 __func__.2506
00000000 l    df *ABS*	00000000 syscall.c
00010ee9 l     F .text	0000000b list_node_prev
00010ef4 l     F .text	0000000a list_node_next
00017260 l     O .rodata	00000194 sys_table
00000000 l    df *ABS*	00000000 task.c
00010fad l     F .text	00000007 hlt
00010fb4 l     F .text	0000000c write_tr
00010fc0 l     F .text	0000000c write_cr3
00010fcc l     F .text	0000001b list_node_init
00010fe7 l     F .text	0000000b list_node_prev
00010ff2 l     F .text	0000000a list_node_next
00010ffc l     F .text	0000000b list_count
00011007 l     F .text	0000000a list_first
00011011 l     F .text	00000011 mmu_set_page_dir
0001c000 l     O .bss	00000600 task_manager
0001c600 l     O .bss	00001000 idle_task_stack
0001d600 l     O .bss	00017400 task_table
00034a00 l     O .bss	00000014 task_table_mutex
000110d3 l     F .text	000001a8 tss_init
00017564 l     O .rodata	0000000a __func__.2969
00011481 l     F .text	0000000a idle_task_entry
00017570 l     O .rodata	00000010 __func__.3002
000116c7 l     F .text	00000045 task_next_run
0001197c l     F .text	00000069 alloc_task
000119e5 l     F .text	00000030 free_task
00011a15 l     F .text	00000058 copy_opened_files
00011c09 l     F .text	000000fe load_phdr
00011d07 l     F .text	000001c8 load_elf_file
00011ecf l     F .text	000000f3 copy_args
00017580 l     O .rodata	0000000a __func__.3133
00000000 l    df *ABS*	00000000 cpu.c
000123dc l     F .text	00000028 lgdt
00012404 l     F .text	0000001a far_jump
0001241e l     F .text	0000000b list_node_prev
00012429 l     F .text	0000000a list_node_next
00034a20 l     O .bss	00000800 gdt_table
00035220 l     O .bss	00000014 mutex
00000000 l    df *ABS*	00000000 irq.c
0001265b l     F .text	0000001d inb
00012678 l     F .text	0000001f outb
00012697 l     F .text	00000007 cli
0001269e l     F .text	00000007 sti
000126a5 l     F .text	00000028 lidt
000126cd l     F .text	00000007 hlt
000126d4 l     F .text	00000010 read_eflags
000126e4 l     F .text	0000000b write_eflags
000126ef l     F .text	00000011 read_cr2
00035240 l     O .bss	00000400 idt_table
00012700 l     F .text	00000093 init_pic
00012793 l     F .text	000000ff dump_core_regs
00012892 l     F .text	0000003e do_default_handler
00000000 l    df *ABS*	00000000 mmu.c
00000000 l    df *ABS*	00000000 console.c
00012fa5 l     F .text	0000000b list_node_prev
00012fb0 l     F .text	0000000a list_node_next
00012fba l     F .text	0000001d inb
00012fd7 l     F .text	0000001f outb
00035640 l     O .bss	00000340 console_buff
00035980 l     O .bss	00000004 curr_console_idx
00012ff6 l     F .text	00000075 read_cursor_pos
0001306b l     F .text	000000c3 update_cursor_pos
0001312e l     F .text	00000093 erase_rows
000131c1 l     F .text	0000008a scroll_up
0001324b l     F .text	00000086 clear_display
000132d1 l     F .text	00000076 move_forward
00013347 l     F .text	00000095 show_char
000134cd l     F .text	00000010 move_to_col0
000134dd l     F .text	00000038 move_next_line
00013515 l     F .text	00000078 move_backword
0001358d l     F .text	0000003a erase_backword
000135c7 l     F .text	000000a2 write_normal
000136a5 l     F .text	00000036 clear_esc_param
000136db l     F .text	0000006e write_esc
00013749 l     F .text	00000098 set_font_style
00017b80 l     O .rodata	00000020 color_table.2403
000137e1 l     F .text	00000051 eraase_in_display
00013832 l     F .text	0000001e move_cursor
00013850 l     F .text	00000037 move_left
00013887 l     F .text	00000043 move_right
000138ca l     F .text	000000f2 write_esc_square
00000000 l    df *ABS*	00000000 dev.c
00019050 l     O .data	00000008 dev_desc_table
000359a0 l     O .bss	00000a00 dev_table
00013cd4 l     F .text	0000003c is_devid_valid
00000000 l    df *ABS*	00000000 disk.c
00013e78 l     F .text	0000000b list_node_prev
00013e83 l     F .text	0000000a list_node_next
00013e8d l     F .text	0000001d inb
00013eaa l     F .text	0000001f inw
00013ec9 l     F .text	0000001f outb
00013ee8 l     F .text	00000021 outw
000363a0 l     O .bss	0000024c disk_buff
000365ec l     O .bss	00000014 mutex
00036600 l     O .bss	00000010 op_sem
00036610 l     O .bss	00000004 task_on_op
00013f09 l     F .text	00000130 disk_send_cmd
00014039 l     F .text	00000050 disk_read_data
00014089 l     F .text	00000050 disk_write_data
000140d9 l     F .text	0000004b disk_wait_data
00014124 l     F .text	000000fe print_info_disk
00014222 l     F .text	0000011f detect_part_info
00014341 l     F .text	00000127 identify_disk
00000000 l    df *ABS*	00000000 kbd.c
000148fb l     F .text	0000001d inb
00014918 l     F .text	0000000b list_node_prev
00014923 l     F .text	0000000a list_node_next
00036614 l     O .bss	00000004 kbd_state
00017d60 l     O .rodata	00000200 map_table
0001492d l     F .text	0000003c do_fx_key
00036618 l     O .bss	00000004 inited.2064
000149b9 l     F .text	0000001a is_make_code
000149d3 l     F .text	00000015 get_key
000149e8 l     F .text	000001eb do_normal_key
00014bd3 l     F .text	00000086 do_e0_key
0003661c l     O .bss	00000004 recv_state.2110
00000000 l    df *ABS*	00000000 time.c
00014d1b l     F .text	0000001f outb
00014d3a l     F .text	0000000b list_node_prev
00014d45 l     F .text	0000000a list_node_next
00036620 l     O .bss	00000004 sys_tick
00014d77 l     F .text	00000060 init_pit
00000000 l    df *ABS*	00000000 tty.c
00014def l     F .text	0000000b list_node_prev
00014dfa l     F .text	0000000a list_node_next
00036640 l     O .bss	000022a0 tty_devs
000388e0 l     O .bss	00000004 curr_tty
00014e04 l     F .text	0000004f get_tty
00000000 l    df *ABS*	00000000 devfs.c
00015396 l     F .text	0000000b list_node_prev
000153a1 l     F .text	0000000a list_node_next
000190e0 l     O .data	0000000c devfs_type_list
00000000 l    df *ABS*	00000000 file.c
00015565 l     F .text	0000000b list_node_prev
00015570 l     F .text	0000000a list_node_next
00038900 l     O .bss	0001e000 file_table
00056900 l     O .bss	00000014 file_alloc_mutex
00000000 l    df *ABS*	00000000 fs.c
000156a8 l     F .text	0000000b list_node_prev
000156b3 l     F .text	0000000a list_node_next
000156bd l     F .text	0000000a list_first
00056920 l     O .bss	0000000c mounted_list
00056940 l     O .bss	00001518 fs_table
00057e58 l     O .bss	0000000c free_list
00057e64 l     O .bss	00000004 temp_pos
000156c7 l     F .text	00000021 is_path_valid
000157cd l     F .text	0000002b fs_protect
000157f8 l     F .text	0000002b fs_unprotect
00015823 l     F .text	0000001d is_fd_bad
00018264 l     O .rodata	0000000a __func__.2933
00015f51 l     F .text	00000060 mount_list_init
00015fb1 l     F .text	00000018 get_fs_op
00015fc9 l     F .text	000001c7 mount
00018270 l     O .rodata	00000008 __func__.2981
00000000 l    df *ABS*	00000000 init.c
000161e0 l     F .text	0000000b list_node_prev
000161eb l     F .text	0000000a list_node_next
00057e68 l     O .bss	00000010 sem
00018364 l     O .rodata	0000000c __func__.2452
00018370 l     O .rodata	00000013 __func__.2457
00000000 l    df *ABS*	00000000 mutex.c
00016325 l     F .text	0000000b list_node_prev
00016330 l     F .text	0000000a list_node_next
0001633a l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 sem.c
000164c9 l     F .text	0000000b list_node_prev
000164d4 l     F .text	0000000a list_node_next
000164de l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 bitmap.c
00000000 l    df *ABS*	00000000 klib.c
00016869 l     F .text	00000007 hlt
00019120 l     O .data	00000004 num2char.1941
00000000 l    df *ABS*	00000000 list.c
00016daf l     F .text	0000000b list_node_prev
00016dba l     F .text	0000000a list_node_next
00016dc4 l     F .text	00000013 list_is_empty
00000000 l    df *ABS*	00000000 log.c
00016fbb l     F .text	0000000b list_node_prev
00016fc6 l     F .text	0000000a list_node_next
00057e78 l     O .bss	00000014 mutex
00057e8c l     O .bss	00000004 log_dev_id
00000000 l    df *ABS*	00000000 first_task.c
80000010 l     F .first_task	0000000b list_node_prev
8000001b l     F .first_task	0000000a list_node_next
00000000 l    df *ABS*	00000000 lib_syscall.c
800000e3 l     F .first_task	00000053 sys_call
00016690 g     F .text	0000003a bitmap_get_bit
000169d4 g     F .text	0000004f kernel_memcpy
00015ca6 g     F .text	0000010c sys_close
0001170c g     F .text	0000000a task_current
0001577d g     F .text	00000050 path_begin_with
800001eb g     F .first_task	0000001b yield
00012f46 g     F .text	0000000b irq_enable_global
00016e5c g     F .text	00000063 list_insert_last
000110a3 g     F .text	00000030 task_file
000102a8 g       .text	00000000 exception_handler_kbd
00010ddd g     F .text	0000010c sys_sbrk
00011716 g     F .text	00000061 sys_yield
0001190b g     F .text	0000005b sys_msleep
00012a04 g     F .text	0000001c do_handler_segment_not_present
00011666 g     F .text	00000036 task_set_ready
0001679e g     F .text	0000001b bitmap_is_set
00016a23 g     F .text	00000041 kernel_memset
00013d5c g     F .text	0000004c dev_write
00015bf4 g     F .text	000000b2 sys_lseek
00014969 g     F .text	00000050 kbd_init
0001026a g       .text	00000000 exception_handler_virtual_exception
000148c7 g     F .text	00000005 disk_close
00010f18 g     F .text	00000095 do_handler_syscall
00012629 g     F .text	0000001e cpu_init
00016fd0 g     F .text	0000002f log_init
00011a6d g     F .text	0000019c sys_fork
000162ed g     F .text	00000038 init_main
0001020f g       .text	00000000 exception_handler_alignment_check
000148bd g     F .text	0000000a disk_control
00012568 g     F .text	00000039 gdt_free_sel
00016870 g     F .text	00000041 kernel_strcpy
00019000 g       .data	00000000 s_data
800001be g     F .first_task	0000002d execve
80000160 g     F .first_task	0000001b getpid
00012e29 g     F .text	0000008b irq_enable
0001002b g       .text	00000000 exception_handler_unknown
000100a7 g       .text	00000000 exception_handler_breakpoint
0001295c g     F .text	0000001c do_handler_overflow
00012bd1 g     F .text	0000001c do_handler_alignment_check
00010631 g     F .text	00000087 memory_create_map
00015a33 g     F .text	000000fd sys_read
00015739 g     F .text	00000044 path_next_child
00013acd g     F .text	000000b8 console_select
000101b6 g       .text	00000000 exception_handler_general_protection
00010d5a g     F .text	00000083 memor_copy_uvm_data
00012a3c g     F .text	000000b5 do_handler_general_protection
00013687 g     F .text	0000001e restore_cursor
000165fe g     F .text	00000029 sem_count
80000025 g     F .first_task	000000be first_task_main
000128ec g     F .text	0000001c do_handler_divider
000166ca g     F .text	000000d4 bitmap_set_bit
000129cc g     F .text	0000001c do_handler_double_fault
00012af1 g     F .text	000000c4 do_handler_page_fault
800002d5 g     F .first_task	00000021 isatty
00010142 g       .text	00000000 exception_handler_double_fault
00012f51 g     F .text	0000002b pic_send_eoi
0001165c g     F .text	0000000a task_first_task
00010000 g       .text	00000000 s_text
00010827 g     F .text	00000085 memory_create_uvm
0001650c g     F .text	0000006e sem_wait
00010995 g     F .text	00000025 memory_alloc_page_for
00010199 g       .text	00000000 exception_handler_stack_segment_fault
80000000 g       .first_task	00000000 first_task_entry
00015e0d g     F .text	000000a6 sys_fstat
00013d10 g     F .text	0000004c dev_read
00012c25 g     F .text	0000001c do_handler_virtual_exception
0001555b g     F .text	0000000a devfs_stat
000100c6 g       .text	00000000 exception_handler_overflow
000102e6 g       .text	00000000 simple_switch
000102c7 g       .text	00000000 exception_handler_ide_primary
000190a0 g     O .data	00000038 dec_tty_desc
800002a8 g     F .first_task	0000002d lseek
00010289 g       .text	00000000 exception_handler_time
00057e90 g     O .bss	00002000 stack
00014468 g     F .text	000000f8 disk_init
00016190 g     F .text	00000050 fs_init
00015670 g     F .text	00000038 file_inc_ref
00010a03 g     F .text	000000ad memory_free_page
00059e90 g       *ABS*	00000000 s_first_task
00011075 g     F .text	0000002e task_remove_fd
000152f0 g     F .text	0000000a tty_control
000133dc g     F .text	000000f1 console_init
00015093 g     F .text	00000134 tty_read
000113b0 g     F .text	00000086 task_uninit
000108ac g     F .text	000000e9 memory_alloc_for_page_dir
00015261 g     F .text	0000008f tty_fifo_get
000100e5 g       .text	00000000 exception_handler_bound_range
00015300 g     F .text	0000006d tty_in
00013da8 g     F .text	0000004c dev_control
00014c59 g     F .text	000000c2 do_handler_kbd
00012994 g     F .text	0000001c do_handler_invalid_opcode
0001015f g       .text	00000000 exception_handler_invalid_tss
00012bb5 g     F .text	0000001c do_handler_fpu_error
00011572 g     F .text	000000ea task_first_init
00012bed g     F .text	0000001c do_handler_machine_check
8000025a g     F .first_task	0000002d write
00015840 g     F .text	000001f3 sys_open
00012908 g     F .text	0000001c do_handler_Debug
800002f6 g     F .first_task	00000027 fstat
00015db2 g     F .text	0000005b sys_isatty
00016dfc g     F .text	00000060 list_insert_first
00013b85 g     F .text	0000014f dev_open
000156e8 g     F .text	00000051 path_to_num
000118e9 g     F .text	00000022 task_set_wakeup
00012924 g     F .text	0000001c do_handler_NMI
0001004a g       .text	00000000 exception_handler_divider
00014f63 g     F .text	00000037 tty_fifo_init
000168b1 g     F .text	00000070 kernel_strncpy
00012f3b g     F .text	0000000b irq_disable_global
00015b30 g     F .text	000000c4 sys_write
80000380 g     F .first_task	00000021 wait
0005a231 g       *ABS*	00000000 mem_free_start
000161f5 g     F .text	00000092 kernel_init
000164e9 g     F .text	00000023 sem_init
00010000 g       .text	00000000 _start
00016d69 g     F .text	00000046 get_file_name
00010123 g       .text	00000000 exception_handler_device_unavailable
00010104 g       .text	00000000 exception_handler_invalid_opcode
00013df4 g     F .text	00000084 dev_close
00013669 g     F .text	0000001e save_cursor
00059e90 g       .bss	00000000 e_data
8000022d g     F .first_task	0000002d read
00016373 g     F .text	00000097 mutex_lock
00011022 g     F .text	00000053 task_alloc_fd
00015551 g     F .text	0000000a devfs_seek
00016d3c g     F .text	0000002d string_count
0001022c g       .text	00000000 exception_handler_machine_check
00014e53 g     F .text	00000110 tty_write
000129e8 g     F .text	0000001c do_handler_invalid_tss
00000000 g       *ABS*	00000000 kernel_base
000151c7 g     F .text	0000009a tty_fifo_put
00019060 g     O .data	00000038 dec_disk_desc
0005a231 g       *ABS*	00000000 e_first_task
000118ad g     F .text	0000003c task_set_sleep
00015eb3 g     F .text	0000009e sys_dup
00012def g     F .text	0000003a irq_install
000125a1 g     F .text	00000088 init_gdt
000153ab g     F .text	00000013 devfs_mount
00014f9a g     F .text	000000f9 tty_open
800001a3 g     F .first_task	0000001b fork
00012f7c g     F .text	00000018 irq_enter_protection
00016bbb g     F .text	0000014b kernel_vsnprintf
00016345 g     F .text	0000002e mutex_init
00012eb4 g     F .text	00000087 irq_disable
8000031d g     F .first_task	00000021 sbrk
00019100 g     O .data	00000020 devfs_op
000153c8 g     F .text	00000127 devfs_open
0001024b g       .text	00000000 exception_handler_smd_exception
00010ab0 g     F .text	0000010f memory_destroy_uvm
00016627 g     F .text	00000016 bitmap_byte_count
000129b0 g     F .text	0000001c do_handler_device_unavailable
00011777 g     F .text	00000045 task_dispatch
00010bbf g     F .text	00000155 memory_copy_uvm
000152fa g     F .text	00000006 tty_close
000154ef g     F .text	00000024 devfs_write
00016287 g     F .text	00000066 move_to_first_task
00012647 g     F .text	00000014 switch_to_tss
00015537 g     F .text	0000001a devfs_close
000139bc g     F .text	0000010b console_write
8000033e g     F .first_task	00000021 dup
00016a64 g     F .text	00000060 kernel_memcmp
000106b8 g     F .text	000000c7 create_kernel_table
00016dd7 g     F .text	00000025 list_init
00012c09 g     F .text	0000001c do_handler_smd_exception
000101d3 g       .text	00000000 exception_handler_page_fault
0001169c g     F .text	0000002b task_set_block
000128d0 g     F .text	0000001c do_handler_unknown
000109ba g     F .text	00000036 memory_alloc_page
000101f0 g       .text	00000000 exception_handler_fpu_error
00010efe g     F .text	0000001a sys_printmsg
00011463 g     F .text	0000001e task_switch_from_to
00012c41 g     F .text	000001ae irq_init
0001640a g     F .text	000000bf mutex_unlock
00015640 g     F .text	00000030 file_table_init
00012f94 g     F .text	00000011 irq_leave_protection
000155fe g     F .text	00000042 file_free
8000017b g     F .first_task	00000028 print_msg
0001699f g     F .text	00000035 kernel_strlen
00012433 g     F .text	00000083 segment_desc_set
00012978 g     F .text	0000001c do_handler_bound_range
000102fb g       .text	00000000 exception_handler_syscall
00014560 g     F .text	000000f1 disk_open
00016ebf g     F .text	00000078 list_remove_first
000183f8 g       .rodata	00000000 e_text
00016921 g     F .text	0000007e kernel_strncmp
0001663d g     F .text	00000053 bitmap_init
0001017c g       .text	00000000 exception_handler_segment_not_present
0001657a g     F .text	00000084 sem_signal
00010088 g       .text	00000000 exception_handler_NMI
000167b9 g     F .text	000000b0 bitmap_alloc_nbits
0001557a g     F .text	00000084 file_alloc
0001148b g     F .text	000000e7 task_manager_init
00011436 g     F .text	0000002d task_start
00010069 g       .text	00000000 exception_handler_Debug
000117bc g     F .text	000000f1 task_time_tick
0001077f g     F .text	000000a8 memory_init
00011fc2 g     F .text	000001bd sys_execve
00014788 g     F .text	00000135 disk_write
000122c5 g     F .text	00000117 sys_wait
0001217f g     F .text	00000146 sys_exit
00016d06 g     F .text	00000036 pannic
0001536d g     F .text	00000029 tty_select
00013ac7 g     F .text	00000006 console_close
00010d14 g     F .text	00000046 memory_get_paddr
00012a20 g     F .text	0000001c do_handler_stack_segment_fault
00012940 g     F .text	0000001c do_handler_breakpoint
000153be g     F .text	0000000a devfs_unmount
8000035f g     F .first_task	00000021 _exit
00015513 g     F .text	00000024 devfs_read
00016fff g     F .text	000000b6 log_printf
0001127b g     F .text	00000135 task_init
00014651 g     F .text	00000137 disk_read
80000206 g     F .first_task	00000027 open
00016ac4 g     F .text	00000024 kernel_sprintf
00011966 g     F .text	00000016 sys_getpid
000124fd g     F .text	0000006b gdt_alloc_desc
00016ae8 g     F .text	000000d3 kernel_itoa
00016f37 g     F .text	00000084 list_remove
000124b6 g     F .text	00000047 gate_desc_set
80000136 g     F .first_task	0000002a msleep
80000287 g     F .first_task	00000021 close
000148cc g     F .text	0000002f do_handler_ide_primary
00010581 g     F .text	000000b0 find_pte
00014d4f g     F .text	00000028 do_handler_time
00014dd7 g     F .text	00000018 time_init



Disassembly of section .text:

00010000 <_start>:
    .text
    .global _start
    .extern kernel_init
    .extern init_main
_start:
    push %ebp
   10000:	55                   	push   %ebp
    mov %esp, %ebp
   10001:	89 e5                	mov    %esp,%ebp
    mov 0x8(%ebp), %eax
   10003:	8b 45 08             	mov    0x8(%ebp),%eax

    # mov 4(%esp), %eax

    push %eax
   10006:	50                   	push   %eax
    call kernel_init
   10007:	e8 e9 61 00 00       	call   161f5 <kernel_init>

    jmp $KERNEL_SELECTOR_CS, $gdt_reload
   1000c:	ea 13 00 01 00 08 00 	ljmp   $0x8,$0x10013

00010013 <gdt_reload>:

gdt_reload:
    mov $KERNEL_SELECTOR_DS, %ax		// 16为数据段选择子
   10013:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
   10017:	8e d8                	mov    %eax,%ds
    mov %ax, %ss
   10019:	8e d0                	mov    %eax,%ss
    mov %ax, %es
   1001b:	8e c0                	mov    %eax,%es
    mov %ax, %fs
   1001d:	8e e0                	mov    %eax,%fs
    mov %ax, %gs
   1001f:	8e e8                	mov    %eax,%gs

    mov $(stack + KERNEL_STACK_SIZE), %esp
   10021:	bc 90 9e 05 00       	mov    $0x59e90,%esp
    jmp init_main
   10026:	e9 c2 62 00 00       	jmp    162ed <init_main>

0001002b <exception_handler_unknown>:
		// 跳过压入的异常号和错误码
		add $(2*4), %esp
		iret
.endm

exception_handler unknown, -1, 0
   1002b:	6a 00                	push   $0x0
   1002d:	6a ff                	push   $0xffffffff
   1002f:	60                   	pusha  
   10030:	1e                   	push   %ds
   10031:	06                   	push   %es
   10032:	0f a0                	push   %fs
   10034:	0f a8                	push   %gs
   10036:	54                   	push   %esp
   10037:	e8 94 28 00 00       	call   128d0 <do_handler_unknown>
   1003c:	83 c4 04             	add    $0x4,%esp
   1003f:	0f a9                	pop    %gs
   10041:	0f a1                	pop    %fs
   10043:	07                   	pop    %es
   10044:	1f                   	pop    %ds
   10045:	61                   	popa   
   10046:	83 c4 08             	add    $0x8,%esp
   10049:	cf                   	iret   

0001004a <exception_handler_divider>:
exception_handler divider, 0, 0
   1004a:	6a 00                	push   $0x0
   1004c:	6a 00                	push   $0x0
   1004e:	60                   	pusha  
   1004f:	1e                   	push   %ds
   10050:	06                   	push   %es
   10051:	0f a0                	push   %fs
   10053:	0f a8                	push   %gs
   10055:	54                   	push   %esp
   10056:	e8 91 28 00 00       	call   128ec <do_handler_divider>
   1005b:	83 c4 04             	add    $0x4,%esp
   1005e:	0f a9                	pop    %gs
   10060:	0f a1                	pop    %fs
   10062:	07                   	pop    %es
   10063:	1f                   	pop    %ds
   10064:	61                   	popa   
   10065:	83 c4 08             	add    $0x8,%esp
   10068:	cf                   	iret   

00010069 <exception_handler_Debug>:
exception_handler Debug, 1, 0
   10069:	6a 00                	push   $0x0
   1006b:	6a 01                	push   $0x1
   1006d:	60                   	pusha  
   1006e:	1e                   	push   %ds
   1006f:	06                   	push   %es
   10070:	0f a0                	push   %fs
   10072:	0f a8                	push   %gs
   10074:	54                   	push   %esp
   10075:	e8 8e 28 00 00       	call   12908 <do_handler_Debug>
   1007a:	83 c4 04             	add    $0x4,%esp
   1007d:	0f a9                	pop    %gs
   1007f:	0f a1                	pop    %fs
   10081:	07                   	pop    %es
   10082:	1f                   	pop    %ds
   10083:	61                   	popa   
   10084:	83 c4 08             	add    $0x8,%esp
   10087:	cf                   	iret   

00010088 <exception_handler_NMI>:
exception_handler NMI, 2, 0
   10088:	6a 00                	push   $0x0
   1008a:	6a 02                	push   $0x2
   1008c:	60                   	pusha  
   1008d:	1e                   	push   %ds
   1008e:	06                   	push   %es
   1008f:	0f a0                	push   %fs
   10091:	0f a8                	push   %gs
   10093:	54                   	push   %esp
   10094:	e8 8b 28 00 00       	call   12924 <do_handler_NMI>
   10099:	83 c4 04             	add    $0x4,%esp
   1009c:	0f a9                	pop    %gs
   1009e:	0f a1                	pop    %fs
   100a0:	07                   	pop    %es
   100a1:	1f                   	pop    %ds
   100a2:	61                   	popa   
   100a3:	83 c4 08             	add    $0x8,%esp
   100a6:	cf                   	iret   

000100a7 <exception_handler_breakpoint>:
exception_handler breakpoint, 3, 0
   100a7:	6a 00                	push   $0x0
   100a9:	6a 03                	push   $0x3
   100ab:	60                   	pusha  
   100ac:	1e                   	push   %ds
   100ad:	06                   	push   %es
   100ae:	0f a0                	push   %fs
   100b0:	0f a8                	push   %gs
   100b2:	54                   	push   %esp
   100b3:	e8 88 28 00 00       	call   12940 <do_handler_breakpoint>
   100b8:	83 c4 04             	add    $0x4,%esp
   100bb:	0f a9                	pop    %gs
   100bd:	0f a1                	pop    %fs
   100bf:	07                   	pop    %es
   100c0:	1f                   	pop    %ds
   100c1:	61                   	popa   
   100c2:	83 c4 08             	add    $0x8,%esp
   100c5:	cf                   	iret   

000100c6 <exception_handler_overflow>:
exception_handler overflow, 4, 0
   100c6:	6a 00                	push   $0x0
   100c8:	6a 04                	push   $0x4
   100ca:	60                   	pusha  
   100cb:	1e                   	push   %ds
   100cc:	06                   	push   %es
   100cd:	0f a0                	push   %fs
   100cf:	0f a8                	push   %gs
   100d1:	54                   	push   %esp
   100d2:	e8 85 28 00 00       	call   1295c <do_handler_overflow>
   100d7:	83 c4 04             	add    $0x4,%esp
   100da:	0f a9                	pop    %gs
   100dc:	0f a1                	pop    %fs
   100de:	07                   	pop    %es
   100df:	1f                   	pop    %ds
   100e0:	61                   	popa   
   100e1:	83 c4 08             	add    $0x8,%esp
   100e4:	cf                   	iret   

000100e5 <exception_handler_bound_range>:
exception_handler bound_range, 5, 0
   100e5:	6a 00                	push   $0x0
   100e7:	6a 05                	push   $0x5
   100e9:	60                   	pusha  
   100ea:	1e                   	push   %ds
   100eb:	06                   	push   %es
   100ec:	0f a0                	push   %fs
   100ee:	0f a8                	push   %gs
   100f0:	54                   	push   %esp
   100f1:	e8 82 28 00 00       	call   12978 <do_handler_bound_range>
   100f6:	83 c4 04             	add    $0x4,%esp
   100f9:	0f a9                	pop    %gs
   100fb:	0f a1                	pop    %fs
   100fd:	07                   	pop    %es
   100fe:	1f                   	pop    %ds
   100ff:	61                   	popa   
   10100:	83 c4 08             	add    $0x8,%esp
   10103:	cf                   	iret   

00010104 <exception_handler_invalid_opcode>:
exception_handler invalid_opcode, 6, 0
   10104:	6a 00                	push   $0x0
   10106:	6a 06                	push   $0x6
   10108:	60                   	pusha  
   10109:	1e                   	push   %ds
   1010a:	06                   	push   %es
   1010b:	0f a0                	push   %fs
   1010d:	0f a8                	push   %gs
   1010f:	54                   	push   %esp
   10110:	e8 7f 28 00 00       	call   12994 <do_handler_invalid_opcode>
   10115:	83 c4 04             	add    $0x4,%esp
   10118:	0f a9                	pop    %gs
   1011a:	0f a1                	pop    %fs
   1011c:	07                   	pop    %es
   1011d:	1f                   	pop    %ds
   1011e:	61                   	popa   
   1011f:	83 c4 08             	add    $0x8,%esp
   10122:	cf                   	iret   

00010123 <exception_handler_device_unavailable>:
exception_handler device_unavailable, 7, 0
   10123:	6a 00                	push   $0x0
   10125:	6a 07                	push   $0x7
   10127:	60                   	pusha  
   10128:	1e                   	push   %ds
   10129:	06                   	push   %es
   1012a:	0f a0                	push   %fs
   1012c:	0f a8                	push   %gs
   1012e:	54                   	push   %esp
   1012f:	e8 7c 28 00 00       	call   129b0 <do_handler_device_unavailable>
   10134:	83 c4 04             	add    $0x4,%esp
   10137:	0f a9                	pop    %gs
   10139:	0f a1                	pop    %fs
   1013b:	07                   	pop    %es
   1013c:	1f                   	pop    %ds
   1013d:	61                   	popa   
   1013e:	83 c4 08             	add    $0x8,%esp
   10141:	cf                   	iret   

00010142 <exception_handler_double_fault>:
exception_handler double_fault, 8, 1
   10142:	6a 08                	push   $0x8
   10144:	60                   	pusha  
   10145:	1e                   	push   %ds
   10146:	06                   	push   %es
   10147:	0f a0                	push   %fs
   10149:	0f a8                	push   %gs
   1014b:	54                   	push   %esp
   1014c:	e8 7b 28 00 00       	call   129cc <do_handler_double_fault>
   10151:	83 c4 04             	add    $0x4,%esp
   10154:	0f a9                	pop    %gs
   10156:	0f a1                	pop    %fs
   10158:	07                   	pop    %es
   10159:	1f                   	pop    %ds
   1015a:	61                   	popa   
   1015b:	83 c4 08             	add    $0x8,%esp
   1015e:	cf                   	iret   

0001015f <exception_handler_invalid_tss>:
exception_handler invalid_tss, 10, 1
   1015f:	6a 0a                	push   $0xa
   10161:	60                   	pusha  
   10162:	1e                   	push   %ds
   10163:	06                   	push   %es
   10164:	0f a0                	push   %fs
   10166:	0f a8                	push   %gs
   10168:	54                   	push   %esp
   10169:	e8 7a 28 00 00       	call   129e8 <do_handler_invalid_tss>
   1016e:	83 c4 04             	add    $0x4,%esp
   10171:	0f a9                	pop    %gs
   10173:	0f a1                	pop    %fs
   10175:	07                   	pop    %es
   10176:	1f                   	pop    %ds
   10177:	61                   	popa   
   10178:	83 c4 08             	add    $0x8,%esp
   1017b:	cf                   	iret   

0001017c <exception_handler_segment_not_present>:
exception_handler segment_not_present, 11, 1
   1017c:	6a 0b                	push   $0xb
   1017e:	60                   	pusha  
   1017f:	1e                   	push   %ds
   10180:	06                   	push   %es
   10181:	0f a0                	push   %fs
   10183:	0f a8                	push   %gs
   10185:	54                   	push   %esp
   10186:	e8 79 28 00 00       	call   12a04 <do_handler_segment_not_present>
   1018b:	83 c4 04             	add    $0x4,%esp
   1018e:	0f a9                	pop    %gs
   10190:	0f a1                	pop    %fs
   10192:	07                   	pop    %es
   10193:	1f                   	pop    %ds
   10194:	61                   	popa   
   10195:	83 c4 08             	add    $0x8,%esp
   10198:	cf                   	iret   

00010199 <exception_handler_stack_segment_fault>:
exception_handler stack_segment_fault, 12, 1
   10199:	6a 0c                	push   $0xc
   1019b:	60                   	pusha  
   1019c:	1e                   	push   %ds
   1019d:	06                   	push   %es
   1019e:	0f a0                	push   %fs
   101a0:	0f a8                	push   %gs
   101a2:	54                   	push   %esp
   101a3:	e8 78 28 00 00       	call   12a20 <do_handler_stack_segment_fault>
   101a8:	83 c4 04             	add    $0x4,%esp
   101ab:	0f a9                	pop    %gs
   101ad:	0f a1                	pop    %fs
   101af:	07                   	pop    %es
   101b0:	1f                   	pop    %ds
   101b1:	61                   	popa   
   101b2:	83 c4 08             	add    $0x8,%esp
   101b5:	cf                   	iret   

000101b6 <exception_handler_general_protection>:
exception_handler general_protection, 13, 1
   101b6:	6a 0d                	push   $0xd
   101b8:	60                   	pusha  
   101b9:	1e                   	push   %ds
   101ba:	06                   	push   %es
   101bb:	0f a0                	push   %fs
   101bd:	0f a8                	push   %gs
   101bf:	54                   	push   %esp
   101c0:	e8 77 28 00 00       	call   12a3c <do_handler_general_protection>
   101c5:	83 c4 04             	add    $0x4,%esp
   101c8:	0f a9                	pop    %gs
   101ca:	0f a1                	pop    %fs
   101cc:	07                   	pop    %es
   101cd:	1f                   	pop    %ds
   101ce:	61                   	popa   
   101cf:	83 c4 08             	add    $0x8,%esp
   101d2:	cf                   	iret   

000101d3 <exception_handler_page_fault>:
exception_handler page_fault, 14, 1
   101d3:	6a 0e                	push   $0xe
   101d5:	60                   	pusha  
   101d6:	1e                   	push   %ds
   101d7:	06                   	push   %es
   101d8:	0f a0                	push   %fs
   101da:	0f a8                	push   %gs
   101dc:	54                   	push   %esp
   101dd:	e8 0f 29 00 00       	call   12af1 <do_handler_page_fault>
   101e2:	83 c4 04             	add    $0x4,%esp
   101e5:	0f a9                	pop    %gs
   101e7:	0f a1                	pop    %fs
   101e9:	07                   	pop    %es
   101ea:	1f                   	pop    %ds
   101eb:	61                   	popa   
   101ec:	83 c4 08             	add    $0x8,%esp
   101ef:	cf                   	iret   

000101f0 <exception_handler_fpu_error>:
exception_handler fpu_error, 16, 0
   101f0:	6a 00                	push   $0x0
   101f2:	6a 10                	push   $0x10
   101f4:	60                   	pusha  
   101f5:	1e                   	push   %ds
   101f6:	06                   	push   %es
   101f7:	0f a0                	push   %fs
   101f9:	0f a8                	push   %gs
   101fb:	54                   	push   %esp
   101fc:	e8 b4 29 00 00       	call   12bb5 <do_handler_fpu_error>
   10201:	83 c4 04             	add    $0x4,%esp
   10204:	0f a9                	pop    %gs
   10206:	0f a1                	pop    %fs
   10208:	07                   	pop    %es
   10209:	1f                   	pop    %ds
   1020a:	61                   	popa   
   1020b:	83 c4 08             	add    $0x8,%esp
   1020e:	cf                   	iret   

0001020f <exception_handler_alignment_check>:
exception_handler alignment_check, 17, 1
   1020f:	6a 11                	push   $0x11
   10211:	60                   	pusha  
   10212:	1e                   	push   %ds
   10213:	06                   	push   %es
   10214:	0f a0                	push   %fs
   10216:	0f a8                	push   %gs
   10218:	54                   	push   %esp
   10219:	e8 b3 29 00 00       	call   12bd1 <do_handler_alignment_check>
   1021e:	83 c4 04             	add    $0x4,%esp
   10221:	0f a9                	pop    %gs
   10223:	0f a1                	pop    %fs
   10225:	07                   	pop    %es
   10226:	1f                   	pop    %ds
   10227:	61                   	popa   
   10228:	83 c4 08             	add    $0x8,%esp
   1022b:	cf                   	iret   

0001022c <exception_handler_machine_check>:
exception_handler machine_check, 18, 0
   1022c:	6a 00                	push   $0x0
   1022e:	6a 12                	push   $0x12
   10230:	60                   	pusha  
   10231:	1e                   	push   %ds
   10232:	06                   	push   %es
   10233:	0f a0                	push   %fs
   10235:	0f a8                	push   %gs
   10237:	54                   	push   %esp
   10238:	e8 b0 29 00 00       	call   12bed <do_handler_machine_check>
   1023d:	83 c4 04             	add    $0x4,%esp
   10240:	0f a9                	pop    %gs
   10242:	0f a1                	pop    %fs
   10244:	07                   	pop    %es
   10245:	1f                   	pop    %ds
   10246:	61                   	popa   
   10247:	83 c4 08             	add    $0x8,%esp
   1024a:	cf                   	iret   

0001024b <exception_handler_smd_exception>:
exception_handler smd_exception, 19, 0
   1024b:	6a 00                	push   $0x0
   1024d:	6a 13                	push   $0x13
   1024f:	60                   	pusha  
   10250:	1e                   	push   %ds
   10251:	06                   	push   %es
   10252:	0f a0                	push   %fs
   10254:	0f a8                	push   %gs
   10256:	54                   	push   %esp
   10257:	e8 ad 29 00 00       	call   12c09 <do_handler_smd_exception>
   1025c:	83 c4 04             	add    $0x4,%esp
   1025f:	0f a9                	pop    %gs
   10261:	0f a1                	pop    %fs
   10263:	07                   	pop    %es
   10264:	1f                   	pop    %ds
   10265:	61                   	popa   
   10266:	83 c4 08             	add    $0x8,%esp
   10269:	cf                   	iret   

0001026a <exception_handler_virtual_exception>:
exception_handler virtual_exception, 20, 0
   1026a:	6a 00                	push   $0x0
   1026c:	6a 14                	push   $0x14
   1026e:	60                   	pusha  
   1026f:	1e                   	push   %ds
   10270:	06                   	push   %es
   10271:	0f a0                	push   %fs
   10273:	0f a8                	push   %gs
   10275:	54                   	push   %esp
   10276:	e8 aa 29 00 00       	call   12c25 <do_handler_virtual_exception>
   1027b:	83 c4 04             	add    $0x4,%esp
   1027e:	0f a9                	pop    %gs
   10280:	0f a1                	pop    %fs
   10282:	07                   	pop    %es
   10283:	1f                   	pop    %ds
   10284:	61                   	popa   
   10285:	83 c4 08             	add    $0x8,%esp
   10288:	cf                   	iret   

00010289 <exception_handler_time>:

exception_handler time,0x20,0
   10289:	6a 00                	push   $0x0
   1028b:	6a 20                	push   $0x20
   1028d:	60                   	pusha  
   1028e:	1e                   	push   %ds
   1028f:	06                   	push   %es
   10290:	0f a0                	push   %fs
   10292:	0f a8                	push   %gs
   10294:	54                   	push   %esp
   10295:	e8 b5 4a 00 00       	call   14d4f <do_handler_time>
   1029a:	83 c4 04             	add    $0x4,%esp
   1029d:	0f a9                	pop    %gs
   1029f:	0f a1                	pop    %fs
   102a1:	07                   	pop    %es
   102a2:	1f                   	pop    %ds
   102a3:	61                   	popa   
   102a4:	83 c4 08             	add    $0x8,%esp
   102a7:	cf                   	iret   

000102a8 <exception_handler_kbd>:
exception_handler kbd,0x21,0
   102a8:	6a 00                	push   $0x0
   102aa:	6a 21                	push   $0x21
   102ac:	60                   	pusha  
   102ad:	1e                   	push   %ds
   102ae:	06                   	push   %es
   102af:	0f a0                	push   %fs
   102b1:	0f a8                	push   %gs
   102b3:	54                   	push   %esp
   102b4:	e8 a0 49 00 00       	call   14c59 <do_handler_kbd>
   102b9:	83 c4 04             	add    $0x4,%esp
   102bc:	0f a9                	pop    %gs
   102be:	0f a1                	pop    %fs
   102c0:	07                   	pop    %es
   102c1:	1f                   	pop    %ds
   102c2:	61                   	popa   
   102c3:	83 c4 08             	add    $0x8,%esp
   102c6:	cf                   	iret   

000102c7 <exception_handler_ide_primary>:
exception_handler ide_primary, 0x2E, 0
   102c7:	6a 00                	push   $0x0
   102c9:	6a 2e                	push   $0x2e
   102cb:	60                   	pusha  
   102cc:	1e                   	push   %ds
   102cd:	06                   	push   %es
   102ce:	0f a0                	push   %fs
   102d0:	0f a8                	push   %gs
   102d2:	54                   	push   %esp
   102d3:	e8 f4 45 00 00       	call   148cc <do_handler_ide_primary>
   102d8:	83 c4 04             	add    $0x4,%esp
   102db:	0f a9                	pop    %gs
   102dd:	0f a1                	pop    %fs
   102df:	07                   	pop    %es
   102e0:	1f                   	pop    %ds
   102e1:	61                   	popa   
   102e2:	83 c4 08             	add    $0x8,%esp
   102e5:	cf                   	iret   

000102e6 <simple_switch>:


	.text
	.global simple_switch
simple_switch:
	movl 4(%esp), %eax   // 取from->stack
   102e6:	8b 44 24 04          	mov    0x4(%esp),%eax
	movl 8(%esp), %edx   // 取to->stack
   102ea:	8b 54 24 08          	mov    0x8(%esp),%edx

	// 保存前一任务的状态
	push %ebp
   102ee:	55                   	push   %ebp
	push %ebx
   102ef:	53                   	push   %ebx
	push %esi
   102f0:	56                   	push   %esi
	push %edi
   102f1:	57                   	push   %edi

	// 切换栈
	mov %esp, (%eax)    // from->stack = esp
   102f2:	89 20                	mov    %esp,(%eax)
  	mov %edx, %esp      // esp = to->stack
   102f4:	89 d4                	mov    %edx,%esp

	// 加载下一任务的栈
	pop %edi
   102f6:	5f                   	pop    %edi
	pop %esi
   102f7:	5e                   	pop    %esi
	pop %ebx
   102f8:	5b                   	pop    %ebx
	pop %ebp
   102f9:	5d                   	pop    %ebp
  	ret
   102fa:	c3                   	ret    

000102fb <exception_handler_syscall>:

.global exception_handler_syscall 
.extern do_handler_syscall

exception_handler_syscall:
	pusha
   102fb:	60                   	pusha  
	push %ds
   102fc:	1e                   	push   %ds
	push %es
   102fd:	06                   	push   %es
	push %fs
   102fe:	0f a0                	push   %fs
	push %gs
   10300:	0f a8                	push   %gs
	pushf
   10302:	9c                   	pushf  

	mov %esp, %eax
   10303:	89 e0                	mov    %esp,%eax
	push %eax
   10305:	50                   	push   %eax
	call do_handler_syscall
   10306:	e8 0d 0c 00 00       	call   10f18 <do_handler_syscall>
	add $4, %esp
   1030b:	83 c4 04             	add    $0x4,%esp

	popf
   1030e:	9d                   	popf   
	pop %gs
   1030f:	0f a9                	pop    %gs
	pop %fs
   10311:	0f a1                	pop    %fs
	pop %es
   10313:	07                   	pop    %es
	pop %ds
   10314:	1f                   	pop    %ds
	popa
   10315:	61                   	popa   
	
   10316:	ca 14 00             	lret   $0x14

00010319 <list_node_prev>:
{
    node->next = node->prev = (list_node_t *)0;
}

static list_node_t *list_node_prev(list_node_t *node)
{
   10319:	55                   	push   %ebp
   1031a:	89 e5                	mov    %esp,%ebp
    return node->prev;
   1031c:	8b 45 08             	mov    0x8(%ebp),%eax
   1031f:	8b 40 04             	mov    0x4(%eax),%eax
}
   10322:	5d                   	pop    %ebp
   10323:	c3                   	ret    

00010324 <list_node_next>:

static list_node_t *list_node_next(list_node_t *node)
{
   10324:	55                   	push   %ebp
   10325:	89 e5                	mov    %esp,%ebp
    return node->next;
   10327:	8b 45 08             	mov    0x8(%ebp),%eax
   1032a:	8b 00                	mov    (%eax),%eax
}
   1032c:	5d                   	pop    %ebp
   1032d:	c3                   	ret    

0001032e <down2>:
    char pad_char; // 填充字符
    int is_zero;   // 是否补零
} fmt_spec_t;

static inline uint32_t down2(uint32_t size, uint32_t bound)
{
   1032e:	55                   	push   %ebp
   1032f:	89 e5                	mov    %esp,%ebp
    return size & ~(bound - 1);
   10331:	8b 45 0c             	mov    0xc(%ebp),%eax
   10334:	f7 d8                	neg    %eax
   10336:	23 45 08             	and    0x8(%ebp),%eax
}
   10339:	5d                   	pop    %ebp
   1033a:	c3                   	ret    

0001033b <up2>:

static inline uint32_t up2(uint32_t size, uint32_t bound)
{
   1033b:	55                   	push   %ebp
   1033c:	89 e5                	mov    %esp,%ebp
    return (size + bound - 1) & ~(bound - 1);
   1033e:	8b 55 08             	mov    0x8(%ebp),%edx
   10341:	8b 45 0c             	mov    0xc(%ebp),%eax
   10344:	01 d0                	add    %edx,%eax
   10346:	8d 50 ff             	lea    -0x1(%eax),%edx
   10349:	8b 45 0c             	mov    0xc(%ebp),%eax
   1034c:	f7 d8                	neg    %eax
   1034e:	21 d0                	and    %edx,%eax
}
   10350:	5d                   	pop    %ebp
   10351:	c3                   	ret    

00010352 <write_cr3>:
 * @brief 写cr3
 *
 * @param v
 */
static inline void write_cr3(uint32_t v)
{
   10352:	55                   	push   %ebp
   10353:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("mov %[v], %%cr3" ::[v] "r"(v));
   10355:	8b 45 08             	mov    0x8(%ebp),%eax
   10358:	0f 22 d8             	mov    %eax,%cr3
}
   1035b:	90                   	nop
   1035c:	5d                   	pop    %ebp
   1035d:	c3                   	ret    

0001035e <mmu_set_page_dir>:
} pte_t;

#pragma pack()

static inline void mmu_set_page_dir(uint32_t page_dir)
{
   1035e:	55                   	push   %ebp
   1035f:	89 e5                	mov    %esp,%ebp
    write_cr3(page_dir);
   10361:	ff 75 08             	pushl  0x8(%ebp)
   10364:	e8 e9 ff ff ff       	call   10352 <write_cr3>
   10369:	83 c4 04             	add    $0x4,%esp
}
   1036c:	90                   	nop
   1036d:	c9                   	leave  
   1036e:	c3                   	ret    

0001036f <pde_index>:

static inline uint32_t pde_index(uint32_t vaddr)
{
   1036f:	55                   	push   %ebp
   10370:	89 e5                	mov    %esp,%ebp
    return (vaddr >> 22);
   10372:	8b 45 08             	mov    0x8(%ebp),%eax
   10375:	c1 e8 16             	shr    $0x16,%eax
}
   10378:	5d                   	pop    %ebp
   10379:	c3                   	ret    

0001037a <pte_index>:

static inline uint32_t pte_index(uint32_t vaddr)
{
   1037a:	55                   	push   %ebp
   1037b:	89 e5                	mov    %esp,%ebp
    return (vaddr >> 12) & 0x3FF;
   1037d:	8b 45 08             	mov    0x8(%ebp),%eax
   10380:	c1 e8 0c             	shr    $0xc,%eax
   10383:	25 ff 03 00 00       	and    $0x3ff,%eax
}
   10388:	5d                   	pop    %ebp
   10389:	c3                   	ret    

0001038a <pde_paddr>:

static inline uint32_t pde_paddr(pde_t *pde)
{
   1038a:	55                   	push   %ebp
   1038b:	89 e5                	mov    %esp,%ebp
    return pde->phy_pt_addr << 12;
   1038d:	8b 45 08             	mov    0x8(%ebp),%eax
   10390:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   10394:	c0 ea 04             	shr    $0x4,%dl
   10397:	0f b6 d2             	movzbl %dl,%edx
   1039a:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   1039e:	c1 e1 04             	shl    $0x4,%ecx
   103a1:	09 ca                	or     %ecx,%edx
   103a3:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   103a7:	c1 e0 0c             	shl    $0xc,%eax
   103aa:	09 d0                	or     %edx,%eax
   103ac:	c1 e0 0c             	shl    $0xc,%eax
}
   103af:	5d                   	pop    %ebp
   103b0:	c3                   	ret    

000103b1 <pte_paddr>:

static inline uint32_t pte_paddr(pte_t *pte)
{
   103b1:	55                   	push   %ebp
   103b2:	89 e5                	mov    %esp,%ebp
    return pte->phy_page_addr << 12;
   103b4:	8b 45 08             	mov    0x8(%ebp),%eax
   103b7:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   103bb:	c0 ea 04             	shr    $0x4,%dl
   103be:	0f b6 d2             	movzbl %dl,%edx
   103c1:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   103c5:	c1 e1 04             	shl    $0x4,%ecx
   103c8:	09 ca                	or     %ecx,%edx
   103ca:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   103ce:	c1 e0 0c             	shl    $0xc,%eax
   103d1:	09 d0                	or     %edx,%eax
   103d3:	c1 e0 0c             	shl    $0xc,%eax
}
   103d6:	5d                   	pop    %ebp
   103d7:	c3                   	ret    

000103d8 <get_pte_perm>:

static inline uint32_t get_pte_perm(pte_t *pte)
{
   103d8:	55                   	push   %ebp
   103d9:	89 e5                	mov    %esp,%ebp
    return (pte->v & 0x1FF);
   103db:	8b 45 08             	mov    0x8(%ebp),%eax
   103de:	8b 00                	mov    (%eax),%eax
   103e0:	25 ff 01 00 00       	and    $0x1ff,%eax
}
   103e5:	5d                   	pop    %ebp
   103e6:	c3                   	ret    

000103e7 <addr_alloc_init>:
/**
 * @brief 初始化地址分配结构
 * 以下不检查start和size的页边界，由上层调用者检查
 */
static void addr_alloc_init(addr_alloc_t *addr_alloc, uint8_t *bits, uint32_t start, uint32_t size, uint32_t page_size)
{
   103e7:	55                   	push   %ebp
   103e8:	89 e5                	mov    %esp,%ebp
   103ea:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&addr_alloc->mutex);
   103ed:	8b 45 08             	mov    0x8(%ebp),%eax
   103f0:	83 ec 0c             	sub    $0xc,%esp
   103f3:	50                   	push   %eax
   103f4:	e8 4c 5f 00 00       	call   16345 <mutex_init>
   103f9:	83 c4 10             	add    $0x10,%esp
    addr_alloc->start = start;
   103fc:	8b 45 08             	mov    0x8(%ebp),%eax
   103ff:	8b 55 10             	mov    0x10(%ebp),%edx
   10402:	89 50 1c             	mov    %edx,0x1c(%eax)
    addr_alloc->size = size;
   10405:	8b 45 08             	mov    0x8(%ebp),%eax
   10408:	8b 55 14             	mov    0x14(%ebp),%edx
   1040b:	89 50 20             	mov    %edx,0x20(%eax)
    addr_alloc->page_size = page_size;
   1040e:	8b 45 08             	mov    0x8(%ebp),%eax
   10411:	8b 55 18             	mov    0x18(%ebp),%edx
   10414:	89 50 24             	mov    %edx,0x24(%eax)
    bitmap_init(&addr_alloc->bitmap, bits, size / page_size, 0);
   10417:	8b 45 14             	mov    0x14(%ebp),%eax
   1041a:	ba 00 00 00 00       	mov    $0x0,%edx
   1041f:	f7 75 18             	divl   0x18(%ebp)
   10422:	89 c2                	mov    %eax,%edx
   10424:	8b 45 08             	mov    0x8(%ebp),%eax
   10427:	83 c0 14             	add    $0x14,%eax
   1042a:	6a 00                	push   $0x0
   1042c:	52                   	push   %edx
   1042d:	ff 75 0c             	pushl  0xc(%ebp)
   10430:	50                   	push   %eax
   10431:	e8 07 62 00 00       	call   1663d <bitmap_init>
   10436:	83 c4 10             	add    $0x10,%esp
}
   10439:	90                   	nop
   1043a:	c9                   	leave  
   1043b:	c3                   	ret    

0001043c <addr_alloc_page>:

/**
 * @brief 分配多页内存
 */
static uint32_t addr_alloc_page(addr_alloc_t *addr_alloc, int page_count)
{
   1043c:	55                   	push   %ebp
   1043d:	89 e5                	mov    %esp,%ebp
   1043f:	83 ec 18             	sub    $0x18,%esp
    uint32_t addr = 0;
   10442:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    mutex_lock(&addr_alloc->mutex);
   10449:	8b 45 08             	mov    0x8(%ebp),%eax
   1044c:	83 ec 0c             	sub    $0xc,%esp
   1044f:	50                   	push   %eax
   10450:	e8 1e 5f 00 00       	call   16373 <mutex_lock>
   10455:	83 c4 10             	add    $0x10,%esp

    int page_index = bitmap_alloc_nbits(&addr_alloc->bitmap, 0, page_count);
   10458:	8b 45 08             	mov    0x8(%ebp),%eax
   1045b:	83 c0 14             	add    $0x14,%eax
   1045e:	83 ec 04             	sub    $0x4,%esp
   10461:	ff 75 0c             	pushl  0xc(%ebp)
   10464:	6a 00                	push   $0x0
   10466:	50                   	push   %eax
   10467:	e8 4d 63 00 00       	call   167b9 <bitmap_alloc_nbits>
   1046c:	83 c4 10             	add    $0x10,%esp
   1046f:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (page_index >= 0)
   10472:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10476:	78 17                	js     1048f <addr_alloc_page+0x53>
    {
        addr = addr_alloc->start + page_index * addr_alloc->page_size;
   10478:	8b 45 08             	mov    0x8(%ebp),%eax
   1047b:	8b 50 1c             	mov    0x1c(%eax),%edx
   1047e:	8b 45 08             	mov    0x8(%ebp),%eax
   10481:	8b 48 24             	mov    0x24(%eax),%ecx
   10484:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10487:	0f af c1             	imul   %ecx,%eax
   1048a:	01 d0                	add    %edx,%eax
   1048c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    mutex_unlock(&addr_alloc->mutex);
   1048f:	8b 45 08             	mov    0x8(%ebp),%eax
   10492:	83 ec 0c             	sub    $0xc,%esp
   10495:	50                   	push   %eax
   10496:	e8 6f 5f 00 00       	call   1640a <mutex_unlock>
   1049b:	83 c4 10             	add    $0x10,%esp
    return addr;
   1049e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   104a1:	c9                   	leave  
   104a2:	c3                   	ret    

000104a3 <addr_free_page>:

/**
 * @brief 释放多页内存
 */
static void addr_free_page(addr_alloc_t *addr_alloc, uint32_t addr, int page_count)
{
   104a3:	55                   	push   %ebp
   104a4:	89 e5                	mov    %esp,%ebp
   104a6:	53                   	push   %ebx
   104a7:	83 ec 14             	sub    $0x14,%esp
    mutex_lock(&addr_alloc->mutex);
   104aa:	8b 45 08             	mov    0x8(%ebp),%eax
   104ad:	83 ec 0c             	sub    $0xc,%esp
   104b0:	50                   	push   %eax
   104b1:	e8 bd 5e 00 00       	call   16373 <mutex_lock>
   104b6:	83 c4 10             	add    $0x10,%esp

    int page_index = (addr - addr_alloc->start) / addr_alloc->page_size;
   104b9:	8b 45 08             	mov    0x8(%ebp),%eax
   104bc:	8b 40 1c             	mov    0x1c(%eax),%eax
   104bf:	8b 55 0c             	mov    0xc(%ebp),%edx
   104c2:	89 d1                	mov    %edx,%ecx
   104c4:	29 c1                	sub    %eax,%ecx
   104c6:	8b 45 08             	mov    0x8(%ebp),%eax
   104c9:	8b 58 24             	mov    0x24(%eax),%ebx
   104cc:	89 c8                	mov    %ecx,%eax
   104ce:	ba 00 00 00 00       	mov    $0x0,%edx
   104d3:	f7 f3                	div    %ebx
   104d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bitmap_set_bit(&addr_alloc->bitmap, page_index, page_count, 0);
   104d8:	8b 45 08             	mov    0x8(%ebp),%eax
   104db:	83 c0 14             	add    $0x14,%eax
   104de:	6a 00                	push   $0x0
   104e0:	ff 75 10             	pushl  0x10(%ebp)
   104e3:	ff 75 f4             	pushl  -0xc(%ebp)
   104e6:	50                   	push   %eax
   104e7:	e8 de 61 00 00       	call   166ca <bitmap_set_bit>
   104ec:	83 c4 10             	add    $0x10,%esp

    mutex_unlock(&addr_alloc->mutex);
   104ef:	8b 45 08             	mov    0x8(%ebp),%eax
   104f2:	83 ec 0c             	sub    $0xc,%esp
   104f5:	50                   	push   %eax
   104f6:	e8 0f 5f 00 00       	call   1640a <mutex_unlock>
   104fb:	83 c4 10             	add    $0x10,%esp
}
   104fe:	90                   	nop
   104ff:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10502:	c9                   	leave  
   10503:	c3                   	ret    

00010504 <show_mem_info>:

static void show_mem_info(boot_info_t *boot_info)
{
   10504:	55                   	push   %ebp
   10505:	89 e5                	mov    %esp,%ebp
   10507:	83 ec 18             	sub    $0x18,%esp
    // log_printf("mem region:");
    for (int i = 0; i < boot_info->ram_region_count; i++)
   1050a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10511:	eb 29                	jmp    1053c <show_mem_info+0x38>
    {
        log_printf("[%d]: 0x%x - 0x%x", i,
   10513:	8b 45 08             	mov    0x8(%ebp),%eax
   10516:	8b 55 f4             	mov    -0xc(%ebp),%edx
   10519:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
   1051d:	8b 45 08             	mov    0x8(%ebp),%eax
   10520:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   10523:	8b 04 c8             	mov    (%eax,%ecx,8),%eax
   10526:	52                   	push   %edx
   10527:	50                   	push   %eax
   10528:	ff 75 f4             	pushl  -0xc(%ebp)
   1052b:	68 c0 70 01 00       	push   $0x170c0
   10530:	e8 ca 6a 00 00       	call   16fff <log_printf>
   10535:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < boot_info->ram_region_count; i++)
   10538:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1053c:	8b 45 08             	mov    0x8(%ebp),%eax
   1053f:	8b 40 50             	mov    0x50(%eax),%eax
   10542:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   10545:	7c cc                	jl     10513 <show_mem_info+0xf>
                   boot_info->ram_region_cfg[i].start,
                   boot_info->ram_region_cfg[i].size);
    }
}
   10547:	90                   	nop
   10548:	c9                   	leave  
   10549:	c3                   	ret    

0001054a <total_mem_size>:

static int total_mem_size(boot_info_t *boot_info)
{
   1054a:	55                   	push   %ebp
   1054b:	89 e5                	mov    %esp,%ebp
   1054d:	83 ec 10             	sub    $0x10,%esp
    uint32_t total_size = 0;
   10550:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for (int i = 0; i < boot_info->ram_region_count; i++)
   10557:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1055e:	eb 11                	jmp    10571 <total_mem_size+0x27>
    {
        total_size += boot_info->ram_region_cfg[i].size;
   10560:	8b 45 08             	mov    0x8(%ebp),%eax
   10563:	8b 55 f8             	mov    -0x8(%ebp),%edx
   10566:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
   1056a:	01 45 fc             	add    %eax,-0x4(%ebp)
    for (int i = 0; i < boot_info->ram_region_count; i++)
   1056d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   10571:	8b 45 08             	mov    0x8(%ebp),%eax
   10574:	8b 40 50             	mov    0x50(%eax),%eax
   10577:	39 45 f8             	cmp    %eax,-0x8(%ebp)
   1057a:	7c e4                	jl     10560 <total_mem_size+0x16>
    }
    return total_size;
   1057c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1057f:	c9                   	leave  
   10580:	c3                   	ret    

00010581 <find_pte>:

pte_t *find_pte(pde_t *page_dir, uint32_t vaddr, int alloc)
{
   10581:	55                   	push   %ebp
   10582:	89 e5                	mov    %esp,%ebp
   10584:	83 ec 18             	sub    $0x18,%esp
    pte_t *page_table;
    pde_t *pde = page_dir + pde_index(vaddr);
   10587:	ff 75 0c             	pushl  0xc(%ebp)
   1058a:	e8 e0 fd ff ff       	call   1036f <pde_index>
   1058f:	83 c4 04             	add    $0x4,%esp
   10592:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10599:	8b 45 08             	mov    0x8(%ebp),%eax
   1059c:	01 d0                	add    %edx,%eax
   1059e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (pde->present)
   105a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105a4:	0f b6 00             	movzbl (%eax),%eax
   105a7:	83 e0 01             	and    $0x1,%eax
   105aa:	84 c0                	test   %al,%al
   105ac:	74 10                	je     105be <find_pte+0x3d>
    {
        page_table = (pte_t *)pde_paddr(pde);
   105ae:	ff 75 f0             	pushl  -0x10(%ebp)
   105b1:	e8 d4 fd ff ff       	call   1038a <pde_paddr>
   105b6:	83 c4 04             	add    $0x4,%esp
   105b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
   105bc:	eb 57                	jmp    10615 <find_pte+0x94>
    }
    else
    {
        if (alloc == 0)
   105be:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   105c2:	75 07                	jne    105cb <find_pte+0x4a>
        {
            return (pte_t *)0;
   105c4:	b8 00 00 00 00       	mov    $0x0,%eax
   105c9:	eb 64                	jmp    1062f <find_pte+0xae>
        }
        uint32_t pg_paddr = addr_alloc_page(&paddr_alloc, 1);
   105cb:	83 ec 08             	sub    $0x8,%esp
   105ce:	6a 01                	push   $0x1
   105d0:	68 00 a0 01 00       	push   $0x1a000
   105d5:	e8 62 fe ff ff       	call   1043c <addr_alloc_page>
   105da:	83 c4 10             	add    $0x10,%esp
   105dd:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if (pg_paddr == 0)
   105e0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   105e4:	75 07                	jne    105ed <find_pte+0x6c>
        {
            return (pte_t *)0;
   105e6:	b8 00 00 00 00       	mov    $0x0,%eax
   105eb:	eb 42                	jmp    1062f <find_pte+0xae>
        }

        // 设置为用户可读写，将被pte中设置所覆盖
        pde->v = pg_paddr | PDE_P | PDE_W | PDE_U;
   105ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
   105f0:	83 c8 07             	or     $0x7,%eax
   105f3:	89 c2                	mov    %eax,%edx
   105f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105f8:	89 10                	mov    %edx,(%eax)
        // 为物理页表绑定虚拟地址的映射，这样下面就可以计算出虚拟地址了
        // kernel_pg_last[pde_index(vaddr)].v = pg_paddr | PTE_P | PTE_W;

        // 清空页表，防止出现异常
        // 这里虚拟地址和物理地址一一映射，所以直接写入
        page_table = (pte_t *)(pg_paddr);
   105fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
   105fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
        kernel_memset(page_table, 0, MEM_PAGE_SIZE);
   10600:	83 ec 04             	sub    $0x4,%esp
   10603:	68 00 10 00 00       	push   $0x1000
   10608:	6a 00                	push   $0x0
   1060a:	ff 75 f4             	pushl  -0xc(%ebp)
   1060d:	e8 11 64 00 00       	call   16a23 <kernel_memset>
   10612:	83 c4 10             	add    $0x10,%esp
    }

    return page_table + pte_index(vaddr);
   10615:	83 ec 0c             	sub    $0xc,%esp
   10618:	ff 75 0c             	pushl  0xc(%ebp)
   1061b:	e8 5a fd ff ff       	call   1037a <pte_index>
   10620:	83 c4 10             	add    $0x10,%esp
   10623:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1062a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1062d:	01 d0                	add    %edx,%eax
}
   1062f:	c9                   	leave  
   10630:	c3                   	ret    

00010631 <memory_create_map>:

/**
 * @brief 将指定的地址空间进行一页的映射
 */
int memory_create_map(pde_t *page_dir, uint32_t vaddr, uint32_t paddr, int count, uint32_t perm)
{
   10631:	55                   	push   %ebp
   10632:	89 e5                	mov    %esp,%ebp
   10634:	83 ec 18             	sub    $0x18,%esp
    for (int i = 0; i < count; i++)
   10637:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1063e:	eb 6e                	jmp    106ae <memory_create_map+0x7d>
    {
        pte_t *pte = find_pte(page_dir, vaddr, 1);
   10640:	83 ec 04             	sub    $0x4,%esp
   10643:	6a 01                	push   $0x1
   10645:	ff 75 0c             	pushl  0xc(%ebp)
   10648:	ff 75 08             	pushl  0x8(%ebp)
   1064b:	e8 31 ff ff ff       	call   10581 <find_pte>
   10650:	83 c4 10             	add    $0x10,%esp
   10653:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (pte == (pte_t *)0)
   10656:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1065a:	75 07                	jne    10663 <memory_create_map+0x32>
        {
            return -1;
   1065c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10661:	eb 53                	jmp    106b6 <memory_create_map+0x85>
        }

        // 创建映射的时候，这条pte应当是不存在的。
        // 如果存在，说明可能有问题
        // log_printf("\tpte addr: 0x%x", (uint32_t)pte);
        ASSERT(pte->present == 0);
   10663:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10666:	0f b6 00             	movzbl (%eax),%eax
   10669:	83 e0 01             	and    $0x1,%eax
   1066c:	84 c0                	test   %al,%al
   1066e:	74 1c                	je     1068c <memory_create_map+0x5b>
   10670:	68 d2 70 01 00       	push   $0x170d2
   10675:	68 00 72 01 00       	push   $0x17200
   1067a:	68 83 00 00 00       	push   $0x83
   1067f:	68 e4 70 01 00       	push   $0x170e4
   10684:	e8 7d 66 00 00       	call   16d06 <pannic>
   10689:	83 c4 10             	add    $0x10,%esp

        pte->v = paddr | perm | PTE_P;
   1068c:	8b 45 10             	mov    0x10(%ebp),%eax
   1068f:	0b 45 18             	or     0x18(%ebp),%eax
   10692:	83 c8 01             	or     $0x1,%eax
   10695:	89 c2                	mov    %eax,%edx
   10697:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1069a:	89 10                	mov    %edx,(%eax)

        vaddr += MEM_PAGE_SIZE;
   1069c:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
        paddr += MEM_PAGE_SIZE;
   106a3:	81 45 10 00 10 00 00 	addl   $0x1000,0x10(%ebp)
    for (int i = 0; i < count; i++)
   106aa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   106ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
   106b1:	3b 45 14             	cmp    0x14(%ebp),%eax
   106b4:	7c 8a                	jl     10640 <memory_create_map+0xf>
    }
}
   106b6:	c9                   	leave  
   106b7:	c3                   	ret    

000106b8 <create_kernel_table>:
void create_kernel_table(void)
{
   106b8:	55                   	push   %ebp
   106b9:	89 e5                	mov    %esp,%ebp
   106bb:	83 ec 28             	sub    $0x28,%esp
        {s_data, (void *)MEM_EBDA_START, s_data, PTE_W},
        {(void *) CONSOLE_DISP_ADDR, (void *)CONSOLE_DISP_END, (void *)CONSOLE_DISP_ADDR, PTE_W},
        {(void *)MEM_EXT_START, (void *)MEM_EXT_END, (void *)MEM_EXT_START, PTE_W},
    };
    // 清空页目录表
    kernel_memset(kernel_page_dir, 0, sizeof(kernel_page_dir));
   106be:	83 ec 04             	sub    $0x4,%esp
   106c1:	68 00 10 00 00       	push   $0x1000
   106c6:	6a 00                	push   $0x0
   106c8:	68 00 b0 01 00       	push   $0x1b000
   106cd:	e8 51 63 00 00       	call   16a23 <kernel_memset>
   106d2:	83 c4 10             	add    $0x10,%esp

    for (int i = 0; i < sizeof(kernel_map) / sizeof(memory_map_t); i++)
   106d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   106dc:	e9 8f 00 00 00       	jmp    10770 <create_kernel_table+0xb8>
    {
        // 可能有多个页，建立多个页的配置
        // 简化起见，不考虑4M的情况
        memory_map_t *map = kernel_map + i;
   106e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   106e4:	c1 e0 04             	shl    $0x4,%eax
   106e7:	05 00 90 01 00       	add    $0x19000,%eax
   106ec:	89 45 f0             	mov    %eax,-0x10(%ebp)

        uint32_t v_start = down2((uint32_t)map->vstart, MEM_PAGE_SIZE);
   106ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106f2:	8b 00                	mov    (%eax),%eax
   106f4:	83 ec 08             	sub    $0x8,%esp
   106f7:	68 00 10 00 00       	push   $0x1000
   106fc:	50                   	push   %eax
   106fd:	e8 2c fc ff ff       	call   1032e <down2>
   10702:	83 c4 10             	add    $0x10,%esp
   10705:	89 45 ec             	mov    %eax,-0x14(%ebp)

        uint32_t vend = up2((uint32_t)map->vend, MEM_PAGE_SIZE);
   10708:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1070b:	8b 40 04             	mov    0x4(%eax),%eax
   1070e:	83 ec 08             	sub    $0x8,%esp
   10711:	68 00 10 00 00       	push   $0x1000
   10716:	50                   	push   %eax
   10717:	e8 1f fc ff ff       	call   1033b <up2>
   1071c:	83 c4 10             	add    $0x10,%esp
   1071f:	89 45 e8             	mov    %eax,-0x18(%ebp)

        uint32_t paddr = down2((uint32_t)map->pstart, MEM_PAGE_SIZE);
   10722:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10725:	8b 40 08             	mov    0x8(%eax),%eax
   10728:	83 ec 08             	sub    $0x8,%esp
   1072b:	68 00 10 00 00       	push   $0x1000
   10730:	50                   	push   %eax
   10731:	e8 f8 fb ff ff       	call   1032e <down2>
   10736:	83 c4 10             	add    $0x10,%esp
   10739:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        int page_count = (vend - v_start) / MEM_PAGE_SIZE;
   1073c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1073f:	2b 45 ec             	sub    -0x14(%ebp),%eax
   10742:	c1 e8 0c             	shr    $0xc,%eax
   10745:	89 45 e0             	mov    %eax,-0x20(%ebp)

        memory_create_map(kernel_page_dir, v_start, (uint32_t)map->pstart, page_count, map->perm);
   10748:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1074b:	8b 40 0c             	mov    0xc(%eax),%eax
   1074e:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10751:	8b 52 08             	mov    0x8(%edx),%edx
   10754:	83 ec 0c             	sub    $0xc,%esp
   10757:	50                   	push   %eax
   10758:	ff 75 e0             	pushl  -0x20(%ebp)
   1075b:	52                   	push   %edx
   1075c:	ff 75 ec             	pushl  -0x14(%ebp)
   1075f:	68 00 b0 01 00       	push   $0x1b000
   10764:	e8 c8 fe ff ff       	call   10631 <memory_create_map>
   10769:	83 c4 20             	add    $0x20,%esp
    for (int i = 0; i < sizeof(kernel_map) / sizeof(memory_map_t); i++)
   1076c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10770:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10773:	83 f8 04             	cmp    $0x4,%eax
   10776:	0f 86 65 ff ff ff    	jbe    106e1 <create_kernel_table+0x29>
    }
}
   1077c:	90                   	nop
   1077d:	c9                   	leave  
   1077e:	c3                   	ret    

0001077f <memory_init>:
 * 该函数的主要任务：
 * 1、初始化物理内存分配器：将所有物理内存管理起来. 在1MB内存中分配物理位图
 * 2、重新创建内核页表：原loader中创建的页表已经不再合适
 */
void memory_init(boot_info_t *boot_info)
{
   1077f:	55                   	push   %ebp
   10780:	89 e5                	mov    %esp,%ebp
   10782:	83 ec 18             	sub    $0x18,%esp

    // log_printf("mem init.");
    // show_mem_info(boot_info);

    // 在内核数据后面放物理页位图
    uint8_t *mem_free = (uint8_t *)&mem_free_start; // 2022年-10-1 经同学反馈，发现这里有点bug，改了下
   10785:	c7 45 f4 31 a2 05 00 	movl   $0x5a231,-0xc(%ebp)

    // 计算1MB以上空间的空闲内存容量，并对齐的页边界
    uint32_t mem_up1MB_free = total_mem_size(boot_info) - MEM_EXT_START;
   1078c:	ff 75 08             	pushl  0x8(%ebp)
   1078f:	e8 b6 fd ff ff       	call   1054a <total_mem_size>
   10794:	83 c4 04             	add    $0x4,%esp
   10797:	2d 00 00 10 00       	sub    $0x100000,%eax
   1079c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    mem_up1MB_free = down2(mem_up1MB_free, MEM_PAGE_SIZE); // 对齐到4KB页
   1079f:	68 00 10 00 00       	push   $0x1000
   107a4:	ff 75 f0             	pushl  -0x10(%ebp)
   107a7:	e8 82 fb ff ff       	call   1032e <down2>
   107ac:	83 c4 08             	add    $0x8,%esp
   107af:	89 45 f0             	mov    %eax,-0x10(%ebp)
    // log_printf("Free memory: 0x%x, size: 0x%x", MEM_EXT_START, mem_up1MB_free);

    // 4GB大小需要总共4*1024*1024*1024/4096/8=128KB的位图, 使用低1MB的RAM空间中足够
    // 该部分的内存仅跟在mem_free_start开始放置
    addr_alloc_init(&paddr_alloc, mem_free, MEM_EXT_START, mem_up1MB_free, MEM_PAGE_SIZE);
   107b2:	83 ec 0c             	sub    $0xc,%esp
   107b5:	68 00 10 00 00       	push   $0x1000
   107ba:	ff 75 f0             	pushl  -0x10(%ebp)
   107bd:	68 00 00 10 00       	push   $0x100000
   107c2:	ff 75 f4             	pushl  -0xc(%ebp)
   107c5:	68 00 a0 01 00       	push   $0x1a000
   107ca:	e8 18 fc ff ff       	call   103e7 <addr_alloc_init>
   107cf:	83 c4 20             	add    $0x20,%esp
    mem_free += bitmap_byte_count(paddr_alloc.size / MEM_PAGE_SIZE);
   107d2:	a1 20 a0 01 00       	mov    0x1a020,%eax
   107d7:	c1 e8 0c             	shr    $0xc,%eax
   107da:	83 ec 0c             	sub    $0xc,%esp
   107dd:	50                   	push   %eax
   107de:	e8 44 5e 00 00       	call   16627 <bitmap_byte_count>
   107e3:	83 c4 10             	add    $0x10,%esp
   107e6:	01 45 f4             	add    %eax,-0xc(%ebp)

    // 到这里，mem_free应该比EBDA地址要小
    ASSERT(mem_free < (uint8_t *)MEM_EBDA_START);
   107e9:	81 7d f4 ff ff 07 00 	cmpl   $0x7ffff,-0xc(%ebp)
   107f0:	76 1c                	jbe    1080e <memory_init+0x8f>
   107f2:	68 1c 71 01 00       	push   $0x1711c
   107f7:	68 14 72 01 00       	push   $0x17214
   107fc:	68 c6 00 00 00       	push   $0xc6
   10801:	68 e4 70 01 00       	push   $0x170e4
   10806:	e8 fb 64 00 00       	call   16d06 <pannic>
   1080b:	83 c4 10             	add    $0x10,%esp

    create_kernel_table();
   1080e:	e8 a5 fe ff ff       	call   106b8 <create_kernel_table>

    mmu_set_page_dir((uint32_t)kernel_page_dir);
   10813:	b8 00 b0 01 00       	mov    $0x1b000,%eax
   10818:	83 ec 0c             	sub    $0xc,%esp
   1081b:	50                   	push   %eax
   1081c:	e8 3d fb ff ff       	call   1035e <mmu_set_page_dir>
   10821:	83 c4 10             	add    $0x10,%esp
}
   10824:	90                   	nop
   10825:	c9                   	leave  
   10826:	c3                   	ret    

00010827 <memory_create_uvm>:

uint32_t memory_create_uvm()
{
   10827:	55                   	push   %ebp
   10828:	89 e5                	mov    %esp,%ebp
   1082a:	83 ec 18             	sub    $0x18,%esp
    pde_t *page_dir = (pde_t *)addr_alloc_page(&paddr_alloc, 1);
   1082d:	83 ec 08             	sub    $0x8,%esp
   10830:	6a 01                	push   $0x1
   10832:	68 00 a0 01 00       	push   $0x1a000
   10837:	e8 00 fc ff ff       	call   1043c <addr_alloc_page>
   1083c:	83 c4 10             	add    $0x10,%esp
   1083f:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (page_dir == 0)
   10842:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10846:	75 07                	jne    1084f <memory_create_uvm+0x28>
    {
        return 0;
   10848:	b8 00 00 00 00       	mov    $0x0,%eax
   1084d:	eb 5b                	jmp    108aa <memory_create_uvm+0x83>
    }

    kernel_memset((void *)page_dir, 0, MEM_PAGE_SIZE);
   1084f:	83 ec 04             	sub    $0x4,%esp
   10852:	68 00 10 00 00       	push   $0x1000
   10857:	6a 00                	push   $0x0
   10859:	ff 75 f0             	pushl  -0x10(%ebp)
   1085c:	e8 c2 61 00 00       	call   16a23 <kernel_memset>
   10861:	83 c4 10             	add    $0x10,%esp

    // 复制整个内核空间的页目录项，以便与其它进程共享内核空间
    // 用户空间的内存映射暂不处理，等加载程序时创建
    uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE);
   10864:	83 ec 0c             	sub    $0xc,%esp
   10867:	68 00 00 00 80       	push   $0x80000000
   1086c:	e8 fe fa ff ff       	call   1036f <pde_index>
   10871:	83 c4 10             	add    $0x10,%esp
   10874:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < user_pde_start; i++)
   10877:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1087e:	eb 1f                	jmp    1089f <memory_create_uvm+0x78>
    {
        page_dir[i].v = kernel_page_dir[i].v;
   10880:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10883:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1088a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1088d:	01 c2                	add    %eax,%edx
   1088f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10892:	8b 04 85 00 b0 01 00 	mov    0x1b000(,%eax,4),%eax
   10899:	89 02                	mov    %eax,(%edx)
    for (int i = 0; i < user_pde_start; i++)
   1089b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1089f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   108a2:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   108a5:	77 d9                	ja     10880 <memory_create_uvm+0x59>
    }

    return (uint32_t)page_dir;
   108a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   108aa:	c9                   	leave  
   108ab:	c3                   	ret    

000108ac <memory_alloc_for_page_dir>:

uint32_t memory_alloc_for_page_dir(uint32_t page_dir, uint32_t vaddr, uint32_t size, int perm)
{
   108ac:	55                   	push   %ebp
   108ad:	89 e5                	mov    %esp,%ebp
   108af:	83 ec 28             	sub    $0x28,%esp
    uint32_t curr_vaddr = vaddr;
   108b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   108b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int page_count = up2(size, MEM_PAGE_SIZE) / MEM_PAGE_SIZE;
   108b8:	68 00 10 00 00       	push   $0x1000
   108bd:	ff 75 10             	pushl  0x10(%ebp)
   108c0:	e8 76 fa ff ff       	call   1033b <up2>
   108c5:	83 c4 08             	add    $0x8,%esp
   108c8:	c1 e8 0c             	shr    $0xc,%eax
   108cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    vaddr = down2(vaddr, MEM_PAGE_SIZE);
   108ce:	68 00 10 00 00       	push   $0x1000
   108d3:	ff 75 0c             	pushl  0xc(%ebp)
   108d6:	e8 53 fa ff ff       	call   1032e <down2>
   108db:	83 c4 08             	add    $0x8,%esp
   108de:	89 45 0c             	mov    %eax,0xc(%ebp)

    // 逐页分配内存，然后建立映射关系
    for (int i = 0; i < page_count; i++)
   108e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   108e8:	e9 95 00 00 00       	jmp    10982 <memory_alloc_for_page_dir+0xd6>
    {
        // 分配需要的内存
        uint32_t paddr = addr_alloc_page(&paddr_alloc, 1);
   108ed:	83 ec 08             	sub    $0x8,%esp
   108f0:	6a 01                	push   $0x1
   108f2:	68 00 a0 01 00       	push   $0x1a000
   108f7:	e8 40 fb ff ff       	call   1043c <addr_alloc_page>
   108fc:	83 c4 10             	add    $0x10,%esp
   108ff:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (paddr == 0)
   10902:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   10906:	75 17                	jne    1091f <memory_alloc_for_page_dir+0x73>
        {
            log_printf("mem alloc failed. no memory");
   10908:	83 ec 0c             	sub    $0xc,%esp
   1090b:	68 41 71 01 00       	push   $0x17141
   10910:	e8 ea 66 00 00       	call   16fff <log_printf>
   10915:	83 c4 10             	add    $0x10,%esp
            return 0;
   10918:	b8 00 00 00 00       	mov    $0x0,%eax
   1091d:	eb 74                	jmp    10993 <memory_alloc_for_page_dir+0xe7>
        }

        // 建立分配的内存与指定地址的关联
        int err = memory_create_map((pde_t *)page_dir, curr_vaddr, paddr, 1, perm);
   1091f:	8b 55 14             	mov    0x14(%ebp),%edx
   10922:	8b 45 08             	mov    0x8(%ebp),%eax
   10925:	83 ec 0c             	sub    $0xc,%esp
   10928:	52                   	push   %edx
   10929:	6a 01                	push   $0x1
   1092b:	ff 75 e8             	pushl  -0x18(%ebp)
   1092e:	ff 75 f4             	pushl  -0xc(%ebp)
   10931:	50                   	push   %eax
   10932:	e8 fa fc ff ff       	call   10631 <memory_create_map>
   10937:	83 c4 20             	add    $0x20,%esp
   1093a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (err < 0)
   1093d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10941:	79 34                	jns    10977 <memory_alloc_for_page_dir+0xcb>
        {
            log_printf("create memory map failed. err = %d", err);
   10943:	83 ec 08             	sub    $0x8,%esp
   10946:	ff 75 e4             	pushl  -0x1c(%ebp)
   10949:	68 60 71 01 00       	push   $0x17160
   1094e:	e8 ac 66 00 00       	call   16fff <log_printf>
   10953:	83 c4 10             	add    $0x10,%esp
            addr_free_page(&paddr_alloc, vaddr, i + 1);
   10956:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10959:	83 c0 01             	add    $0x1,%eax
   1095c:	83 ec 04             	sub    $0x4,%esp
   1095f:	50                   	push   %eax
   10960:	ff 75 0c             	pushl  0xc(%ebp)
   10963:	68 00 a0 01 00       	push   $0x1a000
   10968:	e8 36 fb ff ff       	call   104a3 <addr_free_page>
   1096d:	83 c4 10             	add    $0x10,%esp
            return -1;
   10970:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10975:	eb 1c                	jmp    10993 <memory_alloc_for_page_dir+0xe7>
        }

        curr_vaddr += MEM_PAGE_SIZE;
   10977:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
    for (int i = 0; i < page_count; i++)
   1097e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10982:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10985:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   10988:	0f 8c 5f ff ff ff    	jl     108ed <memory_alloc_for_page_dir+0x41>
    }

    return 0;
   1098e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10993:	c9                   	leave  
   10994:	c3                   	ret    

00010995 <memory_alloc_page_for>:

/**
 * @brief 为指定的虚拟地址空间分配多页内存
 */
int memory_alloc_page_for(uint32_t addr, uint32_t size, int perm)
{
   10995:	55                   	push   %ebp
   10996:	89 e5                	mov    %esp,%ebp
   10998:	83 ec 08             	sub    $0x8,%esp
    return memory_alloc_for_page_dir(task_current()->tss.cr3, addr, size, perm);
   1099b:	e8 6c 0d 00 00       	call   1170c <task_current>
   109a0:	8b 80 98 02 00 00    	mov    0x298(%eax),%eax
   109a6:	ff 75 10             	pushl  0x10(%ebp)
   109a9:	ff 75 0c             	pushl  0xc(%ebp)
   109ac:	ff 75 08             	pushl  0x8(%ebp)
   109af:	50                   	push   %eax
   109b0:	e8 f7 fe ff ff       	call   108ac <memory_alloc_for_page_dir>
   109b5:	83 c4 10             	add    $0x10,%esp
}
   109b8:	c9                   	leave  
   109b9:	c3                   	ret    

000109ba <memory_alloc_page>:

uint32_t memory_alloc_page(void)
{
   109ba:	55                   	push   %ebp
   109bb:	89 e5                	mov    %esp,%ebp
   109bd:	83 ec 18             	sub    $0x18,%esp
    uint32_t addr = addr_alloc_page(&paddr_alloc, 1);
   109c0:	83 ec 08             	sub    $0x8,%esp
   109c3:	6a 01                	push   $0x1
   109c5:	68 00 a0 01 00       	push   $0x1a000
   109ca:	e8 6d fa ff ff       	call   1043c <addr_alloc_page>
   109cf:	83 c4 10             	add    $0x10,%esp
   109d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (addr == 0)
   109d5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   109d9:	75 10                	jne    109eb <memory_alloc_page+0x31>
    {
        log_printf("memory alloc failed. no memory");
   109db:	83 ec 0c             	sub    $0xc,%esp
   109de:	68 84 71 01 00       	push   $0x17184
   109e3:	e8 17 66 00 00       	call   16fff <log_printf>
   109e8:	83 c4 10             	add    $0x10,%esp
    }
    return addr;
   109eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   109ee:	c9                   	leave  
   109ef:	c3                   	ret    

000109f0 <curr_page_dir>:
static pde_t *curr_page_dir(void)
{
   109f0:	55                   	push   %ebp
   109f1:	89 e5                	mov    %esp,%ebp
   109f3:	83 ec 08             	sub    $0x8,%esp
    return (pde_t *)(task_current()->tss.cr3);
   109f6:	e8 11 0d 00 00       	call   1170c <task_current>
   109fb:	8b 80 98 02 00 00    	mov    0x298(%eax),%eax
}
   10a01:	c9                   	leave  
   10a02:	c3                   	ret    

00010a03 <memory_free_page>:
void memory_free_page(uint32_t addr)
{
   10a03:	55                   	push   %ebp
   10a04:	89 e5                	mov    %esp,%ebp
   10a06:	83 ec 18             	sub    $0x18,%esp
    if (addr < MEMORY_TASK_BASE)
   10a09:	8b 45 08             	mov    0x8(%ebp),%eax
   10a0c:	85 c0                	test   %eax,%eax
   10a0e:	78 1a                	js     10a2a <memory_free_page+0x27>
    {
        addr_free_page(&paddr_alloc, addr, 1);
   10a10:	83 ec 04             	sub    $0x4,%esp
   10a13:	6a 01                	push   $0x1
   10a15:	ff 75 08             	pushl  0x8(%ebp)
   10a18:	68 00 a0 01 00       	push   $0x1a000
   10a1d:	e8 81 fa ff ff       	call   104a3 <addr_free_page>
   10a22:	83 c4 10             	add    $0x10,%esp
        ASSERT(pte != (pte_t *)0 && pte->present);

        addr_free_page(&paddr_alloc, pte->phy_page_addr, 1);
        pte->v = 0;
    }
}
   10a25:	e9 83 00 00 00       	jmp    10aad <memory_free_page+0xaa>
        pte_t *pte = find_pte(curr_page_dir(), addr, 0);
   10a2a:	e8 c1 ff ff ff       	call   109f0 <curr_page_dir>
   10a2f:	83 ec 04             	sub    $0x4,%esp
   10a32:	6a 00                	push   $0x0
   10a34:	ff 75 08             	pushl  0x8(%ebp)
   10a37:	50                   	push   %eax
   10a38:	e8 44 fb ff ff       	call   10581 <find_pte>
   10a3d:	83 c4 10             	add    $0x10,%esp
   10a40:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ASSERT(pte != (pte_t *)0 && pte->present);
   10a43:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10a47:	74 0d                	je     10a56 <memory_free_page+0x53>
   10a49:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a4c:	0f b6 00             	movzbl (%eax),%eax
   10a4f:	83 e0 01             	and    $0x1,%eax
   10a52:	84 c0                	test   %al,%al
   10a54:	75 1c                	jne    10a72 <memory_free_page+0x6f>
   10a56:	68 a4 71 01 00       	push   $0x171a4
   10a5b:	68 20 72 01 00       	push   $0x17220
   10a60:	68 22 01 00 00       	push   $0x122
   10a65:	68 e4 70 01 00       	push   $0x170e4
   10a6a:	e8 97 62 00 00       	call   16d06 <pannic>
   10a6f:	83 c4 10             	add    $0x10,%esp
        addr_free_page(&paddr_alloc, pte->phy_page_addr, 1);
   10a72:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a75:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   10a79:	c0 ea 04             	shr    $0x4,%dl
   10a7c:	0f b6 d2             	movzbl %dl,%edx
   10a7f:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   10a83:	c1 e1 04             	shl    $0x4,%ecx
   10a86:	09 ca                	or     %ecx,%edx
   10a88:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   10a8c:	c1 e0 0c             	shl    $0xc,%eax
   10a8f:	09 d0                	or     %edx,%eax
   10a91:	83 ec 04             	sub    $0x4,%esp
   10a94:	6a 01                	push   $0x1
   10a96:	50                   	push   %eax
   10a97:	68 00 a0 01 00       	push   $0x1a000
   10a9c:	e8 02 fa ff ff       	call   104a3 <addr_free_page>
   10aa1:	83 c4 10             	add    $0x10,%esp
        pte->v = 0;
   10aa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10aa7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
   10aad:	90                   	nop
   10aae:	c9                   	leave  
   10aaf:	c3                   	ret    

00010ab0 <memory_destroy_uvm>:

/**
 * @brief 销毁用户空间内存
 */
void memory_destroy_uvm(uint32_t page_dir)
{
   10ab0:	55                   	push   %ebp
   10ab1:	89 e5                	mov    %esp,%ebp
   10ab3:	83 ec 28             	sub    $0x28,%esp
    uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE);
   10ab6:	68 00 00 00 80       	push   $0x80000000
   10abb:	e8 af f8 ff ff       	call   1036f <pde_index>
   10ac0:	83 c4 04             	add    $0x4,%esp
   10ac3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    pde_t *pde = (pde_t *)page_dir + user_pde_start;
   10ac6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10ac9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10ad0:	8b 45 08             	mov    0x8(%ebp),%eax
   10ad3:	01 d0                	add    %edx,%eax
   10ad5:	89 45 f4             	mov    %eax,-0xc(%ebp)

    ASSERT(page_dir != 0);
   10ad8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10adc:	75 1c                	jne    10afa <memory_destroy_uvm+0x4a>
   10ade:	68 c6 71 01 00       	push   $0x171c6
   10ae3:	68 34 72 01 00       	push   $0x17234
   10ae8:	68 31 01 00 00       	push   $0x131
   10aed:	68 e4 70 01 00       	push   $0x170e4
   10af2:	e8 0f 62 00 00       	call   16d06 <pannic>
   10af7:	83 c4 10             	add    $0x10,%esp

    // 释放页表中对应的各项，不包含映射的内核页面
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++)
   10afa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10afd:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10b00:	e9 95 00 00 00       	jmp    10b9a <memory_destroy_uvm+0xea>
    {
        if (!pde->present)
   10b05:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b08:	0f b6 00             	movzbl (%eax),%eax
   10b0b:	83 e0 01             	and    $0x1,%eax
   10b0e:	84 c0                	test   %al,%al
   10b10:	74 7f                	je     10b91 <memory_destroy_uvm+0xe1>
        {
            continue;
        }

        // 释放页表对应的物理页 + 页表
        pte_t *pte = (pte_t *)pde_paddr(pde);
   10b12:	83 ec 0c             	sub    $0xc,%esp
   10b15:	ff 75 f4             	pushl  -0xc(%ebp)
   10b18:	e8 6d f8 ff ff       	call   1038a <pde_paddr>
   10b1d:	83 c4 10             	add    $0x10,%esp
   10b20:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for (int j = 0; j < PTE_CNT; j++, pte++)
   10b23:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10b2a:	eb 39                	jmp    10b65 <memory_destroy_uvm+0xb5>
        {
            if (!pte->present)
   10b2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10b2f:	0f b6 00             	movzbl (%eax),%eax
   10b32:	83 e0 01             	and    $0x1,%eax
   10b35:	84 c0                	test   %al,%al
   10b37:	74 23                	je     10b5c <memory_destroy_uvm+0xac>
            {
                continue;
            }

            addr_free_page(&paddr_alloc, pte_paddr(pte), 1);
   10b39:	83 ec 0c             	sub    $0xc,%esp
   10b3c:	ff 75 ec             	pushl  -0x14(%ebp)
   10b3f:	e8 6d f8 ff ff       	call   103b1 <pte_paddr>
   10b44:	83 c4 10             	add    $0x10,%esp
   10b47:	83 ec 04             	sub    $0x4,%esp
   10b4a:	6a 01                	push   $0x1
   10b4c:	50                   	push   %eax
   10b4d:	68 00 a0 01 00       	push   $0x1a000
   10b52:	e8 4c f9 ff ff       	call   104a3 <addr_free_page>
   10b57:	83 c4 10             	add    $0x10,%esp
   10b5a:	eb 01                	jmp    10b5d <memory_destroy_uvm+0xad>
                continue;
   10b5c:	90                   	nop
        for (int j = 0; j < PTE_CNT; j++, pte++)
   10b5d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   10b61:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   10b65:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   10b6c:	7e be                	jle    10b2c <memory_destroy_uvm+0x7c>
        }

        addr_free_page(&paddr_alloc, (uint32_t)pde_paddr(pde), 1);
   10b6e:	83 ec 0c             	sub    $0xc,%esp
   10b71:	ff 75 f4             	pushl  -0xc(%ebp)
   10b74:	e8 11 f8 ff ff       	call   1038a <pde_paddr>
   10b79:	83 c4 10             	add    $0x10,%esp
   10b7c:	83 ec 04             	sub    $0x4,%esp
   10b7f:	6a 01                	push   $0x1
   10b81:	50                   	push   %eax
   10b82:	68 00 a0 01 00       	push   $0x1a000
   10b87:	e8 17 f9 ff ff       	call   104a3 <addr_free_page>
   10b8c:	83 c4 10             	add    $0x10,%esp
   10b8f:	eb 01                	jmp    10b92 <memory_destroy_uvm+0xe2>
            continue;
   10b91:	90                   	nop
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++)
   10b92:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10b96:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   10b9a:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   10ba1:	0f 8e 5e ff ff ff    	jle    10b05 <memory_destroy_uvm+0x55>
    }

    // 页目录表
    addr_free_page(&paddr_alloc, page_dir, 1);
   10ba7:	83 ec 04             	sub    $0x4,%esp
   10baa:	6a 01                	push   $0x1
   10bac:	ff 75 08             	pushl  0x8(%ebp)
   10baf:	68 00 a0 01 00       	push   $0x1a000
   10bb4:	e8 ea f8 ff ff       	call   104a3 <addr_free_page>
   10bb9:	83 c4 10             	add    $0x10,%esp
}
   10bbc:	90                   	nop
   10bbd:	c9                   	leave  
   10bbe:	c3                   	ret    

00010bbf <memory_copy_uvm>:

/**
 * @brief 复制页表及其所有的内存空间
 */
uint32_t memory_copy_uvm(uint32_t page_dir)
{
   10bbf:	55                   	push   %ebp
   10bc0:	89 e5                	mov    %esp,%ebp
   10bc2:	83 ec 38             	sub    $0x38,%esp
    // 复制基础页表
    uint32_t to_page_dir = memory_create_uvm();
   10bc5:	e8 5d fc ff ff       	call   10827 <memory_create_uvm>
   10bca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (to_page_dir == 0)
   10bcd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10bd1:	0f 84 1b 01 00 00    	je     10cf2 <memory_copy_uvm+0x133>
    {
        goto copy_uvm_failed;
    }

    // 再复制用户空间的各项
    uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE);
   10bd7:	83 ec 0c             	sub    $0xc,%esp
   10bda:	68 00 00 00 80       	push   $0x80000000
   10bdf:	e8 8b f7 ff ff       	call   1036f <pde_index>
   10be4:	83 c4 10             	add    $0x10,%esp
   10be7:	89 45 e0             	mov    %eax,-0x20(%ebp)
    pde_t *pde = (pde_t *)page_dir + user_pde_start;
   10bea:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10bed:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10bf4:	8b 45 08             	mov    0x8(%ebp),%eax
   10bf7:	01 d0                	add    %edx,%eax
   10bf9:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 遍历用户空间页目录项
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++)
   10bfc:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10bff:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10c02:	e9 d9 00 00 00       	jmp    10ce0 <memory_copy_uvm+0x121>
    {
        if (!pde->present)
   10c07:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10c0a:	0f b6 00             	movzbl (%eax),%eax
   10c0d:	83 e0 01             	and    $0x1,%eax
   10c10:	84 c0                	test   %al,%al
   10c12:	0f 84 bf 00 00 00    	je     10cd7 <memory_copy_uvm+0x118>
        {
            continue;
        }

        // 遍历页表
        pte_t *pte = (pte_t *)pde_paddr(pde);
   10c18:	83 ec 0c             	sub    $0xc,%esp
   10c1b:	ff 75 f4             	pushl  -0xc(%ebp)
   10c1e:	e8 67 f7 ff ff       	call   1038a <pde_paddr>
   10c23:	83 c4 10             	add    $0x10,%esp
   10c26:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for (int j = 0; j < PTE_CNT; j++, pte++)
   10c29:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10c30:	e9 93 00 00 00       	jmp    10cc8 <memory_copy_uvm+0x109>
        {
            if (!pte->present)
   10c35:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c38:	0f b6 00             	movzbl (%eax),%eax
   10c3b:	83 e0 01             	and    $0x1,%eax
   10c3e:	84 c0                	test   %al,%al
   10c40:	74 7d                	je     10cbf <memory_copy_uvm+0x100>
            {
                continue;
            }

            // 分配物理内存
            uint32_t page = addr_alloc_page(&paddr_alloc, 1);
   10c42:	83 ec 08             	sub    $0x8,%esp
   10c45:	6a 01                	push   $0x1
   10c47:	68 00 a0 01 00       	push   $0x1a000
   10c4c:	e8 eb f7 ff ff       	call   1043c <addr_alloc_page>
   10c51:	83 c4 10             	add    $0x10,%esp
   10c54:	89 45 dc             	mov    %eax,-0x24(%ebp)
            if (page == 0)
   10c57:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   10c5b:	0f 84 94 00 00 00    	je     10cf5 <memory_copy_uvm+0x136>
            {
                goto copy_uvm_failed;
            }

            // 建立映射关系
            uint32_t vaddr = (i << 22) | (j << 12);
   10c61:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10c64:	c1 e0 16             	shl    $0x16,%eax
   10c67:	89 c2                	mov    %eax,%edx
   10c69:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10c6c:	c1 e0 0c             	shl    $0xc,%eax
   10c6f:	09 d0                	or     %edx,%eax
   10c71:	89 45 d8             	mov    %eax,-0x28(%ebp)
            int err = memory_create_map((pde_t *)to_page_dir, vaddr, page, 1, get_pte_perm(pte));
   10c74:	83 ec 0c             	sub    $0xc,%esp
   10c77:	ff 75 ec             	pushl  -0x14(%ebp)
   10c7a:	e8 59 f7 ff ff       	call   103d8 <get_pte_perm>
   10c7f:	83 c4 10             	add    $0x10,%esp
   10c82:	89 c2                	mov    %eax,%edx
   10c84:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10c87:	83 ec 0c             	sub    $0xc,%esp
   10c8a:	52                   	push   %edx
   10c8b:	6a 01                	push   $0x1
   10c8d:	ff 75 dc             	pushl  -0x24(%ebp)
   10c90:	ff 75 d8             	pushl  -0x28(%ebp)
   10c93:	50                   	push   %eax
   10c94:	e8 98 f9 ff ff       	call   10631 <memory_create_map>
   10c99:	83 c4 20             	add    $0x20,%esp
   10c9c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            if (err < 0)
   10c9f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   10ca3:	78 53                	js     10cf8 <memory_copy_uvm+0x139>
            {
                goto copy_uvm_failed;
            }

            // 复制内容。
            kernel_memcpy((void *)page, (void *)vaddr, MEM_PAGE_SIZE);
   10ca5:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10ca8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10cab:	83 ec 04             	sub    $0x4,%esp
   10cae:	68 00 10 00 00       	push   $0x1000
   10cb3:	52                   	push   %edx
   10cb4:	50                   	push   %eax
   10cb5:	e8 1a 5d 00 00       	call   169d4 <kernel_memcpy>
   10cba:	83 c4 10             	add    $0x10,%esp
   10cbd:	eb 01                	jmp    10cc0 <memory_copy_uvm+0x101>
                continue;
   10cbf:	90                   	nop
        for (int j = 0; j < PTE_CNT; j++, pte++)
   10cc0:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   10cc4:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   10cc8:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   10ccf:	0f 8e 60 ff ff ff    	jle    10c35 <memory_copy_uvm+0x76>
   10cd5:	eb 01                	jmp    10cd8 <memory_copy_uvm+0x119>
            continue;
   10cd7:	90                   	nop
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++)
   10cd8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10cdc:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   10ce0:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   10ce7:	0f 8e 1a ff ff ff    	jle    10c07 <memory_copy_uvm+0x48>
        }
    }
    return to_page_dir;
   10ced:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10cf0:	eb 20                	jmp    10d12 <memory_copy_uvm+0x153>
        goto copy_uvm_failed;
   10cf2:	90                   	nop
   10cf3:	eb 04                	jmp    10cf9 <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   10cf5:	90                   	nop
   10cf6:	eb 01                	jmp    10cf9 <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   10cf8:	90                   	nop

copy_uvm_failed:
    if (to_page_dir)
   10cf9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10cfd:	74 0e                	je     10d0d <memory_copy_uvm+0x14e>
    {
        memory_destroy_uvm(to_page_dir);
   10cff:	83 ec 0c             	sub    $0xc,%esp
   10d02:	ff 75 e4             	pushl  -0x1c(%ebp)
   10d05:	e8 a6 fd ff ff       	call   10ab0 <memory_destroy_uvm>
   10d0a:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   10d0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   10d12:	c9                   	leave  
   10d13:	c3                   	ret    

00010d14 <memory_get_paddr>:

uint32_t memory_get_paddr(uint32_t page_dir, uint32_t vaddr)
{
   10d14:	55                   	push   %ebp
   10d15:	89 e5                	mov    %esp,%ebp
   10d17:	83 ec 18             	sub    $0x18,%esp
    pte_t *pte = find_pte((pde_t *)page_dir, vaddr, 0);
   10d1a:	8b 45 08             	mov    0x8(%ebp),%eax
   10d1d:	83 ec 04             	sub    $0x4,%esp
   10d20:	6a 00                	push   $0x0
   10d22:	ff 75 0c             	pushl  0xc(%ebp)
   10d25:	50                   	push   %eax
   10d26:	e8 56 f8 ff ff       	call   10581 <find_pte>
   10d2b:	83 c4 10             	add    $0x10,%esp
   10d2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!pte)
   10d31:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10d35:	75 07                	jne    10d3e <memory_get_paddr+0x2a>
    {
        return 0;
   10d37:	b8 00 00 00 00       	mov    $0x0,%eax
   10d3c:	eb 1a                	jmp    10d58 <memory_get_paddr+0x44>
    }
    return pte_paddr(pte) + (vaddr & (MEM_PAGE_SIZE - 1));
   10d3e:	83 ec 0c             	sub    $0xc,%esp
   10d41:	ff 75 f4             	pushl  -0xc(%ebp)
   10d44:	e8 68 f6 ff ff       	call   103b1 <pte_paddr>
   10d49:	83 c4 10             	add    $0x10,%esp
   10d4c:	89 c2                	mov    %eax,%edx
   10d4e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d51:	25 ff 0f 00 00       	and    $0xfff,%eax
   10d56:	01 d0                	add    %edx,%eax
}
   10d58:	c9                   	leave  
   10d59:	c3                   	ret    

00010d5a <memor_copy_uvm_data>:

int memor_copy_uvm_data(uint32_t to, uint32_t page_dir, uint32_t from, uint32_t size)
{
   10d5a:	55                   	push   %ebp
   10d5b:	89 e5                	mov    %esp,%ebp
   10d5d:	83 ec 18             	sub    $0x18,%esp
    while (size > 0)
   10d60:	eb 6e                	jmp    10dd0 <memor_copy_uvm_data+0x76>
    {
        uint32_t to_paddr = memory_get_paddr(page_dir, to);
   10d62:	83 ec 08             	sub    $0x8,%esp
   10d65:	ff 75 08             	pushl  0x8(%ebp)
   10d68:	ff 75 0c             	pushl  0xc(%ebp)
   10d6b:	e8 a4 ff ff ff       	call   10d14 <memory_get_paddr>
   10d70:	83 c4 10             	add    $0x10,%esp
   10d73:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (!to_paddr)
   10d76:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10d7a:	75 07                	jne    10d83 <memor_copy_uvm_data+0x29>
        {
            return -1;
   10d7c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10d81:	eb 58                	jmp    10ddb <memor_copy_uvm_data+0x81>
        }

        uint32_t offset_in_page = to_paddr & (MEM_PAGE_SIZE - 1);
   10d83:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d86:	25 ff 0f 00 00       	and    $0xfff,%eax
   10d8b:	89 45 ec             	mov    %eax,-0x14(%ebp)

        uint32_t curr_size = MEM_PAGE_SIZE - offset_in_page;
   10d8e:	b8 00 10 00 00       	mov    $0x1000,%eax
   10d93:	2b 45 ec             	sub    -0x14(%ebp),%eax
   10d96:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (curr_size > size)
   10d99:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d9c:	3b 45 14             	cmp    0x14(%ebp),%eax
   10d9f:	76 06                	jbe    10da7 <memor_copy_uvm_data+0x4d>
        {
            curr_size = size;
   10da1:	8b 45 14             	mov    0x14(%ebp),%eax
   10da4:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }

        kernel_memcpy((void *)to_paddr, (void *)from, curr_size);
   10da7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   10daa:	8b 55 10             	mov    0x10(%ebp),%edx
   10dad:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10db0:	83 ec 04             	sub    $0x4,%esp
   10db3:	51                   	push   %ecx
   10db4:	52                   	push   %edx
   10db5:	50                   	push   %eax
   10db6:	e8 19 5c 00 00       	call   169d4 <kernel_memcpy>
   10dbb:	83 c4 10             	add    $0x10,%esp

        size -= curr_size;
   10dbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10dc1:	29 45 14             	sub    %eax,0x14(%ebp)
        to += curr_size;
   10dc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10dc7:	01 45 08             	add    %eax,0x8(%ebp)
        from += curr_size;
   10dca:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10dcd:	01 45 10             	add    %eax,0x10(%ebp)
    while (size > 0)
   10dd0:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   10dd4:	75 8c                	jne    10d62 <memor_copy_uvm_data+0x8>
    }
    return 0;
   10dd6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10ddb:	c9                   	leave  
   10ddc:	c3                   	ret    

00010ddd <sys_sbrk>:

char *sys_sbrk(int incr)
{
   10ddd:	55                   	push   %ebp
   10dde:	89 e5                	mov    %esp,%ebp
   10de0:	83 ec 38             	sub    $0x38,%esp
    int pre_incr = incr;
   10de3:	8b 45 08             	mov    0x8(%ebp),%eax
   10de6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    task_t *task = task_current();
   10de9:	e8 1e 09 00 00       	call   1170c <task_current>
   10dee:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char * pre_heap_end = (char *)task->heap_end;
   10df1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10df4:	8b 40 50             	mov    0x50(%eax),%eax
   10df7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    ASSERT(incr >= 0);
   10dfa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10dfe:	79 1c                	jns    10e1c <sys_sbrk+0x3f>
   10e00:	68 d4 71 01 00       	push   $0x171d4
   10e05:	68 48 72 01 00       	push   $0x17248
   10e0a:	68 b7 01 00 00       	push   $0x1b7
   10e0f:	68 e4 70 01 00       	push   $0x170e4
   10e14:	e8 ed 5e 00 00       	call   16d06 <pannic>
   10e19:	83 c4 10             	add    $0x10,%esp
    if(incr == 0)
   10e1c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10e20:	75 1b                	jne    10e3d <sys_sbrk+0x60>
    {
        log_printf("sbrk(0),end=0x%x\n",pre_heap_end);
   10e22:	83 ec 08             	sub    $0x8,%esp
   10e25:	ff 75 e8             	pushl  -0x18(%ebp)
   10e28:	68 de 71 01 00       	push   $0x171de
   10e2d:	e8 cd 61 00 00       	call   16fff <log_printf>
   10e32:	83 c4 10             	add    $0x10,%esp
        return pre_heap_end;
   10e35:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10e38:	e9 aa 00 00 00       	jmp    10ee7 <sys_sbrk+0x10a>
    }
    uint32_t start = task->heap_end;
   10e3d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e40:	8b 40 50             	mov    0x50(%eax),%eax
   10e43:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t end = start + incr;
   10e46:	8b 55 08             	mov    0x8(%ebp),%edx
   10e49:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e4c:	01 d0                	add    %edx,%eax
   10e4e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    int start_offset = start % MEM_PAGE_SIZE;
   10e51:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e54:	25 ff 0f 00 00       	and    $0xfff,%eax
   10e59:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(start_offset)
   10e5c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10e60:	74 37                	je     10e99 <sys_sbrk+0xbc>
    {
        if(start_offset + incr <= MEM_PAGE_SIZE)
   10e62:	8b 55 e0             	mov    -0x20(%ebp),%edx
   10e65:	8b 45 08             	mov    0x8(%ebp),%eax
   10e68:	01 d0                	add    %edx,%eax
   10e6a:	3d 00 10 00 00       	cmp    $0x1000,%eax
   10e6f:	7f 0e                	jg     10e7f <sys_sbrk+0xa2>
        {
            task->heap_end = end;
   10e71:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e74:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10e77:	89 50 50             	mov    %edx,0x50(%eax)
            return pre_heap_end;
   10e7a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10e7d:	eb 68                	jmp    10ee7 <sys_sbrk+0x10a>
        }
        else
        {
            uint32_t curr_size = MEM_PAGE_SIZE - start_offset;
   10e7f:	b8 00 10 00 00       	mov    $0x1000,%eax
   10e84:	2b 45 e0             	sub    -0x20(%ebp),%eax
   10e87:	89 45 dc             	mov    %eax,-0x24(%ebp)
            start += curr_size;
   10e8a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e8d:	01 45 f4             	add    %eax,-0xc(%ebp)
            incr -= curr_size;
   10e90:	8b 45 08             	mov    0x8(%ebp),%eax
   10e93:	2b 45 dc             	sub    -0x24(%ebp),%eax
   10e96:	89 45 08             	mov    %eax,0x8(%ebp)
        }
    }
    if(incr)
   10e99:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10e9d:	74 3c                	je     10edb <sys_sbrk+0xfe>
    {
        uint32_t curr_size = end - start;
   10e9f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10ea2:	2b 45 f4             	sub    -0xc(%ebp),%eax
   10ea5:	89 45 d8             	mov    %eax,-0x28(%ebp)
        int err = memory_alloc_page_for(start, curr_size, PTE_P | PTE_W | PTE_U);
   10ea8:	83 ec 04             	sub    $0x4,%esp
   10eab:	6a 07                	push   $0x7
   10ead:	ff 75 d8             	pushl  -0x28(%ebp)
   10eb0:	ff 75 f4             	pushl  -0xc(%ebp)
   10eb3:	e8 dd fa ff ff       	call   10995 <memory_alloc_page_for>
   10eb8:	83 c4 10             	add    $0x10,%esp
   10ebb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        if(err < 0)
   10ebe:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   10ec2:	79 17                	jns    10edb <sys_sbrk+0xfe>
        {
            log_printf("sbrk failed\n");
   10ec4:	83 ec 0c             	sub    $0xc,%esp
   10ec7:	68 f0 71 01 00       	push   $0x171f0
   10ecc:	e8 2e 61 00 00       	call   16fff <log_printf>
   10ed1:	83 c4 10             	add    $0x10,%esp
            return (char *)-1;
   10ed4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10ed9:	eb 0c                	jmp    10ee7 <sys_sbrk+0x10a>
        }
    }
    // log_printf("sbrk(%d),end=0x%x\n",pre_incr,task->heap_end);
    task->heap_end = end;
   10edb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10ede:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10ee1:	89 50 50             	mov    %edx,0x50(%eax)
    return (char *)pre_heap_end;
   10ee4:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   10ee7:	c9                   	leave  
   10ee8:	c3                   	ret    

00010ee9 <list_node_prev>:
{
   10ee9:	55                   	push   %ebp
   10eea:	89 e5                	mov    %esp,%ebp
    return node->prev;
   10eec:	8b 45 08             	mov    0x8(%ebp),%eax
   10eef:	8b 40 04             	mov    0x4(%eax),%eax
}
   10ef2:	5d                   	pop    %ebp
   10ef3:	c3                   	ret    

00010ef4 <list_node_next>:
{
   10ef4:	55                   	push   %ebp
   10ef5:	89 e5                	mov    %esp,%ebp
    return node->next;
   10ef7:	8b 45 08             	mov    0x8(%ebp),%eax
   10efa:	8b 00                	mov    (%eax),%eax
}
   10efc:	5d                   	pop    %ebp
   10efd:	c3                   	ret    

00010efe <sys_printmsg>:

// 系统调用处理函数类型
typedef int (*syscall_handler_t)(uint32_t arg0, uint32_t arg1, uint32_t arg2, uint32_t arg3);

void sys_printmsg(const char *fmt, int arg)
{
   10efe:	55                   	push   %ebp
   10eff:	89 e5                	mov    %esp,%ebp
   10f01:	83 ec 08             	sub    $0x8,%esp
    log_printf(fmt, arg);
   10f04:	83 ec 08             	sub    $0x8,%esp
   10f07:	ff 75 0c             	pushl  0xc(%ebp)
   10f0a:	ff 75 08             	pushl  0x8(%ebp)
   10f0d:	e8 ed 60 00 00       	call   16fff <log_printf>
   10f12:	83 c4 10             	add    $0x10,%esp
}
   10f15:	90                   	nop
   10f16:	c9                   	leave  
   10f17:	c3                   	ret    

00010f18 <do_handler_syscall>:
    [SYS_exit] = (syscall_handler_t)sys_exit,
    [SYS_wait] = (syscall_handler_t)sys_wait,
};

void do_handler_syscall(syscall_frame_t *frame)
{
   10f18:	55                   	push   %ebp
   10f19:	89 e5                	mov    %esp,%ebp
   10f1b:	53                   	push   %ebx
   10f1c:	83 ec 14             	sub    $0x14,%esp
    if (frame->func_id < sizeof(sys_table) / sizeof(sys_table[0]))
   10f1f:	8b 45 08             	mov    0x8(%ebp),%eax
   10f22:	8b 40 3c             	mov    0x3c(%eax),%eax
   10f25:	83 f8 64             	cmp    $0x64,%eax
   10f28:	77 4e                	ja     10f78 <do_handler_syscall+0x60>
    {
        syscall_handler_t handler = sys_table[frame->func_id];
   10f2a:	8b 45 08             	mov    0x8(%ebp),%eax
   10f2d:	8b 40 3c             	mov    0x3c(%eax),%eax
   10f30:	8b 04 85 60 72 01 00 	mov    0x17260(,%eax,4),%eax
   10f37:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (handler)
   10f3a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10f3e:	74 38                	je     10f78 <do_handler_syscall+0x60>
        {
            int ret = handler(frame->arg0, frame->arg1, frame->arg2, frame->arg3);
   10f40:	8b 45 08             	mov    0x8(%ebp),%eax
   10f43:	8b 40 4c             	mov    0x4c(%eax),%eax
   10f46:	89 c3                	mov    %eax,%ebx
   10f48:	8b 45 08             	mov    0x8(%ebp),%eax
   10f4b:	8b 40 48             	mov    0x48(%eax),%eax
   10f4e:	89 c1                	mov    %eax,%ecx
   10f50:	8b 45 08             	mov    0x8(%ebp),%eax
   10f53:	8b 40 44             	mov    0x44(%eax),%eax
   10f56:	89 c2                	mov    %eax,%edx
   10f58:	8b 45 08             	mov    0x8(%ebp),%eax
   10f5b:	8b 40 40             	mov    0x40(%eax),%eax
   10f5e:	53                   	push   %ebx
   10f5f:	51                   	push   %ecx
   10f60:	52                   	push   %edx
   10f61:	50                   	push   %eax
   10f62:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10f65:	ff d0                	call   *%eax
   10f67:	83 c4 10             	add    $0x10,%esp
   10f6a:	89 45 f0             	mov    %eax,-0x10(%ebp)
            frame->eax = ret;
   10f6d:	8b 45 08             	mov    0x8(%ebp),%eax
   10f70:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10f73:	89 50 30             	mov    %edx,0x30(%eax)
            return;
   10f76:	eb 30                	jmp    10fa8 <do_handler_syscall+0x90>
        }
    }

    // 未知的系统调用
    task_t *task = task_current();
   10f78:	e8 8f 07 00 00       	call   1170c <task_current>
   10f7d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    log_printf("task: %s, Unknown syscall: %d", task->name, frame->func_id);
   10f80:	8b 45 08             	mov    0x8(%ebp),%eax
   10f83:	8b 40 3c             	mov    0x3c(%eax),%eax
   10f86:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10f89:	83 c2 04             	add    $0x4,%edx
   10f8c:	83 ec 04             	sub    $0x4,%esp
   10f8f:	50                   	push   %eax
   10f90:	52                   	push   %edx
   10f91:	68 f4 73 01 00       	push   $0x173f4
   10f96:	e8 64 60 00 00       	call   16fff <log_printf>
   10f9b:	83 c4 10             	add    $0x10,%esp
    frame->eax = -1;
   10f9e:	8b 45 08             	mov    0x8(%ebp),%eax
   10fa1:	c7 40 30 ff ff ff ff 	movl   $0xffffffff,0x30(%eax)
   10fa8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10fab:	c9                   	leave  
   10fac:	c3                   	ret    

00010fad <hlt>:
{
   10fad:	55                   	push   %ebp
   10fae:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   10fb0:	f4                   	hlt    
}
   10fb1:	90                   	nop
   10fb2:	5d                   	pop    %ebp
   10fb3:	c3                   	ret    

00010fb4 <write_tr>:
{
   10fb4:	55                   	push   %ebp
   10fb5:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("ltr %%ax" ::"a"(tss_selector));
   10fb7:	8b 45 08             	mov    0x8(%ebp),%eax
   10fba:	0f 00 d8             	ltr    %ax
}
   10fbd:	90                   	nop
   10fbe:	5d                   	pop    %ebp
   10fbf:	c3                   	ret    

00010fc0 <write_cr3>:
{
   10fc0:	55                   	push   %ebp
   10fc1:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("mov %[v], %%cr3" ::[v] "r"(v));
   10fc3:	8b 45 08             	mov    0x8(%ebp),%eax
   10fc6:	0f 22 d8             	mov    %eax,%cr3
}
   10fc9:	90                   	nop
   10fca:	5d                   	pop    %ebp
   10fcb:	c3                   	ret    

00010fcc <list_node_init>:
{
   10fcc:	55                   	push   %ebp
   10fcd:	89 e5                	mov    %esp,%ebp
    node->next = node->prev = (list_node_t *)0;
   10fcf:	8b 45 08             	mov    0x8(%ebp),%eax
   10fd2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   10fd9:	8b 45 08             	mov    0x8(%ebp),%eax
   10fdc:	8b 50 04             	mov    0x4(%eax),%edx
   10fdf:	8b 45 08             	mov    0x8(%ebp),%eax
   10fe2:	89 10                	mov    %edx,(%eax)
}
   10fe4:	90                   	nop
   10fe5:	5d                   	pop    %ebp
   10fe6:	c3                   	ret    

00010fe7 <list_node_prev>:
{
   10fe7:	55                   	push   %ebp
   10fe8:	89 e5                	mov    %esp,%ebp
    return node->prev;
   10fea:	8b 45 08             	mov    0x8(%ebp),%eax
   10fed:	8b 40 04             	mov    0x4(%eax),%eax
}
   10ff0:	5d                   	pop    %ebp
   10ff1:	c3                   	ret    

00010ff2 <list_node_next>:
{
   10ff2:	55                   	push   %ebp
   10ff3:	89 e5                	mov    %esp,%ebp
    return node->next;
   10ff5:	8b 45 08             	mov    0x8(%ebp),%eax
   10ff8:	8b 00                	mov    (%eax),%eax
}
   10ffa:	5d                   	pop    %ebp
   10ffb:	c3                   	ret    

00010ffc <list_count>:
{
    return list->count == 0;
}

static inline int list_count(list_t *list)
{
   10ffc:	55                   	push   %ebp
   10ffd:	89 e5                	mov    %esp,%ebp
    return list->count;
   10fff:	8b 45 08             	mov    0x8(%ebp),%eax
   11002:	8b 40 08             	mov    0x8(%eax),%eax
}
   11005:	5d                   	pop    %ebp
   11006:	c3                   	ret    

00011007 <list_first>:

static inline list_node_t *list_first(list_t *list)
{
   11007:	55                   	push   %ebp
   11008:	89 e5                	mov    %esp,%ebp
    return list->first;
   1100a:	8b 45 08             	mov    0x8(%ebp),%eax
   1100d:	8b 00                	mov    (%eax),%eax
}
   1100f:	5d                   	pop    %ebp
   11010:	c3                   	ret    

00011011 <mmu_set_page_dir>:
{
   11011:	55                   	push   %ebp
   11012:	89 e5                	mov    %esp,%ebp
    write_cr3(page_dir);
   11014:	ff 75 08             	pushl  0x8(%ebp)
   11017:	e8 a4 ff ff ff       	call   10fc0 <write_cr3>
   1101c:	83 c4 04             	add    $0x4,%esp
}
   1101f:	90                   	nop
   11020:	c9                   	leave  
   11021:	c3                   	ret    

00011022 <task_alloc_fd>:
static uint32_t idle_task_stack[IDLE_STACK_SIZE]; // 空闲任务堆栈
static task_t task_table[TASK_NR];                // 任务表
static mutex_t task_table_mutex;                  // 任务表互斥锁

int task_alloc_fd(file_t *file) // 返回文件描述符索引
{
   11022:	55                   	push   %ebp
   11023:	89 e5                	mov    %esp,%ebp
   11025:	83 ec 18             	sub    $0x18,%esp
    task_t *task = task_current();
   11028:	e8 df 06 00 00       	call   1170c <task_current>
   1102d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (int i = 0; i < TASK_OFILE_NR; i++)
   11030:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11037:	eb 2f                	jmp    11068 <task_alloc_fd+0x46>
    {
        file_t *p = task->file_table[i];
   11039:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1103c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1103f:	83 c2 18             	add    $0x18,%edx
   11042:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   11046:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (p == (file_t *)0)
   11049:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1104d:	75 15                	jne    11064 <task_alloc_fd+0x42>
        {
            task->file_table[i] = file;
   1104f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11052:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11055:	8d 4a 18             	lea    0x18(%edx),%ecx
   11058:	8b 55 08             	mov    0x8(%ebp),%edx
   1105b:	89 54 88 04          	mov    %edx,0x4(%eax,%ecx,4)
            return i;
   1105f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11062:	eb 0f                	jmp    11073 <task_alloc_fd+0x51>
    for (int i = 0; i < TASK_OFILE_NR; i++)
   11064:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11068:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   1106c:	7e cb                	jle    11039 <task_alloc_fd+0x17>
        }
    }
    return -1;
   1106e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11073:	c9                   	leave  
   11074:	c3                   	ret    

00011075 <task_remove_fd>:
void task_remove_fd(int fd) // 释放文件描述符
{
   11075:	55                   	push   %ebp
   11076:	89 e5                	mov    %esp,%ebp
   11078:	83 ec 18             	sub    $0x18,%esp
    if ((fd >= 0) && (fd < TASK_OFILE_NR))
   1107b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1107f:	78 1f                	js     110a0 <task_remove_fd+0x2b>
   11081:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   11085:	7f 19                	jg     110a0 <task_remove_fd+0x2b>
    {
        task_t *task = task_current();
   11087:	e8 80 06 00 00       	call   1170c <task_current>
   1108c:	89 45 f4             	mov    %eax,-0xc(%ebp)
        task->file_table[fd] = (file_t *)0;
   1108f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11092:	8b 55 08             	mov    0x8(%ebp),%edx
   11095:	83 c2 18             	add    $0x18,%edx
   11098:	c7 44 90 04 00 00 00 	movl   $0x0,0x4(%eax,%edx,4)
   1109f:	00 
    }
}
   110a0:	90                   	nop
   110a1:	c9                   	leave  
   110a2:	c3                   	ret    

000110a3 <task_file>:
file_t *task_file(int fd) // 返回文件描述符
{
   110a3:	55                   	push   %ebp
   110a4:	89 e5                	mov    %esp,%ebp
   110a6:	83 ec 18             	sub    $0x18,%esp
    if ((fd >= 0) && (fd < TASK_OFILE_NR))
   110a9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   110ad:	78 1d                	js     110cc <task_file+0x29>
   110af:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   110b3:	7f 17                	jg     110cc <task_file+0x29>
    {
        task_t *task = task_current();
   110b5:	e8 52 06 00 00       	call   1170c <task_current>
   110ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return task->file_table[fd];
   110bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   110c0:	8b 55 08             	mov    0x8(%ebp),%edx
   110c3:	83 c2 18             	add    $0x18,%edx
   110c6:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   110ca:	eb 05                	jmp    110d1 <task_file+0x2e>
    }
    return (file_t *)0;
   110cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
   110d1:	c9                   	leave  
   110d2:	c3                   	ret    

000110d3 <tss_init>:

/**
 * @brief 初始化TSS
 */
static int tss_init(task_t *task, int flag, uint32_t entry, uint32_t esp)
{
   110d3:	55                   	push   %ebp
   110d4:	89 e5                	mov    %esp,%ebp
   110d6:	83 ec 28             	sub    $0x28,%esp
    int tss_sel = gdt_alloc_desc();
   110d9:	e8 1f 14 00 00       	call   124fd <gdt_alloc_desc>
   110de:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (tss_sel < 0)
   110e1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   110e5:	79 1a                	jns    11101 <tss_init+0x2e>
    {
        log_printf("tss_init: alloc tss descriptor failed\n");
   110e7:	83 ec 0c             	sub    $0xc,%esp
   110ea:	68 14 74 01 00       	push   $0x17414
   110ef:	e8 0b 5f 00 00       	call   16fff <log_printf>
   110f4:	83 c4 10             	add    $0x10,%esp
        return -1;
   110f7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   110fc:	e9 78 01 00 00       	jmp    11279 <tss_init+0x1a6>
    }

    segment_desc_set(tss_sel, (uint32_t)&task->tss, sizeof(tss_t),
   11101:	8b 45 08             	mov    0x8(%ebp),%eax
   11104:	05 7c 02 00 00       	add    $0x27c,%eax
   11109:	68 89 00 00 00       	push   $0x89
   1110e:	6a 68                	push   $0x68
   11110:	50                   	push   %eax
   11111:	ff 75 ec             	pushl  -0x14(%ebp)
   11114:	e8 1a 13 00 00       	call   12433 <segment_desc_set>
   11119:	83 c4 10             	add    $0x10,%esp
                     SEG_P_PRESENT | SEG_DPL0 | SEG_TYPE_TSS);

    kernel_memset(&task->tss, 0, sizeof(tss_t));
   1111c:	8b 45 08             	mov    0x8(%ebp),%eax
   1111f:	05 7c 02 00 00       	add    $0x27c,%eax
   11124:	83 ec 04             	sub    $0x4,%esp
   11127:	6a 68                	push   $0x68
   11129:	6a 00                	push   $0x0
   1112b:	50                   	push   %eax
   1112c:	e8 f2 58 00 00       	call   16a23 <kernel_memset>
   11131:	83 c4 10             	add    $0x10,%esp

    uint32_t kernel_stack = memory_alloc_page();
   11134:	e8 81 f8 ff ff       	call   109ba <memory_alloc_page>
   11139:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (kernel_stack == 0)
   1113c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11140:	0f 84 0b 01 00 00    	je     11251 <tss_init+0x17e>
        goto tss_init_failed;
    }

    int code_sel, data_sel;

    if (flag & TASK_FLAGS_SYSTEM)
   11146:	8b 45 0c             	mov    0xc(%ebp),%eax
   11149:	83 e0 01             	and    $0x1,%eax
   1114c:	85 c0                	test   %eax,%eax
   1114e:	74 10                	je     11160 <tss_init+0x8d>
    {
        code_sel = KERNEL_SELECTOR_CS;
   11150:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
        data_sel = KERNEL_SELECTOR_DS;
   11157:	c7 45 f0 10 00 00 00 	movl   $0x10,-0x10(%ebp)
   1115e:	eb 16                	jmp    11176 <tss_init+0xa3>
    }
    else
    {
        // 注意加了RP3,不然将产生段保护错误
        code_sel = task_manager.app_code_sel | SEG_RPL3;
   11160:	a1 f8 c5 01 00       	mov    0x1c5f8,%eax
   11165:	83 c8 03             	or     $0x3,%eax
   11168:	89 45 f4             	mov    %eax,-0xc(%ebp)
        data_sel = task_manager.app_data_sel | SEG_RPL3;
   1116b:	a1 fc c5 01 00       	mov    0x1c5fc,%eax
   11170:	83 c8 03             	or     $0x3,%eax
   11173:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    task->tss.eip = entry;
   11176:	8b 45 08             	mov    0x8(%ebp),%eax
   11179:	8b 55 10             	mov    0x10(%ebp),%edx
   1117c:	89 90 9c 02 00 00    	mov    %edx,0x29c(%eax)
    task->tss.esp = esp;
   11182:	8b 45 08             	mov    0x8(%ebp),%eax
   11185:	8b 55 14             	mov    0x14(%ebp),%edx
   11188:	89 90 b4 02 00 00    	mov    %edx,0x2b4(%eax)
    task->tss.esp0 = kernel_stack + MEM_PAGE_SIZE;
   1118e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11191:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
   11197:	8b 45 08             	mov    0x8(%ebp),%eax
   1119a:	89 90 80 02 00 00    	mov    %edx,0x280(%eax)
    task->tss.ss = data_sel;
   111a0:	8b 55 f0             	mov    -0x10(%ebp),%edx
   111a3:	8b 45 08             	mov    0x8(%ebp),%eax
   111a6:	89 90 cc 02 00 00    	mov    %edx,0x2cc(%eax)
    task->tss.ss0 = KERNEL_SELECTOR_DS;
   111ac:	8b 45 08             	mov    0x8(%ebp),%eax
   111af:	c7 80 84 02 00 00 10 	movl   $0x10,0x284(%eax)
   111b6:	00 00 00 
    task->tss.es = task->tss.ds = task->tss.fs = task->tss.gs = data_sel;
   111b9:	8b 55 f0             	mov    -0x10(%ebp),%edx
   111bc:	8b 45 08             	mov    0x8(%ebp),%eax
   111bf:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%eax)
   111c5:	8b 45 08             	mov    0x8(%ebp),%eax
   111c8:	8b 90 d8 02 00 00    	mov    0x2d8(%eax),%edx
   111ce:	8b 45 08             	mov    0x8(%ebp),%eax
   111d1:	89 90 d4 02 00 00    	mov    %edx,0x2d4(%eax)
   111d7:	8b 45 08             	mov    0x8(%ebp),%eax
   111da:	8b 90 d4 02 00 00    	mov    0x2d4(%eax),%edx
   111e0:	8b 45 08             	mov    0x8(%ebp),%eax
   111e3:	89 90 d0 02 00 00    	mov    %edx,0x2d0(%eax)
   111e9:	8b 45 08             	mov    0x8(%ebp),%eax
   111ec:	8b 90 d0 02 00 00    	mov    0x2d0(%eax),%edx
   111f2:	8b 45 08             	mov    0x8(%ebp),%eax
   111f5:	89 90 c4 02 00 00    	mov    %edx,0x2c4(%eax)
    task->tss.cs = code_sel;
   111fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
   111fe:	8b 45 08             	mov    0x8(%ebp),%eax
   11201:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%eax)
    task->tss.eflags = EFALGS_IF | EFALGS_DEFAULT;
   11207:	8b 45 08             	mov    0x8(%ebp),%eax
   1120a:	c7 80 a0 02 00 00 02 	movl   $0x202,0x2a0(%eax)
   11211:	02 00 00 
    uint32_t page_dir = memory_create_uvm();
   11214:	e8 0e f6 ff ff       	call   10827 <memory_create_uvm>
   11219:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (page_dir == -1)
   1121c:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
   11220:	75 10                	jne    11232 <tss_init+0x15f>
    {
        gdt_free_sel(tss_sel);
   11222:	83 ec 0c             	sub    $0xc,%esp
   11225:	ff 75 ec             	pushl  -0x14(%ebp)
   11228:	e8 3b 13 00 00       	call   12568 <gdt_free_sel>
   1122d:	83 c4 10             	add    $0x10,%esp
        goto tss_init_failed;
   11230:	eb 20                	jmp    11252 <tss_init+0x17f>
    }
    task->tss.cr3 = page_dir;
   11232:	8b 45 08             	mov    0x8(%ebp),%eax
   11235:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   11238:	89 90 98 02 00 00    	mov    %edx,0x298(%eax)
    task->tss_sel = tss_sel;
   1123e:	8b 45 08             	mov    0x8(%ebp),%eax
   11241:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11244:	89 90 e4 02 00 00    	mov    %edx,0x2e4(%eax)
    return 0;
   1124a:	b8 00 00 00 00       	mov    $0x0,%eax
   1124f:	eb 28                	jmp    11279 <tss_init+0x1a6>
        goto tss_init_failed;
   11251:	90                   	nop

tss_init_failed:
    gdt_free_sel(tss_sel);
   11252:	83 ec 0c             	sub    $0xc,%esp
   11255:	ff 75 ec             	pushl  -0x14(%ebp)
   11258:	e8 0b 13 00 00       	call   12568 <gdt_free_sel>
   1125d:	83 c4 10             	add    $0x10,%esp

    if (kernel_stack)
   11260:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11264:	74 0e                	je     11274 <tss_init+0x1a1>
    {
        memory_free_page(kernel_stack);
   11266:	83 ec 0c             	sub    $0xc,%esp
   11269:	ff 75 e8             	pushl  -0x18(%ebp)
   1126c:	e8 92 f7 ff ff       	call   10a03 <memory_free_page>
   11271:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   11274:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11279:	c9                   	leave  
   1127a:	c3                   	ret    

0001127b <task_init>:
/**
 * @brief 初始化任务
 */
int task_init(task_t *task, const char *task_name, int flag, uint32_t entry, uint32_t esp)
{
   1127b:	55                   	push   %ebp
   1127c:	89 e5                	mov    %esp,%ebp
   1127e:	83 ec 18             	sub    $0x18,%esp
    ASSERT(task != (task_t *)0);
   11281:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11285:	75 19                	jne    112a0 <task_init+0x25>
   11287:	68 3b 74 01 00       	push   $0x1743b
   1128c:	68 64 75 01 00       	push   $0x17564
   11291:	6a 7b                	push   $0x7b
   11293:	68 50 74 01 00       	push   $0x17450
   11298:	e8 69 5a 00 00       	call   16d06 <pannic>
   1129d:	83 c4 10             	add    $0x10,%esp
    // 任务字段初始化
    kernel_strncpy(task->name, task_name, TASK_NAME_SIZE);
   112a0:	8b 45 08             	mov    0x8(%ebp),%eax
   112a3:	83 c0 04             	add    $0x4,%eax
   112a6:	83 ec 04             	sub    $0x4,%esp
   112a9:	6a 40                	push   $0x40
   112ab:	ff 75 0c             	pushl  0xc(%ebp)
   112ae:	50                   	push   %eax
   112af:	e8 fd 55 00 00       	call   168b1 <kernel_strncpy>
   112b4:	83 c4 10             	add    $0x10,%esp

    tss_init(task, flag, entry, esp);
   112b7:	ff 75 18             	pushl  0x18(%ebp)
   112ba:	ff 75 14             	pushl  0x14(%ebp)
   112bd:	ff 75 10             	pushl  0x10(%ebp)
   112c0:	ff 75 08             	pushl  0x8(%ebp)
   112c3:	e8 0b fe ff ff       	call   110d3 <tss_init>
   112c8:	83 c4 10             	add    $0x10,%esp
    task->state = TASK_CREATED;
   112cb:	8b 45 08             	mov    0x8(%ebp),%eax
   112ce:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    task->time_ticks = TASK_TIME_SLICE_DEFAULT;
   112d4:	8b 45 08             	mov    0x8(%ebp),%eax
   112d7:	c7 40 5c 0a 00 00 00 	movl   $0xa,0x5c(%eax)
    task->slice_ticks = task->time_ticks;
   112de:	8b 45 08             	mov    0x8(%ebp),%eax
   112e1:	8b 50 5c             	mov    0x5c(%eax),%edx
   112e4:	8b 45 08             	mov    0x8(%ebp),%eax
   112e7:	89 50 58             	mov    %edx,0x58(%eax)
    task->sleep_ticks = 0;
   112ea:	8b 45 08             	mov    0x8(%ebp),%eax
   112ed:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
    task->pid = (uint32_t)task;
   112f4:	8b 55 08             	mov    0x8(%ebp),%edx
   112f7:	8b 45 08             	mov    0x8(%ebp),%eax
   112fa:	89 50 44             	mov    %edx,0x44(%eax)
    task->parent = (task_t *)0;
   112fd:	8b 45 08             	mov    0x8(%ebp),%eax
   11300:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    task->heap_start = 0;
   11307:	8b 45 08             	mov    0x8(%ebp),%eax
   1130a:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
    task->heap_end = 0;
   11311:	8b 45 08             	mov    0x8(%ebp),%eax
   11314:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
    task->exit_status = 0;
   1131b:	8b 45 08             	mov    0x8(%ebp),%eax
   1131e:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
    list_node_init(&task->all_node);
   11325:	8b 45 08             	mov    0x8(%ebp),%eax
   11328:	05 6c 02 00 00       	add    $0x26c,%eax
   1132d:	83 ec 0c             	sub    $0xc,%esp
   11330:	50                   	push   %eax
   11331:	e8 96 fc ff ff       	call   10fcc <list_node_init>
   11336:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->run_node);
   11339:	8b 45 08             	mov    0x8(%ebp),%eax
   1133c:	05 64 02 00 00       	add    $0x264,%eax
   11341:	83 ec 0c             	sub    $0xc,%esp
   11344:	50                   	push   %eax
   11345:	e8 82 fc ff ff       	call   10fcc <list_node_init>
   1134a:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->wait_node);
   1134d:	8b 45 08             	mov    0x8(%ebp),%eax
   11350:	05 74 02 00 00       	add    $0x274,%eax
   11355:	83 ec 0c             	sub    $0xc,%esp
   11358:	50                   	push   %eax
   11359:	e8 6e fc ff ff       	call   10fcc <list_node_init>
   1135e:	83 c4 10             	add    $0x10,%esp

    kernel_memset((void *)task->file_table, 0, sizeof(task->file_table));
   11361:	8b 45 08             	mov    0x8(%ebp),%eax
   11364:	83 c0 64             	add    $0x64,%eax
   11367:	83 ec 04             	sub    $0x4,%esp
   1136a:	68 00 02 00 00       	push   $0x200
   1136f:	6a 00                	push   $0x0
   11371:	50                   	push   %eax
   11372:	e8 ac 56 00 00       	call   16a23 <kernel_memset>
   11377:	83 c4 10             	add    $0x10,%esp

    // 插入就绪队列中和所有的任务队列中
    irq_state_t state = irq_enter_protection();
   1137a:	e8 fd 1b 00 00       	call   12f7c <irq_enter_protection>
   1137f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    list_insert_last(&task_manager.task_list, &task->all_node);
   11382:	8b 45 08             	mov    0x8(%ebp),%eax
   11385:	05 6c 02 00 00       	add    $0x26c,%eax
   1138a:	83 ec 08             	sub    $0x8,%esp
   1138d:	50                   	push   %eax
   1138e:	68 10 c0 01 00       	push   $0x1c010
   11393:	e8 c4 5a 00 00       	call   16e5c <list_insert_last>
   11398:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   1139b:	83 ec 0c             	sub    $0xc,%esp
   1139e:	ff 75 f4             	pushl  -0xc(%ebp)
   113a1:	e8 ee 1b 00 00       	call   12f94 <irq_leave_protection>
   113a6:	83 c4 10             	add    $0x10,%esp
    //     *(--pesp) = 0;
    //     *(--pesp) = 0;
    //     *(--pesp) = 0;
    //     task->stack = pesp;
    // }
    return 0;
   113a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
   113ae:	c9                   	leave  
   113af:	c3                   	ret    

000113b0 <task_uninit>:

void task_uninit(task_t *task)
{
   113b0:	55                   	push   %ebp
   113b1:	89 e5                	mov    %esp,%ebp
   113b3:	83 ec 08             	sub    $0x8,%esp
    if (task->tss_sel)
   113b6:	8b 45 08             	mov    0x8(%ebp),%eax
   113b9:	8b 80 e4 02 00 00    	mov    0x2e4(%eax),%eax
   113bf:	85 c0                	test   %eax,%eax
   113c1:	74 15                	je     113d8 <task_uninit+0x28>
    {
        gdt_free_sel(task->tss_sel);
   113c3:	8b 45 08             	mov    0x8(%ebp),%eax
   113c6:	8b 80 e4 02 00 00    	mov    0x2e4(%eax),%eax
   113cc:	83 ec 0c             	sub    $0xc,%esp
   113cf:	50                   	push   %eax
   113d0:	e8 93 11 00 00       	call   12568 <gdt_free_sel>
   113d5:	83 c4 10             	add    $0x10,%esp
    }

    if (task->tss.esp0)
   113d8:	8b 45 08             	mov    0x8(%ebp),%eax
   113db:	8b 80 80 02 00 00    	mov    0x280(%eax),%eax
   113e1:	85 c0                	test   %eax,%eax
   113e3:	74 1a                	je     113ff <task_uninit+0x4f>
    {
        memory_free_page(task->tss.esp - MEM_PAGE_SIZE);
   113e5:	8b 45 08             	mov    0x8(%ebp),%eax
   113e8:	8b 80 b4 02 00 00    	mov    0x2b4(%eax),%eax
   113ee:	2d 00 10 00 00       	sub    $0x1000,%eax
   113f3:	83 ec 0c             	sub    $0xc,%esp
   113f6:	50                   	push   %eax
   113f7:	e8 07 f6 ff ff       	call   10a03 <memory_free_page>
   113fc:	83 c4 10             	add    $0x10,%esp
    }

    if (task->tss.cr3)
   113ff:	8b 45 08             	mov    0x8(%ebp),%eax
   11402:	8b 80 98 02 00 00    	mov    0x298(%eax),%eax
   11408:	85 c0                	test   %eax,%eax
   1140a:	74 15                	je     11421 <task_uninit+0x71>
    {
        memory_destroy_uvm(task->tss.cr3);
   1140c:	8b 45 08             	mov    0x8(%ebp),%eax
   1140f:	8b 80 98 02 00 00    	mov    0x298(%eax),%eax
   11415:	83 ec 0c             	sub    $0xc,%esp
   11418:	50                   	push   %eax
   11419:	e8 92 f6 ff ff       	call   10ab0 <memory_destroy_uvm>
   1141e:	83 c4 10             	add    $0x10,%esp
    }
    kernel_memset(task, 0, sizeof(task));
   11421:	83 ec 04             	sub    $0x4,%esp
   11424:	6a 04                	push   $0x4
   11426:	6a 00                	push   $0x0
   11428:	ff 75 08             	pushl  0x8(%ebp)
   1142b:	e8 f3 55 00 00       	call   16a23 <kernel_memset>
   11430:	83 c4 10             	add    $0x10,%esp
}
   11433:	90                   	nop
   11434:	c9                   	leave  
   11435:	c3                   	ret    

00011436 <task_start>:
void task_start(task_t *task)
{
   11436:	55                   	push   %ebp
   11437:	89 e5                	mov    %esp,%ebp
   11439:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   1143c:	e8 3b 1b 00 00       	call   12f7c <irq_enter_protection>
   11441:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_set_ready(task);
   11444:	83 ec 0c             	sub    $0xc,%esp
   11447:	ff 75 08             	pushl  0x8(%ebp)
   1144a:	e8 17 02 00 00       	call   11666 <task_set_ready>
   1144f:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   11452:	83 ec 0c             	sub    $0xc,%esp
   11455:	ff 75 f4             	pushl  -0xc(%ebp)
   11458:	e8 37 1b 00 00       	call   12f94 <irq_leave_protection>
   1145d:	83 c4 10             	add    $0x10,%esp
}
   11460:	90                   	nop
   11461:	c9                   	leave  
   11462:	c3                   	ret    

00011463 <task_switch_from_to>:
void simple_switch(uint32_t **from, uint32_t *to);
void task_switch_from_to(task_t *from, task_t *to)
{
   11463:	55                   	push   %ebp
   11464:	89 e5                	mov    %esp,%ebp
   11466:	83 ec 08             	sub    $0x8,%esp
    switch_to_tss(to->tss_sel);
   11469:	8b 45 0c             	mov    0xc(%ebp),%eax
   1146c:	8b 80 e4 02 00 00    	mov    0x2e4(%eax),%eax
   11472:	83 ec 0c             	sub    $0xc,%esp
   11475:	50                   	push   %eax
   11476:	e8 cc 11 00 00       	call   12647 <switch_to_tss>
   1147b:	83 c4 10             	add    $0x10,%esp
    // simple_switch(&from->stack, to->stack);
}
   1147e:	90                   	nop
   1147f:	c9                   	leave  
   11480:	c3                   	ret    

00011481 <idle_task_entry>:

/**
 * @brief 空闲任务
 */
static void idle_task_entry(void)
{
   11481:	55                   	push   %ebp
   11482:	89 e5                	mov    %esp,%ebp
    for (;;)
    {
        hlt();
   11484:	e8 24 fb ff ff       	call   10fad <hlt>
   11489:	eb f9                	jmp    11484 <idle_task_entry+0x3>

0001148b <task_manager_init>:

/**
 * @brief 任务管理器初始化
 */
void task_manager_init(void)
{
   1148b:	55                   	push   %ebp
   1148c:	89 e5                	mov    %esp,%ebp
   1148e:	83 ec 18             	sub    $0x18,%esp

    kernel_memset(&task_manager, 0, sizeof(task_manager_t));
   11491:	83 ec 04             	sub    $0x4,%esp
   11494:	68 00 06 00 00       	push   $0x600
   11499:	6a 00                	push   $0x0
   1149b:	68 00 c0 01 00       	push   $0x1c000
   114a0:	e8 7e 55 00 00       	call   16a23 <kernel_memset>
   114a5:	83 c4 10             	add    $0x10,%esp
    mutex_init(&task_table_mutex);
   114a8:	83 ec 0c             	sub    $0xc,%esp
   114ab:	68 00 4a 03 00       	push   $0x34a00
   114b0:	e8 90 4e 00 00       	call   16345 <mutex_init>
   114b5:	83 c4 10             	add    $0x10,%esp
    // 数据段和代码段，使用DPL3，所有应用共用同一个
    // 为调试方便，暂时使用DPL0
    int sel = gdt_alloc_desc();
   114b8:	e8 40 10 00 00       	call   124fd <gdt_alloc_desc>
   114bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(sel, 0x00000000, 0xFFFFFFFF,
   114c0:	68 f2 40 00 00       	push   $0x40f2
   114c5:	6a ff                	push   $0xffffffff
   114c7:	6a 00                	push   $0x0
   114c9:	ff 75 f4             	pushl  -0xc(%ebp)
   114cc:	e8 62 0f 00 00       	call   12433 <segment_desc_set>
   114d1:	83 c4 10             	add    $0x10,%esp
                     SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL |
                         SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);
    task_manager.app_data_sel = sel;
   114d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   114d7:	a3 fc c5 01 00       	mov    %eax,0x1c5fc

    sel = gdt_alloc_desc();
   114dc:	e8 1c 10 00 00       	call   124fd <gdt_alloc_desc>
   114e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(sel, 0x00000000, 0xFFFFFFFF,
   114e4:	68 fa 40 00 00       	push   $0x40fa
   114e9:	6a ff                	push   $0xffffffff
   114eb:	6a 00                	push   $0x0
   114ed:	ff 75 f4             	pushl  -0xc(%ebp)
   114f0:	e8 3e 0f 00 00       	call   12433 <segment_desc_set>
   114f5:	83 c4 10             	add    $0x10,%esp
                     SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL |
                         SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);
    task_manager.app_code_sel = sel;
   114f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   114fb:	a3 f8 c5 01 00       	mov    %eax,0x1c5f8

    // 各队列初始化
    list_init(&task_manager.ready_list);
   11500:	83 ec 0c             	sub    $0xc,%esp
   11503:	68 04 c0 01 00       	push   $0x1c004
   11508:	e8 ca 58 00 00       	call   16dd7 <list_init>
   1150d:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.task_list);
   11510:	83 ec 0c             	sub    $0xc,%esp
   11513:	68 10 c0 01 00       	push   $0x1c010
   11518:	e8 ba 58 00 00       	call   16dd7 <list_init>
   1151d:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.sleep_list);
   11520:	83 ec 0c             	sub    $0xc,%esp
   11523:	68 1c c0 01 00       	push   $0x1c01c
   11528:	e8 aa 58 00 00       	call   16dd7 <list_init>
   1152d:	83 c4 10             	add    $0x10,%esp
    // 空闲任务初始化
    task_init(&task_manager.idle_task,
              "idle task",
              TASK_FLAGS_SYSTEM,
              (uint32_t)idle_task_entry,
              (uint32_t)(idle_task_stack + IDLE_STACK_SIZE)); // 里面的值不必要写
   11530:	b8 00 d6 01 00       	mov    $0x1d600,%eax
    task_init(&task_manager.idle_task,
   11535:	89 c2                	mov    %eax,%edx
   11537:	b8 81 14 01 00       	mov    $0x11481,%eax
   1153c:	83 ec 0c             	sub    $0xc,%esp
   1153f:	52                   	push   %edx
   11540:	50                   	push   %eax
   11541:	6a 01                	push   $0x1
   11543:	68 85 74 01 00       	push   $0x17485
   11548:	68 10 c3 01 00       	push   $0x1c310
   1154d:	e8 29 fd ff ff       	call   1127b <task_init>
   11552:	83 c4 20             	add    $0x20,%esp

    task_manager.current_task = (task_t *)0;
   11555:	c7 05 00 c0 01 00 00 	movl   $0x0,0x1c000
   1155c:	00 00 00 
    task_start(&task_manager.idle_task);
   1155f:	83 ec 0c             	sub    $0xc,%esp
   11562:	68 10 c3 01 00       	push   $0x1c310
   11567:	e8 ca fe ff ff       	call   11436 <task_start>
   1156c:	83 c4 10             	add    $0x10,%esp
}
   1156f:	90                   	nop
   11570:	c9                   	leave  
   11571:	c3                   	ret    

00011572 <task_first_init>:
 * 不过，考虑到init可能用到newlib库，如果与kernel合并编译，在lds中很难控制将newlib的
 * 代码与init进程的放在一起，有可能与kernel放在了一起。
 * 综上，最好是分离。
 */
void task_first_init(void)
{
   11572:	55                   	push   %ebp
   11573:	89 e5                	mov    %esp,%ebp
   11575:	83 ec 18             	sub    $0x18,%esp

    // 以下获得的是bin文件在内存中的物理地址
    extern uint8_t s_first_task[], e_first_task[];

    // 分配的空间比实际存储的空间要大一些，多余的用于放置栈
    uint32_t copy_size = (uint32_t)(e_first_task - s_first_task);
   11578:	ba 31 a2 05 00       	mov    $0x5a231,%edx
   1157d:	b8 90 9e 05 00       	mov    $0x59e90,%eax
   11582:	29 c2                	sub    %eax,%edx
   11584:	89 d0                	mov    %edx,%eax
   11586:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t alloc_size = 10 * MEM_PAGE_SIZE;
   11589:	c7 45 f0 00 a0 00 00 	movl   $0xa000,-0x10(%ebp)
    ASSERT(copy_size < alloc_size);
   11590:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11593:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   11596:	72 1c                	jb     115b4 <task_first_init+0x42>
   11598:	68 8f 74 01 00       	push   $0x1748f
   1159d:	68 70 75 01 00       	push   $0x17570
   115a2:	68 03 01 00 00       	push   $0x103
   115a7:	68 50 74 01 00       	push   $0x17450
   115ac:	e8 55 57 00 00       	call   16d06 <pannic>
   115b1:	83 c4 10             	add    $0x10,%esp

    uint32_t first_start = (uint32_t)first_task_entry;
   115b4:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%ebp)

    // 第一个任务代码量小一些，好和栈放在1个页面呢
    // 这样就不要立即考虑还要给栈分配空间的问题
    task_init(&task_manager.first_task, "first task", 0, first_start, first_start + alloc_size); // 里面的值不必要写
   115bb:	8b 55 ec             	mov    -0x14(%ebp),%edx
   115be:	8b 45 f0             	mov    -0x10(%ebp),%eax
   115c1:	01 d0                	add    %edx,%eax
   115c3:	83 ec 0c             	sub    $0xc,%esp
   115c6:	50                   	push   %eax
   115c7:	ff 75 ec             	pushl  -0x14(%ebp)
   115ca:	6a 00                	push   $0x0
   115cc:	68 a6 74 01 00       	push   $0x174a6
   115d1:	68 28 c0 01 00       	push   $0x1c028
   115d6:	e8 a0 fc ff ff       	call   1127b <task_init>
   115db:	83 c4 20             	add    $0x20,%esp
    task_manager.first_task.heap_start = (uint32_t)e_first_task;
   115de:	b8 31 a2 05 00       	mov    $0x5a231,%eax
   115e3:	a3 74 c0 01 00       	mov    %eax,0x1c074
    task_manager.first_task.heap_end = (uint32_t)e_first_task;
   115e8:	b8 31 a2 05 00       	mov    $0x5a231,%eax
   115ed:	a3 78 c0 01 00       	mov    %eax,0x1c078
    task_manager.current_task = &task_manager.first_task;
   115f2:	c7 05 00 c0 01 00 28 	movl   $0x1c028,0x1c000
   115f9:	c0 01 00 

    // 更新页表地址为自己的
    mmu_set_page_dir(task_manager.first_task.tss.cr3);
   115fc:	a1 c0 c2 01 00       	mov    0x1c2c0,%eax
   11601:	83 ec 0c             	sub    $0xc,%esp
   11604:	50                   	push   %eax
   11605:	e8 07 fa ff ff       	call   11011 <mmu_set_page_dir>
   1160a:	83 c4 10             	add    $0x10,%esp

    // 分配一页内存供代码存放使用，然后将代码复制过去
    memory_alloc_page_for(first_start, alloc_size, PTE_P | PTE_W | PTE_U);
   1160d:	83 ec 04             	sub    $0x4,%esp
   11610:	6a 07                	push   $0x7
   11612:	ff 75 f0             	pushl  -0x10(%ebp)
   11615:	ff 75 ec             	pushl  -0x14(%ebp)
   11618:	e8 78 f3 ff ff       	call   10995 <memory_alloc_page_for>
   1161d:	83 c4 10             	add    $0x10,%esp
    kernel_memcpy((void *)first_start, (void *)s_first_task, copy_size);
   11620:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11623:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11626:	83 ec 04             	sub    $0x4,%esp
   11629:	52                   	push   %edx
   1162a:	68 90 9e 05 00       	push   $0x59e90
   1162f:	50                   	push   %eax
   11630:	e8 9f 53 00 00       	call   169d4 <kernel_memcpy>
   11635:	83 c4 10             	add    $0x10,%esp

    // 启动进程
    task_start(&task_manager.first_task);
   11638:	83 ec 0c             	sub    $0xc,%esp
   1163b:	68 28 c0 01 00       	push   $0x1c028
   11640:	e8 f1 fd ff ff       	call   11436 <task_start>
   11645:	83 c4 10             	add    $0x10,%esp
    // 写TR寄存器，指示当前运行的第一个任务
    write_tr(task_manager.first_task.tss_sel);
   11648:	a1 0c c3 01 00       	mov    0x1c30c,%eax
   1164d:	83 ec 0c             	sub    $0xc,%esp
   11650:	50                   	push   %eax
   11651:	e8 5e f9 ff ff       	call   10fb4 <write_tr>
   11656:	83 c4 10             	add    $0x10,%esp
}
   11659:	90                   	nop
   1165a:	c9                   	leave  
   1165b:	c3                   	ret    

0001165c <task_first_task>:

/**
 * @brief 返回初始任务
 */
task_t *task_first_task(void)
{
   1165c:	55                   	push   %ebp
   1165d:	89 e5                	mov    %esp,%ebp
    return &task_manager.first_task;
   1165f:	b8 28 c0 01 00       	mov    $0x1c028,%eax
}
   11664:	5d                   	pop    %ebp
   11665:	c3                   	ret    

00011666 <task_set_ready>:

/**
 * @brief 将任务插入就绪队列
 */
void task_set_ready(task_t *task)
{
   11666:	55                   	push   %ebp
   11667:	89 e5                	mov    %esp,%ebp
   11669:	83 ec 08             	sub    $0x8,%esp
    if (task == &task_manager.idle_task)
   1166c:	81 7d 08 10 c3 01 00 	cmpl   $0x1c310,0x8(%ebp)
   11673:	74 24                	je     11699 <task_set_ready+0x33>
    {
        return;
    }
    task->state = TASK_READY;
   11675:	8b 45 08             	mov    0x8(%ebp),%eax
   11678:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    list_insert_last(&task_manager.ready_list, &task->run_node);
   1167e:	8b 45 08             	mov    0x8(%ebp),%eax
   11681:	05 64 02 00 00       	add    $0x264,%eax
   11686:	83 ec 08             	sub    $0x8,%esp
   11689:	50                   	push   %eax
   1168a:	68 04 c0 01 00       	push   $0x1c004
   1168f:	e8 c8 57 00 00       	call   16e5c <list_insert_last>
   11694:	83 c4 10             	add    $0x10,%esp
   11697:	eb 01                	jmp    1169a <task_set_ready+0x34>
        return;
   11699:	90                   	nop
}
   1169a:	c9                   	leave  
   1169b:	c3                   	ret    

0001169c <task_set_block>:

/**
 * @brief 将任务从就绪队列移除
 */
void task_set_block(task_t *task)
{
   1169c:	55                   	push   %ebp
   1169d:	89 e5                	mov    %esp,%ebp
   1169f:	83 ec 08             	sub    $0x8,%esp
    if (task != &task_manager.idle_task)
   116a2:	81 7d 08 10 c3 01 00 	cmpl   $0x1c310,0x8(%ebp)
   116a9:	74 19                	je     116c4 <task_set_block+0x28>
    {
        list_remove(&task_manager.ready_list, &task->run_node);
   116ab:	8b 45 08             	mov    0x8(%ebp),%eax
   116ae:	05 64 02 00 00       	add    $0x264,%eax
   116b3:	83 ec 08             	sub    $0x8,%esp
   116b6:	50                   	push   %eax
   116b7:	68 04 c0 01 00       	push   $0x1c004
   116bc:	e8 76 58 00 00       	call   16f37 <list_remove>
   116c1:	83 c4 10             	add    $0x10,%esp
    }
}
   116c4:	90                   	nop
   116c5:	c9                   	leave  
   116c6:	c3                   	ret    

000116c7 <task_next_run>:

/**
 * @brief 返回下一个要运行的任务
 */
static task_t *task_next_run(void)
{
   116c7:	55                   	push   %ebp
   116c8:	89 e5                	mov    %esp,%ebp
   116ca:	83 ec 10             	sub    $0x10,%esp
    // 如果没有任务，则运行空闲任务
    if (list_count(&task_manager.ready_list) == 0)
   116cd:	68 04 c0 01 00       	push   $0x1c004
   116d2:	e8 25 f9 ff ff       	call   10ffc <list_count>
   116d7:	83 c4 04             	add    $0x4,%esp
   116da:	85 c0                	test   %eax,%eax
   116dc:	75 07                	jne    116e5 <task_next_run+0x1e>
    {
        return &task_manager.idle_task;
   116de:	b8 10 c3 01 00       	mov    $0x1c310,%eax
   116e3:	eb 25                	jmp    1170a <task_next_run+0x43>
    }

    // 普通任务
    list_node_t *task_node = list_first(&task_manager.ready_list);
   116e5:	68 04 c0 01 00       	push   $0x1c004
   116ea:	e8 18 f9 ff ff       	call   11007 <list_first>
   116ef:	83 c4 04             	add    $0x4,%esp
   116f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return list_node_parent(task_node, task_t, run_node);
   116f5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   116f9:	74 0a                	je     11705 <task_next_run+0x3e>
   116fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   116fe:	2d 64 02 00 00       	sub    $0x264,%eax
   11703:	eb 05                	jmp    1170a <task_next_run+0x43>
   11705:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1170a:	c9                   	leave  
   1170b:	c3                   	ret    

0001170c <task_current>:

/**
 * @brief 返回当前任务
 */
task_t *task_current(void)
{
   1170c:	55                   	push   %ebp
   1170d:	89 e5                	mov    %esp,%ebp
    return task_manager.current_task;
   1170f:	a1 00 c0 01 00       	mov    0x1c000,%eax
}
   11714:	5d                   	pop    %ebp
   11715:	c3                   	ret    

00011716 <sys_yield>:

/**
 * @brief 任务调度 - 切换到下一个任务
 */
int sys_yield(void)
{
   11716:	55                   	push   %ebp
   11717:	89 e5                	mov    %esp,%ebp
   11719:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   1171c:	e8 5b 18 00 00       	call   12f7c <irq_enter_protection>
   11721:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (list_count(&task_manager.ready_list) > 1)
   11724:	83 ec 0c             	sub    $0xc,%esp
   11727:	68 04 c0 01 00       	push   $0x1c004
   1172c:	e8 cb f8 ff ff       	call   10ffc <list_count>
   11731:	83 c4 10             	add    $0x10,%esp
   11734:	83 f8 01             	cmp    $0x1,%eax
   11737:	7e 29                	jle    11762 <sys_yield+0x4c>
    {
        task_t *curr_task = task_current();
   11739:	e8 ce ff ff ff       	call   1170c <task_current>
   1173e:	89 45 f0             	mov    %eax,-0x10(%ebp)

        task_set_block(curr_task); // 将当前任务从就绪队列移除
   11741:	83 ec 0c             	sub    $0xc,%esp
   11744:	ff 75 f0             	pushl  -0x10(%ebp)
   11747:	e8 50 ff ff ff       	call   1169c <task_set_block>
   1174c:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task); // 将当前任务插入就绪队列尾部
   1174f:	83 ec 0c             	sub    $0xc,%esp
   11752:	ff 75 f0             	pushl  -0x10(%ebp)
   11755:	e8 0c ff ff ff       	call   11666 <task_set_ready>
   1175a:	83 c4 10             	add    $0x10,%esp

        task_dispatch(); // 调度下一个任务
   1175d:	e8 15 00 00 00       	call   11777 <task_dispatch>
    }
    irq_leave_protection(state);
   11762:	83 ec 0c             	sub    $0xc,%esp
   11765:	ff 75 f4             	pushl  -0xc(%ebp)
   11768:	e8 27 18 00 00       	call   12f94 <irq_leave_protection>
   1176d:	83 c4 10             	add    $0x10,%esp
    return 0;
   11770:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11775:	c9                   	leave  
   11776:	c3                   	ret    

00011777 <task_dispatch>:

/**
 * @brief 任务调度
 */
void task_dispatch(void)
{
   11777:	55                   	push   %ebp
   11778:	89 e5                	mov    %esp,%ebp
   1177a:	83 ec 18             	sub    $0x18,%esp
    task_t *to = task_next_run();
   1177d:	e8 45 ff ff ff       	call   116c7 <task_next_run>
   11782:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (to != task_manager.current_task)
   11785:	a1 00 c0 01 00       	mov    0x1c000,%eax
   1178a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   1178d:	74 2a                	je     117b9 <task_dispatch+0x42>
    {
        task_t *from = task_manager.current_task;
   1178f:	a1 00 c0 01 00       	mov    0x1c000,%eax
   11794:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_manager.current_task = to;
   11797:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1179a:	a3 00 c0 01 00       	mov    %eax,0x1c000

        to->state = TASK_RUNNING;
   1179f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117a2:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        task_switch_from_to(from, to);
   117a8:	83 ec 08             	sub    $0x8,%esp
   117ab:	ff 75 f4             	pushl  -0xc(%ebp)
   117ae:	ff 75 f0             	pushl  -0x10(%ebp)
   117b1:	e8 ad fc ff ff       	call   11463 <task_switch_from_to>
   117b6:	83 c4 10             	add    $0x10,%esp
    }
}
   117b9:	90                   	nop
   117ba:	c9                   	leave  
   117bb:	c3                   	ret    

000117bc <task_time_tick>:

/**
 * @brief 时间片到
 */
void task_time_tick(void)
{
   117bc:	55                   	push   %ebp
   117bd:	89 e5                	mov    %esp,%ebp
   117bf:	83 ec 28             	sub    $0x28,%esp
    task_t *curr_task = task_current();
   117c2:	e8 45 ff ff ff       	call   1170c <task_current>
   117c7:	89 45 f0             	mov    %eax,-0x10(%ebp)

    irq_state_t state = irq_enter_protection();
   117ca:	e8 ad 17 00 00       	call   12f7c <irq_enter_protection>
   117cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (--curr_task->slice_ticks == 0)
   117d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   117d5:	8b 40 58             	mov    0x58(%eax),%eax
   117d8:	8d 50 ff             	lea    -0x1(%eax),%edx
   117db:	8b 45 f0             	mov    -0x10(%ebp),%eax
   117de:	89 50 58             	mov    %edx,0x58(%eax)
   117e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   117e4:	8b 40 58             	mov    0x58(%eax),%eax
   117e7:	85 c0                	test   %eax,%eax
   117e9:	75 2d                	jne    11818 <task_time_tick+0x5c>
    {

        curr_task->slice_ticks = curr_task->time_ticks;
   117eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   117ee:	8b 50 5c             	mov    0x5c(%eax),%edx
   117f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   117f4:	89 50 58             	mov    %edx,0x58(%eax)

        task_set_block(curr_task); // 将当前任务从就绪队列移除
   117f7:	83 ec 0c             	sub    $0xc,%esp
   117fa:	ff 75 f0             	pushl  -0x10(%ebp)
   117fd:	e8 9a fe ff ff       	call   1169c <task_set_block>
   11802:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task); // 将当前任务插入就绪队列尾部
   11805:	83 ec 0c             	sub    $0xc,%esp
   11808:	ff 75 f0             	pushl  -0x10(%ebp)
   1180b:	e8 56 fe ff ff       	call   11666 <task_set_ready>
   11810:	83 c4 10             	add    $0x10,%esp

        task_dispatch(); // 调度下一个任务
   11813:	e8 5f ff ff ff       	call   11777 <task_dispatch>
    }

    list_node_t *curr = list_first(&task_manager.sleep_list);
   11818:	83 ec 0c             	sub    $0xc,%esp
   1181b:	68 1c c0 01 00       	push   $0x1c01c
   11820:	e8 e2 f7 ff ff       	call   11007 <list_first>
   11825:	83 c4 10             	add    $0x10,%esp
   11828:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while (curr)
   1182b:	eb 64                	jmp    11891 <task_time_tick+0xd5>
    {
        list_node_t *next = list_node_next(curr);
   1182d:	83 ec 0c             	sub    $0xc,%esp
   11830:	ff 75 f4             	pushl  -0xc(%ebp)
   11833:	e8 ba f7 ff ff       	call   10ff2 <list_node_next>
   11838:	83 c4 10             	add    $0x10,%esp
   1183b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        task_t *task = list_node_parent(curr, task_t, run_node);
   1183e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11842:	74 0a                	je     1184e <task_time_tick+0x92>
   11844:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11847:	2d 64 02 00 00       	sub    $0x264,%eax
   1184c:	eb 05                	jmp    11853 <task_time_tick+0x97>
   1184e:	b8 00 00 00 00       	mov    $0x0,%eax
   11853:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (--task->sleep_ticks == 0)
   11856:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11859:	8b 40 54             	mov    0x54(%eax),%eax
   1185c:	8d 50 ff             	lea    -0x1(%eax),%edx
   1185f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11862:	89 50 54             	mov    %edx,0x54(%eax)
   11865:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11868:	8b 40 54             	mov    0x54(%eax),%eax
   1186b:	85 c0                	test   %eax,%eax
   1186d:	75 1c                	jne    1188b <task_time_tick+0xcf>
        {
            task_set_wakeup(task);
   1186f:	83 ec 0c             	sub    $0xc,%esp
   11872:	ff 75 e4             	pushl  -0x1c(%ebp)
   11875:	e8 6f 00 00 00       	call   118e9 <task_set_wakeup>
   1187a:	83 c4 10             	add    $0x10,%esp
            task_set_ready(task);
   1187d:	83 ec 0c             	sub    $0xc,%esp
   11880:	ff 75 e4             	pushl  -0x1c(%ebp)
   11883:	e8 de fd ff ff       	call   11666 <task_set_ready>
   11888:	83 c4 10             	add    $0x10,%esp
        }

        curr = next;
   1188b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1188e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (curr)
   11891:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11895:	75 96                	jne    1182d <task_time_tick+0x71>
    }
    task_dispatch();
   11897:	e8 db fe ff ff       	call   11777 <task_dispatch>
    irq_leave_protection(state);
   1189c:	83 ec 0c             	sub    $0xc,%esp
   1189f:	ff 75 ec             	pushl  -0x14(%ebp)
   118a2:	e8 ed 16 00 00       	call   12f94 <irq_leave_protection>
   118a7:	83 c4 10             	add    $0x10,%esp
}
   118aa:	90                   	nop
   118ab:	c9                   	leave  
   118ac:	c3                   	ret    

000118ad <task_set_sleep>:
void task_set_sleep(task_t *task, uint32_t ticks)
{
   118ad:	55                   	push   %ebp
   118ae:	89 e5                	mov    %esp,%ebp
   118b0:	83 ec 08             	sub    $0x8,%esp
    if (ticks == 0)
   118b3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   118b7:	74 2d                	je     118e6 <task_set_sleep+0x39>
    {
        return;
    }

    task->sleep_ticks = ticks;
   118b9:	8b 55 0c             	mov    0xc(%ebp),%edx
   118bc:	8b 45 08             	mov    0x8(%ebp),%eax
   118bf:	89 50 54             	mov    %edx,0x54(%eax)
    task->state = TASK_SLEEP;
   118c2:	8b 45 08             	mov    0x8(%ebp),%eax
   118c5:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    list_insert_last(&task_manager.sleep_list, &task->run_node);
   118cb:	8b 45 08             	mov    0x8(%ebp),%eax
   118ce:	05 64 02 00 00       	add    $0x264,%eax
   118d3:	83 ec 08             	sub    $0x8,%esp
   118d6:	50                   	push   %eax
   118d7:	68 1c c0 01 00       	push   $0x1c01c
   118dc:	e8 7b 55 00 00       	call   16e5c <list_insert_last>
   118e1:	83 c4 10             	add    $0x10,%esp
   118e4:	eb 01                	jmp    118e7 <task_set_sleep+0x3a>
        return;
   118e6:	90                   	nop
}
   118e7:	c9                   	leave  
   118e8:	c3                   	ret    

000118e9 <task_set_wakeup>:
void task_set_wakeup(task_t *task)
{
   118e9:	55                   	push   %ebp
   118ea:	89 e5                	mov    %esp,%ebp
   118ec:	83 ec 08             	sub    $0x8,%esp
    list_remove(&task_manager.sleep_list, &task->run_node);
   118ef:	8b 45 08             	mov    0x8(%ebp),%eax
   118f2:	05 64 02 00 00       	add    $0x264,%eax
   118f7:	83 ec 08             	sub    $0x8,%esp
   118fa:	50                   	push   %eax
   118fb:	68 1c c0 01 00       	push   $0x1c01c
   11900:	e8 32 56 00 00       	call   16f37 <list_remove>
   11905:	83 c4 10             	add    $0x10,%esp
}
   11908:	90                   	nop
   11909:	c9                   	leave  
   1190a:	c3                   	ret    

0001190b <sys_msleep>:

void sys_msleep(uint32_t ms)
{
   1190b:	55                   	push   %ebp
   1190c:	89 e5                	mov    %esp,%ebp
   1190e:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   11911:	e8 66 16 00 00       	call   12f7c <irq_enter_protection>
   11916:	89 45 f4             	mov    %eax,-0xc(%ebp)

    task_t *curr_task = task_current();
   11919:	e8 ee fd ff ff       	call   1170c <task_current>
   1191e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    task_set_block(curr_task);
   11921:	83 ec 0c             	sub    $0xc,%esp
   11924:	ff 75 f0             	pushl  -0x10(%ebp)
   11927:	e8 70 fd ff ff       	call   1169c <task_set_block>
   1192c:	83 c4 10             	add    $0x10,%esp

    task_set_sleep(curr_task, (ms + (OS_TICK_MS - 1)) / OS_TICK_MS);
   1192f:	8b 45 08             	mov    0x8(%ebp),%eax
   11932:	83 c0 09             	add    $0x9,%eax
   11935:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
   1193a:	f7 e2                	mul    %edx
   1193c:	89 d0                	mov    %edx,%eax
   1193e:	c1 e8 03             	shr    $0x3,%eax
   11941:	83 ec 08             	sub    $0x8,%esp
   11944:	50                   	push   %eax
   11945:	ff 75 f0             	pushl  -0x10(%ebp)
   11948:	e8 60 ff ff ff       	call   118ad <task_set_sleep>
   1194d:	83 c4 10             	add    $0x10,%esp
    task_dispatch();
   11950:	e8 22 fe ff ff       	call   11777 <task_dispatch>
    irq_leave_protection(state);
   11955:	83 ec 0c             	sub    $0xc,%esp
   11958:	ff 75 f4             	pushl  -0xc(%ebp)
   1195b:	e8 34 16 00 00       	call   12f94 <irq_leave_protection>
   11960:	83 c4 10             	add    $0x10,%esp
}
   11963:	90                   	nop
   11964:	c9                   	leave  
   11965:	c3                   	ret    

00011966 <sys_getpid>:

int sys_getpid(void)
{
   11966:	55                   	push   %ebp
   11967:	89 e5                	mov    %esp,%ebp
   11969:	83 ec 10             	sub    $0x10,%esp
    task_t *task = task_current();
   1196c:	e8 9b fd ff ff       	call   1170c <task_current>
   11971:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return task->pid;
   11974:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11977:	8b 40 44             	mov    0x44(%eax),%eax
}
   1197a:	c9                   	leave  
   1197b:	c3                   	ret    

0001197c <alloc_task>:

static task_t *alloc_task(void)
{
   1197c:	55                   	push   %ebp
   1197d:	89 e5                	mov    %esp,%ebp
   1197f:	83 ec 18             	sub    $0x18,%esp
    task_t *task = (task_t *)0;
   11982:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    mutex_lock(&task_table_mutex);
   11989:	83 ec 0c             	sub    $0xc,%esp
   1198c:	68 00 4a 03 00       	push   $0x34a00
   11991:	e8 dd 49 00 00       	call   16373 <mutex_lock>
   11996:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < TASK_NR; i++)
   11999:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   119a0:	eb 28                	jmp    119ca <alloc_task+0x4e>
    {
        task_t *curr = task_table + i;
   119a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   119a5:	69 c0 e8 02 00 00    	imul   $0x2e8,%eax,%eax
   119ab:	05 00 d6 01 00       	add    $0x1d600,%eax
   119b0:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (curr->name[0] == 0)
   119b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119b6:	0f b6 40 04          	movzbl 0x4(%eax),%eax
   119ba:	84 c0                	test   %al,%al
   119bc:	75 08                	jne    119c6 <alloc_task+0x4a>
        {
            task = curr;
   119be:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
   119c4:	eb 0a                	jmp    119d0 <alloc_task+0x54>
    for (int i = 0; i < TASK_NR; i++)
   119c6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   119ca:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
   119ce:	7e d2                	jle    119a2 <alloc_task+0x26>
        }
    }
    mutex_unlock(&task_table_mutex);
   119d0:	83 ec 0c             	sub    $0xc,%esp
   119d3:	68 00 4a 03 00       	push   $0x34a00
   119d8:	e8 2d 4a 00 00       	call   1640a <mutex_unlock>
   119dd:	83 c4 10             	add    $0x10,%esp
    return task;
   119e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   119e3:	c9                   	leave  
   119e4:	c3                   	ret    

000119e5 <free_task>:

static void free_task(task_t *task)
{
   119e5:	55                   	push   %ebp
   119e6:	89 e5                	mov    %esp,%ebp
   119e8:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&task_table_mutex);
   119eb:	83 ec 0c             	sub    $0xc,%esp
   119ee:	68 00 4a 03 00       	push   $0x34a00
   119f3:	e8 7b 49 00 00       	call   16373 <mutex_lock>
   119f8:	83 c4 10             	add    $0x10,%esp
    // kernel_memset(task, 0, sizeof(task_t));
    task->name[0] = 0;
   119fb:	8b 45 08             	mov    0x8(%ebp),%eax
   119fe:	c6 40 04 00          	movb   $0x0,0x4(%eax)
    mutex_unlock(&task_table_mutex);
   11a02:	83 ec 0c             	sub    $0xc,%esp
   11a05:	68 00 4a 03 00       	push   $0x34a00
   11a0a:	e8 fb 49 00 00       	call   1640a <mutex_unlock>
   11a0f:	83 c4 10             	add    $0x10,%esp
}
   11a12:	90                   	nop
   11a13:	c9                   	leave  
   11a14:	c3                   	ret    

00011a15 <copy_opened_files>:
static void copy_opened_files(task_t *child_task)
{
   11a15:	55                   	push   %ebp
   11a16:	89 e5                	mov    %esp,%ebp
   11a18:	83 ec 18             	sub    $0x18,%esp
    task_t *parent_task = task_current();
   11a1b:	e8 ec fc ff ff       	call   1170c <task_current>
   11a20:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (int i = 0; i < TASK_OFILE_NR; i++)
   11a23:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11a2a:	eb 38                	jmp    11a64 <copy_opened_files+0x4f>
    {
        file_t *file = parent_task->file_table[i];
   11a2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a32:	83 c2 18             	add    $0x18,%edx
   11a35:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   11a39:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (file)
   11a3c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11a40:	74 1e                	je     11a60 <copy_opened_files+0x4b>
        {
            file_inc_ref(file);
   11a42:	83 ec 0c             	sub    $0xc,%esp
   11a45:	ff 75 ec             	pushl  -0x14(%ebp)
   11a48:	e8 23 3c 00 00       	call   15670 <file_inc_ref>
   11a4d:	83 c4 10             	add    $0x10,%esp
            child_task->file_table[i] = file;
   11a50:	8b 45 08             	mov    0x8(%ebp),%eax
   11a53:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a56:	8d 4a 18             	lea    0x18(%edx),%ecx
   11a59:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11a5c:	89 54 88 04          	mov    %edx,0x4(%eax,%ecx,4)
    for (int i = 0; i < TASK_OFILE_NR; i++)
   11a60:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11a64:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   11a68:	7e c2                	jle    11a2c <copy_opened_files+0x17>
        }
    }
}
   11a6a:	90                   	nop
   11a6b:	c9                   	leave  
   11a6c:	c3                   	ret    

00011a6d <sys_fork>:
int sys_fork(void)
{
   11a6d:	55                   	push   %ebp
   11a6e:	89 e5                	mov    %esp,%ebp
   11a70:	83 ec 28             	sub    $0x28,%esp
    task_t *parent_task = task_current();
   11a73:	e8 94 fc ff ff       	call   1170c <task_current>
   11a78:	89 45 f4             	mov    %eax,-0xc(%ebp)

    task_t *child_task = alloc_task();
   11a7b:	e8 fc fe ff ff       	call   1197c <alloc_task>
   11a80:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (child_task == (task_t *)0)
   11a83:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11a87:	0f 84 4f 01 00 00    	je     11bdc <sys_fork+0x16f>
    {
        goto fork_failed;
    }
    syscall_frame_t *parent_frame = (syscall_frame_t *)(parent_task->tss.esp0 - sizeof(syscall_frame_t));
   11a8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a90:	8b 80 80 02 00 00    	mov    0x280(%eax),%eax
   11a96:	83 e8 58             	sub    $0x58,%eax
   11a99:	89 45 ec             	mov    %eax,-0x14(%ebp)
    int err = task_init(child_task, parent_task->name, 0, parent_frame->eip, parent_frame->esp + sizeof(uint32_t) * SYSCALL_PARAM_COUNT);
   11a9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a9f:	8b 40 50             	mov    0x50(%eax),%eax
   11aa2:	8d 50 14             	lea    0x14(%eax),%edx
   11aa5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11aa8:	8b 40 34             	mov    0x34(%eax),%eax
   11aab:	89 c1                	mov    %eax,%ecx
   11aad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ab0:	83 c0 04             	add    $0x4,%eax
   11ab3:	83 ec 0c             	sub    $0xc,%esp
   11ab6:	52                   	push   %edx
   11ab7:	51                   	push   %ecx
   11ab8:	6a 00                	push   $0x0
   11aba:	50                   	push   %eax
   11abb:	ff 75 f0             	pushl  -0x10(%ebp)
   11abe:	e8 b8 f7 ff ff       	call   1127b <task_init>
   11ac3:	83 c4 20             	add    $0x20,%esp
   11ac6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (err < 0)
   11ac9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11acd:	0f 88 0c 01 00 00    	js     11bdf <sys_fork+0x172>
    {
        goto fork_failed;
    }
    copy_opened_files(child_task);
   11ad3:	83 ec 0c             	sub    $0xc,%esp
   11ad6:	ff 75 f0             	pushl  -0x10(%ebp)
   11ad9:	e8 37 ff ff ff       	call   11a15 <copy_opened_files>
   11ade:	83 c4 10             	add    $0x10,%esp


    tss_t *child_tss = &child_task->tss;
   11ae1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ae4:	05 7c 02 00 00       	add    $0x27c,%eax
   11ae9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    child_tss->eax = 0;
   11aec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11aef:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
    child_tss->ebx = parent_frame->ebx;
   11af6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11af9:	8b 40 24             	mov    0x24(%eax),%eax
   11afc:	89 c2                	mov    %eax,%edx
   11afe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b01:	89 50 34             	mov    %edx,0x34(%eax)
    child_tss->ecx = parent_frame->ecx;
   11b04:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b07:	8b 40 2c             	mov    0x2c(%eax),%eax
   11b0a:	89 c2                	mov    %eax,%edx
   11b0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b0f:	89 50 2c             	mov    %edx,0x2c(%eax)
    child_tss->edx = parent_frame->edx;
   11b12:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b15:	8b 40 28             	mov    0x28(%eax),%eax
   11b18:	89 c2                	mov    %eax,%edx
   11b1a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b1d:	89 50 30             	mov    %edx,0x30(%eax)
    child_tss->esi = parent_frame->esi;
   11b20:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b23:	8b 40 18             	mov    0x18(%eax),%eax
   11b26:	89 c2                	mov    %eax,%edx
   11b28:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b2b:	89 50 40             	mov    %edx,0x40(%eax)
    child_tss->edi = parent_frame->edi;
   11b2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b31:	8b 40 14             	mov    0x14(%eax),%eax
   11b34:	89 c2                	mov    %eax,%edx
   11b36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b39:	89 50 44             	mov    %edx,0x44(%eax)
    child_tss->ebp = parent_frame->ebp;
   11b3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b3f:	8b 40 1c             	mov    0x1c(%eax),%eax
   11b42:	89 c2                	mov    %eax,%edx
   11b44:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b47:	89 50 3c             	mov    %edx,0x3c(%eax)

    child_tss->cs = parent_frame->cs;
   11b4a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b4d:	8b 40 38             	mov    0x38(%eax),%eax
   11b50:	89 c2                	mov    %eax,%edx
   11b52:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b55:	89 50 4c             	mov    %edx,0x4c(%eax)
    child_tss->ds = parent_frame->ds;
   11b58:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b5b:	8b 40 10             	mov    0x10(%eax),%eax
   11b5e:	89 c2                	mov    %eax,%edx
   11b60:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b63:	89 50 54             	mov    %edx,0x54(%eax)
    child_tss->es = parent_frame->es;
   11b66:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b69:	8b 40 0c             	mov    0xc(%eax),%eax
   11b6c:	89 c2                	mov    %eax,%edx
   11b6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b71:	89 50 48             	mov    %edx,0x48(%eax)
    child_tss->fs = parent_frame->fs;
   11b74:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b77:	8b 40 08             	mov    0x8(%eax),%eax
   11b7a:	89 c2                	mov    %eax,%edx
   11b7c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b7f:	89 50 58             	mov    %edx,0x58(%eax)
    child_tss->gs = parent_frame->gs;
   11b82:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b85:	8b 40 04             	mov    0x4(%eax),%eax
   11b88:	89 c2                	mov    %eax,%edx
   11b8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b8d:	89 50 5c             	mov    %edx,0x5c(%eax)
    child_tss->eflags = parent_frame->eflags;
   11b90:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b93:	8b 00                	mov    (%eax),%eax
   11b95:	89 c2                	mov    %eax,%edx
   11b97:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b9a:	89 50 24             	mov    %edx,0x24(%eax)

    child_task->parent = parent_task;
   11b9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ba0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11ba3:	89 50 48             	mov    %edx,0x48(%eax)

    if ((child_task->tss.cr3 = memory_copy_uvm(parent_task->tss.cr3)) < 0)
   11ba6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ba9:	8b 80 98 02 00 00    	mov    0x298(%eax),%eax
   11baf:	83 ec 0c             	sub    $0xc,%esp
   11bb2:	50                   	push   %eax
   11bb3:	e8 07 f0 ff ff       	call   10bbf <memory_copy_uvm>
   11bb8:	83 c4 10             	add    $0x10,%esp
   11bbb:	89 c2                	mov    %eax,%edx
   11bbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11bc0:	89 90 98 02 00 00    	mov    %edx,0x298(%eax)
    {
        goto fork_failed;
    }
    task_start(child_task);
   11bc6:	83 ec 0c             	sub    $0xc,%esp
   11bc9:	ff 75 f0             	pushl  -0x10(%ebp)
   11bcc:	e8 65 f8 ff ff       	call   11436 <task_start>
   11bd1:	83 c4 10             	add    $0x10,%esp
    return child_task->pid;
   11bd4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11bd7:	8b 40 44             	mov    0x44(%eax),%eax
   11bda:	eb 2b                	jmp    11c07 <sys_fork+0x19a>
        goto fork_failed;
   11bdc:	90                   	nop
   11bdd:	eb 01                	jmp    11be0 <sys_fork+0x173>
        goto fork_failed;
   11bdf:	90                   	nop
fork_failed:
    if (child_task)
   11be0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11be4:	74 1c                	je     11c02 <sys_fork+0x195>
    {
        task_uninit(child_task);
   11be6:	83 ec 0c             	sub    $0xc,%esp
   11be9:	ff 75 f0             	pushl  -0x10(%ebp)
   11bec:	e8 bf f7 ff ff       	call   113b0 <task_uninit>
   11bf1:	83 c4 10             	add    $0x10,%esp
        free_task(child_task);
   11bf4:	83 ec 0c             	sub    $0xc,%esp
   11bf7:	ff 75 f0             	pushl  -0x10(%ebp)
   11bfa:	e8 e6 fd ff ff       	call   119e5 <free_task>
   11bff:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   11c02:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11c07:	c9                   	leave  
   11c08:	c3                   	ret    

00011c09 <load_phdr>:

static int load_phdr(int file, Elf32_Phdr *phdr, uint32_t page_dir)
{
   11c09:	55                   	push   %ebp
   11c0a:	89 e5                	mov    %esp,%ebp
   11c0c:	83 ec 28             	sub    $0x28,%esp
    int err = memory_alloc_for_page_dir(
   11c0f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c12:	8b 50 14             	mov    0x14(%eax),%edx
   11c15:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c18:	8b 40 08             	mov    0x8(%eax),%eax
   11c1b:	6a 07                	push   $0x7
   11c1d:	52                   	push   %edx
   11c1e:	50                   	push   %eax
   11c1f:	ff 75 10             	pushl  0x10(%ebp)
   11c22:	e8 85 ec ff ff       	call   108ac <memory_alloc_for_page_dir>
   11c27:	83 c4 10             	add    $0x10,%esp
   11c2a:	89 45 ec             	mov    %eax,-0x14(%ebp)
        page_dir,
        phdr->p_vaddr,
        phdr->p_memsz,
        PTE_P | PTE_U | PTE_W);
    if (err < 0)
   11c2d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11c31:	79 1a                	jns    11c4d <load_phdr+0x44>
    {
        log_printf("alloc memory failed\n");
   11c33:	83 ec 0c             	sub    $0xc,%esp
   11c36:	68 b1 74 01 00       	push   $0x174b1
   11c3b:	e8 bf 53 00 00       	call   16fff <log_printf>
   11c40:	83 c4 10             	add    $0x10,%esp
        return -1;
   11c43:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11c48:	e9 b8 00 00 00       	jmp    11d05 <load_phdr+0xfc>
    }
    if (sys_lseek(file, phdr->p_offset, 0) < 0)
   11c4d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c50:	8b 40 04             	mov    0x4(%eax),%eax
   11c53:	83 ec 04             	sub    $0x4,%esp
   11c56:	6a 00                	push   $0x0
   11c58:	50                   	push   %eax
   11c59:	ff 75 08             	pushl  0x8(%ebp)
   11c5c:	e8 93 3f 00 00       	call   15bf4 <sys_lseek>
   11c61:	83 c4 10             	add    $0x10,%esp
   11c64:	85 c0                	test   %eax,%eax
   11c66:	79 1a                	jns    11c82 <load_phdr+0x79>
    {
        log_printf("lseek file failed\n");
   11c68:	83 ec 0c             	sub    $0xc,%esp
   11c6b:	68 c6 74 01 00       	push   $0x174c6
   11c70:	e8 8a 53 00 00       	call   16fff <log_printf>
   11c75:	83 c4 10             	add    $0x10,%esp
        return -1;
   11c78:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11c7d:	e9 83 00 00 00       	jmp    11d05 <load_phdr+0xfc>
    }
    uint32_t vaddr = phdr->p_vaddr;
   11c82:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c85:	8b 40 08             	mov    0x8(%eax),%eax
   11c88:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t size = phdr->p_filesz;
   11c8b:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c8e:	8b 40 10             	mov    0x10(%eax),%eax
   11c91:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while (size > 0)
   11c94:	eb 64                	jmp    11cfa <load_phdr+0xf1>
    {
        int curr_size = (size > MEM_PAGE_SIZE) ? MEM_PAGE_SIZE : size;
   11c96:	b8 00 10 00 00       	mov    $0x1000,%eax
   11c9b:	81 7d f0 00 10 00 00 	cmpl   $0x1000,-0x10(%ebp)
   11ca2:	0f 46 45 f0          	cmovbe -0x10(%ebp),%eax
   11ca6:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t paddr = memory_get_paddr(page_dir, vaddr);
   11ca9:	83 ec 08             	sub    $0x8,%esp
   11cac:	ff 75 f4             	pushl  -0xc(%ebp)
   11caf:	ff 75 10             	pushl  0x10(%ebp)
   11cb2:	e8 5d f0 ff ff       	call   10d14 <memory_get_paddr>
   11cb7:	83 c4 10             	add    $0x10,%esp
   11cba:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if (sys_read(file, (char *)paddr, curr_size) < curr_size)
   11cbd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11cc0:	83 ec 04             	sub    $0x4,%esp
   11cc3:	ff 75 e8             	pushl  -0x18(%ebp)
   11cc6:	50                   	push   %eax
   11cc7:	ff 75 08             	pushl  0x8(%ebp)
   11cca:	e8 64 3d 00 00       	call   15a33 <sys_read>
   11ccf:	83 c4 10             	add    $0x10,%esp
   11cd2:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   11cd5:	7e 17                	jle    11cee <load_phdr+0xe5>
        {
            log_printf("read file failed\n");
   11cd7:	83 ec 0c             	sub    $0xc,%esp
   11cda:	68 d9 74 01 00       	push   $0x174d9
   11cdf:	e8 1b 53 00 00       	call   16fff <log_printf>
   11ce4:	83 c4 10             	add    $0x10,%esp
            return -1;
   11ce7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11cec:	eb 17                	jmp    11d05 <load_phdr+0xfc>
        }
        size -= curr_size;
   11cee:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11cf1:	29 45 f0             	sub    %eax,-0x10(%ebp)
        vaddr += curr_size;
   11cf4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11cf7:	01 45 f4             	add    %eax,-0xc(%ebp)
    while (size > 0)
   11cfa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11cfe:	75 96                	jne    11c96 <load_phdr+0x8d>
    }
    return 0;
   11d00:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11d05:	c9                   	leave  
   11d06:	c3                   	ret    

00011d07 <load_elf_file>:

static uint32_t load_elf_file(task_t *task, char *name, uint32_t page_dir)
{
   11d07:	55                   	push   %ebp
   11d08:	89 e5                	mov    %esp,%ebp
   11d0a:	83 ec 78             	sub    $0x78,%esp
    Elf32_Ehdr elf_hdr;
    Elf32_Phdr elf_phdr;

    int file = sys_open(name, 0);
   11d0d:	83 ec 08             	sub    $0x8,%esp
   11d10:	6a 00                	push   $0x0
   11d12:	ff 75 0c             	pushl  0xc(%ebp)
   11d15:	e8 26 3b 00 00       	call   15840 <sys_open>
   11d1a:	83 c4 10             	add    $0x10,%esp
   11d1d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (file < 0)
   11d20:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11d24:	79 18                	jns    11d3e <load_elf_file+0x37>
    {
        log_printf("open file %s failed\n", name);
   11d26:	83 ec 08             	sub    $0x8,%esp
   11d29:	ff 75 0c             	pushl  0xc(%ebp)
   11d2c:	68 eb 74 01 00       	push   $0x174eb
   11d31:	e8 c9 52 00 00       	call   16fff <log_printf>
   11d36:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11d39:	e9 76 01 00 00       	jmp    11eb4 <load_elf_file+0x1ad>
    }
    int cnt = sys_read(file, (char *)&elf_hdr, sizeof(Elf32_Ehdr));
   11d3e:	83 ec 04             	sub    $0x4,%esp
   11d41:	6a 34                	push   $0x34
   11d43:	8d 45 b0             	lea    -0x50(%ebp),%eax
   11d46:	50                   	push   %eax
   11d47:	ff 75 ec             	pushl  -0x14(%ebp)
   11d4a:	e8 e4 3c 00 00       	call   15a33 <sys_read>
   11d4f:	83 c4 10             	add    $0x10,%esp
   11d52:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if (cnt < sizeof(Elf32_Ehdr))
   11d55:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11d58:	83 f8 33             	cmp    $0x33,%eax
   11d5b:	77 18                	ja     11d75 <load_elf_file+0x6e>
    {
        log_printf("read file %s failed\n", name);
   11d5d:	83 ec 08             	sub    $0x8,%esp
   11d60:	ff 75 0c             	pushl  0xc(%ebp)
   11d63:	68 00 75 01 00       	push   $0x17500
   11d68:	e8 92 52 00 00       	call   16fff <log_printf>
   11d6d:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11d70:	e9 3f 01 00 00       	jmp    11eb4 <load_elf_file+0x1ad>
    }

    if (elf_hdr.e_ident[0] != 0x7f ||
   11d75:	0f b6 45 b0          	movzbl -0x50(%ebp),%eax
   11d79:	3c 7f                	cmp    $0x7f,%al
   11d7b:	75 18                	jne    11d95 <load_elf_file+0x8e>
        elf_hdr.e_ident[1] != 'E' ||
   11d7d:	0f b6 45 b1          	movzbl -0x4f(%ebp),%eax
    if (elf_hdr.e_ident[0] != 0x7f ||
   11d81:	3c 45                	cmp    $0x45,%al
   11d83:	75 10                	jne    11d95 <load_elf_file+0x8e>
        elf_hdr.e_ident[2] != 'L' ||
   11d85:	0f b6 45 b2          	movzbl -0x4e(%ebp),%eax
        elf_hdr.e_ident[1] != 'E' ||
   11d89:	3c 4c                	cmp    $0x4c,%al
   11d8b:	75 08                	jne    11d95 <load_elf_file+0x8e>
        elf_hdr.e_ident[3] != 'F')
   11d8d:	0f b6 45 b3          	movzbl -0x4d(%ebp),%eax
        elf_hdr.e_ident[2] != 'L' ||
   11d91:	3c 46                	cmp    $0x46,%al
   11d93:	74 18                	je     11dad <load_elf_file+0xa6>
    {
        log_printf("file %s is not a elf file\n", name);
   11d95:	83 ec 08             	sub    $0x8,%esp
   11d98:	ff 75 0c             	pushl  0xc(%ebp)
   11d9b:	68 15 75 01 00       	push   $0x17515
   11da0:	e8 5a 52 00 00       	call   16fff <log_printf>
   11da5:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11da8:	e9 07 01 00 00       	jmp    11eb4 <load_elf_file+0x1ad>
    }

    uint32_t e_phoff = elf_hdr.e_phoff;
   11dad:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11db0:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for (int i = 0; i < elf_hdr.e_phnum; i++, e_phoff += elf_hdr.e_phentsize)
   11db3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11dba:	e9 88 00 00 00       	jmp    11e47 <load_elf_file+0x140>
    {
        if (sys_lseek(file, e_phoff, 0) < 0)
   11dbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11dc2:	83 ec 04             	sub    $0x4,%esp
   11dc5:	6a 00                	push   $0x0
   11dc7:	50                   	push   %eax
   11dc8:	ff 75 ec             	pushl  -0x14(%ebp)
   11dcb:	e8 24 3e 00 00       	call   15bf4 <sys_lseek>
   11dd0:	83 c4 10             	add    $0x10,%esp
   11dd3:	85 c0                	test   %eax,%eax
   11dd5:	79 18                	jns    11def <load_elf_file+0xe8>
        {
            log_printf("lseek file %s failed\n", name);
   11dd7:	83 ec 08             	sub    $0x8,%esp
   11dda:	ff 75 0c             	pushl  0xc(%ebp)
   11ddd:	68 30 75 01 00       	push   $0x17530
   11de2:	e8 18 52 00 00       	call   16fff <log_printf>
   11de7:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11dea:	e9 c5 00 00 00       	jmp    11eb4 <load_elf_file+0x1ad>
        }
        cnt = sys_read(file, (char *)&elf_phdr, sizeof(elf_phdr));
   11def:	83 ec 04             	sub    $0x4,%esp
   11df2:	6a 20                	push   $0x20
   11df4:	8d 45 90             	lea    -0x70(%ebp),%eax
   11df7:	50                   	push   %eax
   11df8:	ff 75 ec             	pushl  -0x14(%ebp)
   11dfb:	e8 33 3c 00 00       	call   15a33 <sys_read>
   11e00:	83 c4 10             	add    $0x10,%esp
   11e03:	89 45 e8             	mov    %eax,-0x18(%ebp)

        if (cnt < sizeof(elf_phdr))
   11e06:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11e09:	83 f8 1f             	cmp    $0x1f,%eax
   11e0c:	77 18                	ja     11e26 <load_elf_file+0x11f>
        {
            log_printf("read file %s failed\n", name);
   11e0e:	83 ec 08             	sub    $0x8,%esp
   11e11:	ff 75 0c             	pushl  0xc(%ebp)
   11e14:	68 00 75 01 00       	push   $0x17500
   11e19:	e8 e1 51 00 00       	call   16fff <log_printf>
   11e1e:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11e21:	e9 8e 00 00 00       	jmp    11eb4 <load_elf_file+0x1ad>
        }
        if ((elf_phdr.p_type != PT_LOAD) || (elf_phdr.p_vaddr > MEMORY_TASK_BASE))
   11e26:	8b 45 90             	mov    -0x70(%ebp),%eax
   11e29:	83 f8 01             	cmp    $0x1,%eax
   11e2c:	75 0a                	jne    11e38 <load_elf_file+0x131>
   11e2e:	8b 45 98             	mov    -0x68(%ebp),%eax
   11e31:	3d 00 00 00 80       	cmp    $0x80000000,%eax
   11e36:	eb 01                	jmp    11e39 <load_elf_file+0x132>
        {
            continue;
   11e38:	90                   	nop
    for (int i = 0; i < elf_hdr.e_phnum; i++, e_phoff += elf_hdr.e_phentsize)
   11e39:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11e3d:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
   11e41:	0f b7 c0             	movzwl %ax,%eax
   11e44:	01 45 f4             	add    %eax,-0xc(%ebp)
   11e47:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
   11e4b:	0f b7 c0             	movzwl %ax,%eax
   11e4e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11e51:	0f 8c 68 ff ff ff    	jl     11dbf <load_elf_file+0xb8>
        }
    }
    int err = load_phdr(file, &elf_phdr, page_dir);
   11e57:	83 ec 04             	sub    $0x4,%esp
   11e5a:	ff 75 10             	pushl  0x10(%ebp)
   11e5d:	8d 45 90             	lea    -0x70(%ebp),%eax
   11e60:	50                   	push   %eax
   11e61:	ff 75 ec             	pushl  -0x14(%ebp)
   11e64:	e8 a0 fd ff ff       	call   11c09 <load_phdr>
   11e69:	83 c4 10             	add    $0x10,%esp
   11e6c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (err < 0)
   11e6f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   11e73:	79 12                	jns    11e87 <load_elf_file+0x180>
    {
        log_printf("load phdr failed\n");
   11e75:	83 ec 0c             	sub    $0xc,%esp
   11e78:	68 46 75 01 00       	push   $0x17546
   11e7d:	e8 7d 51 00 00       	call   16fff <log_printf>
   11e82:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11e85:	eb 2d                	jmp    11eb4 <load_elf_file+0x1ad>
    }
    sys_close(file);
   11e87:	83 ec 0c             	sub    $0xc,%esp
   11e8a:	ff 75 ec             	pushl  -0x14(%ebp)
   11e8d:	e8 14 3e 00 00       	call   15ca6 <sys_close>
   11e92:	83 c4 10             	add    $0x10,%esp
    task->heap_start = elf_phdr.p_vaddr + elf_phdr.p_memsz;
   11e95:	8b 55 98             	mov    -0x68(%ebp),%edx
   11e98:	8b 45 a4             	mov    -0x5c(%ebp),%eax
   11e9b:	01 c2                	add    %eax,%edx
   11e9d:	8b 45 08             	mov    0x8(%ebp),%eax
   11ea0:	89 50 4c             	mov    %edx,0x4c(%eax)
    task->heap_end = task->heap_start;
   11ea3:	8b 45 08             	mov    0x8(%ebp),%eax
   11ea6:	8b 50 4c             	mov    0x4c(%eax),%edx
   11ea9:	8b 45 08             	mov    0x8(%ebp),%eax
   11eac:	89 50 50             	mov    %edx,0x50(%eax)
    return elf_hdr.e_entry;
   11eaf:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11eb2:	eb 19                	jmp    11ecd <load_elf_file+0x1c6>
load_failed:
    if (file)
   11eb4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11eb8:	74 0e                	je     11ec8 <load_elf_file+0x1c1>
    {
        sys_close(file);
   11eba:	83 ec 0c             	sub    $0xc,%esp
   11ebd:	ff 75 ec             	pushl  -0x14(%ebp)
   11ec0:	e8 e1 3d 00 00       	call   15ca6 <sys_close>
   11ec5:	83 c4 10             	add    $0x10,%esp
    }
    return 0;
   11ec8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11ecd:	c9                   	leave  
   11ece:	c3                   	ret    

00011ecf <copy_args>:

static int copy_args(char *to, uint32_t page_dir, int argc, char **argv)
{
   11ecf:	55                   	push   %ebp
   11ed0:	89 e5                	mov    %esp,%ebp
   11ed2:	83 ec 38             	sub    $0x38,%esp
    task_args_t task_args;
    task_args.argc = argc;
   11ed5:	8b 45 10             	mov    0x10(%ebp),%eax
   11ed8:	89 45 d8             	mov    %eax,-0x28(%ebp)
    task_args.argv = (char **)(to + sizeof(task_args_t));
   11edb:	8b 45 08             	mov    0x8(%ebp),%eax
   11ede:	83 c0 0c             	add    $0xc,%eax
   11ee1:	89 45 dc             	mov    %eax,-0x24(%ebp)

    char *dest_arg = to + sizeof(task_args_t) + sizeof(char *) * argc;
   11ee4:	8b 45 10             	mov    0x10(%ebp),%eax
   11ee7:	83 c0 03             	add    $0x3,%eax
   11eea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11ef1:	8b 45 08             	mov    0x8(%ebp),%eax
   11ef4:	01 d0                	add    %edx,%eax
   11ef6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char **dest_arg_tb = (char **)memory_get_paddr(page_dir, (uint32_t)(to + sizeof(task_args_t)));
   11ef9:	8b 45 08             	mov    0x8(%ebp),%eax
   11efc:	83 c0 0c             	add    $0xc,%eax
   11eff:	83 ec 08             	sub    $0x8,%esp
   11f02:	50                   	push   %eax
   11f03:	ff 75 0c             	pushl  0xc(%ebp)
   11f06:	e8 09 ee ff ff       	call   10d14 <memory_get_paddr>
   11f0b:	83 c4 10             	add    $0x10,%esp
   11f0e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for (int i = 0; i < argc; i++)
   11f11:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11f18:	e9 82 00 00 00       	jmp    11f9f <copy_args+0xd0>
    {
        char *from = argv[i];
   11f1d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11f20:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11f27:	8b 45 14             	mov    0x14(%ebp),%eax
   11f2a:	01 d0                	add    %edx,%eax
   11f2c:	8b 00                	mov    (%eax),%eax
   11f2e:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int len = kernel_strlen(from) + 1;
   11f31:	83 ec 0c             	sub    $0xc,%esp
   11f34:	ff 75 e8             	pushl  -0x18(%ebp)
   11f37:	e8 63 4a 00 00       	call   1699f <kernel_strlen>
   11f3c:	83 c4 10             	add    $0x10,%esp
   11f3f:	83 c0 01             	add    $0x1,%eax
   11f42:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int err = memor_copy_uvm_data((uint32_t)dest_arg, page_dir, (uint32_t)from, len);
   11f45:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   11f48:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11f4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f4e:	51                   	push   %ecx
   11f4f:	52                   	push   %edx
   11f50:	ff 75 0c             	pushl  0xc(%ebp)
   11f53:	50                   	push   %eax
   11f54:	e8 01 ee ff ff       	call   10d5a <memor_copy_uvm_data>
   11f59:	83 c4 10             	add    $0x10,%esp
   11f5c:	89 45 e0             	mov    %eax,-0x20(%ebp)
        ASSERT(err >= 0);
   11f5f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11f63:	79 1c                	jns    11f81 <copy_args+0xb2>
   11f65:	68 58 75 01 00       	push   $0x17558
   11f6a:	68 80 75 01 00       	push   $0x17580
   11f6f:	68 89 02 00 00       	push   $0x289
   11f74:	68 50 74 01 00       	push   $0x17450
   11f79:	e8 88 4d 00 00       	call   16d06 <pannic>
   11f7e:	83 c4 10             	add    $0x10,%esp
        dest_arg_tb[i] = dest_arg;
   11f81:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11f84:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11f8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11f8e:	01 c2                	add    %eax,%edx
   11f90:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f93:	89 02                	mov    %eax,(%edx)
        dest_arg += len;
   11f95:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11f98:	01 45 f4             	add    %eax,-0xc(%ebp)
    for (int i = 0; i < argc; i++)
   11f9b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11f9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11fa2:	3b 45 10             	cmp    0x10(%ebp),%eax
   11fa5:	0f 8c 72 ff ff ff    	jl     11f1d <copy_args+0x4e>
    }
    return memor_copy_uvm_data((uint32_t)to, page_dir, (uint32_t)&task_args, sizeof(task_args));
   11fab:	8d 55 d4             	lea    -0x2c(%ebp),%edx
   11fae:	8b 45 08             	mov    0x8(%ebp),%eax
   11fb1:	6a 0c                	push   $0xc
   11fb3:	52                   	push   %edx
   11fb4:	ff 75 0c             	pushl  0xc(%ebp)
   11fb7:	50                   	push   %eax
   11fb8:	e8 9d ed ff ff       	call   10d5a <memor_copy_uvm_data>
   11fbd:	83 c4 10             	add    $0x10,%esp
}
   11fc0:	c9                   	leave  
   11fc1:	c3                   	ret    

00011fc2 <sys_execve>:

int sys_execve(char *name, char **argv, char **env)
{
   11fc2:	55                   	push   %ebp
   11fc3:	89 e5                	mov    %esp,%ebp
   11fc5:	83 ec 28             	sub    $0x28,%esp
    task_t *task = task_current();
   11fc8:	e8 3f f7 ff ff       	call   1170c <task_current>
   11fcd:	89 45 f4             	mov    %eax,-0xc(%ebp)

    kernel_strncpy(task->name, get_file_name(name), TASK_NAME_SIZE);
   11fd0:	83 ec 0c             	sub    $0xc,%esp
   11fd3:	ff 75 08             	pushl  0x8(%ebp)
   11fd6:	e8 8e 4d 00 00       	call   16d69 <get_file_name>
   11fdb:	83 c4 10             	add    $0x10,%esp
   11fde:	89 c2                	mov    %eax,%edx
   11fe0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11fe3:	83 c0 04             	add    $0x4,%eax
   11fe6:	83 ec 04             	sub    $0x4,%esp
   11fe9:	6a 40                	push   $0x40
   11feb:	52                   	push   %edx
   11fec:	50                   	push   %eax
   11fed:	e8 bf 48 00 00       	call   168b1 <kernel_strncpy>
   11ff2:	83 c4 10             	add    $0x10,%esp

    uint32_t old_page_dir = task->tss.cr3;
   11ff5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ff8:	8b 80 98 02 00 00    	mov    0x298(%eax),%eax
   11ffe:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t new_page_dir = memory_create_uvm();
   12001:	e8 21 e8 ff ff       	call   10827 <memory_create_uvm>
   12006:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if (!new_page_dir)
   12009:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1200d:	0f 84 2d 01 00 00    	je     12140 <sys_execve+0x17e>
    {
        goto execve_failed;
    }

    uint32_t entry = load_elf_file(task, name, new_page_dir);
   12013:	83 ec 04             	sub    $0x4,%esp
   12016:	ff 75 ec             	pushl  -0x14(%ebp)
   12019:	ff 75 08             	pushl  0x8(%ebp)
   1201c:	ff 75 f4             	pushl  -0xc(%ebp)
   1201f:	e8 e3 fc ff ff       	call   11d07 <load_elf_file>
   12024:	83 c4 10             	add    $0x10,%esp
   12027:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if (entry == 0)
   1202a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1202e:	0f 84 0f 01 00 00    	je     12143 <sys_execve+0x181>
    {
        goto execve_failed;
    }
    uint32_t stack_top = MEM_TASK_STACK_TOP - MEM_TASK_ARG_SIZE;
   12034:	c7 45 e4 00 00 ff df 	movl   $0xdfff0000,-0x1c(%ebp)
    int err = memory_alloc_for_page_dir(
   1203b:	6a 07                	push   $0x7
   1203d:	68 00 40 1f 00       	push   $0x1f4000
   12042:	68 00 c0 e0 df       	push   $0xdfe0c000
   12047:	ff 75 ec             	pushl  -0x14(%ebp)
   1204a:	e8 5d e8 ff ff       	call   108ac <memory_alloc_for_page_dir>
   1204f:	83 c4 10             	add    $0x10,%esp
   12052:	89 45 e0             	mov    %eax,-0x20(%ebp)
        new_page_dir,
        MEM_TASK_STACK_TOP - MEM_TASK_STACK_SIZE,
        MEM_TASK_STACK_SIZE,
        PTE_P | PTE_U | PTE_W);
    if (err < 0)
   12055:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   12059:	0f 88 e7 00 00 00    	js     12146 <sys_execve+0x184>
    {
        goto execve_failed;
    }

    int arg_num = string_count(argv);
   1205f:	83 ec 0c             	sub    $0xc,%esp
   12062:	ff 75 0c             	pushl  0xc(%ebp)
   12065:	e8 d2 4c 00 00       	call   16d3c <string_count>
   1206a:	83 c4 10             	add    $0x10,%esp
   1206d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    err = copy_args((char *)stack_top, new_page_dir, arg_num, argv);
   12070:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12073:	ff 75 0c             	pushl  0xc(%ebp)
   12076:	ff 75 dc             	pushl  -0x24(%ebp)
   12079:	ff 75 ec             	pushl  -0x14(%ebp)
   1207c:	50                   	push   %eax
   1207d:	e8 4d fe ff ff       	call   11ecf <copy_args>
   12082:	83 c4 10             	add    $0x10,%esp
   12085:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (err < 0)
   12088:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1208c:	0f 88 b7 00 00 00    	js     12149 <sys_execve+0x187>
    {
        goto execve_failed;
    }
    syscall_frame_t *frame = (syscall_frame_t *)(task->tss.esp0 - sizeof(syscall_frame_t));
   12092:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12095:	8b 80 80 02 00 00    	mov    0x280(%eax),%eax
   1209b:	83 e8 58             	sub    $0x58,%eax
   1209e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    frame->eip = entry;
   120a1:	8b 55 e8             	mov    -0x18(%ebp),%edx
   120a4:	8b 45 d8             	mov    -0x28(%ebp),%eax
   120a7:	89 50 34             	mov    %edx,0x34(%eax)
    frame->eax = frame->edx = frame->ecx = frame->ebx = 0;
   120aa:	8b 45 d8             	mov    -0x28(%ebp),%eax
   120ad:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
   120b4:	8b 45 d8             	mov    -0x28(%ebp),%eax
   120b7:	8b 50 24             	mov    0x24(%eax),%edx
   120ba:	8b 45 d8             	mov    -0x28(%ebp),%eax
   120bd:	89 50 2c             	mov    %edx,0x2c(%eax)
   120c0:	8b 45 d8             	mov    -0x28(%ebp),%eax
   120c3:	8b 50 2c             	mov    0x2c(%eax),%edx
   120c6:	8b 45 d8             	mov    -0x28(%ebp),%eax
   120c9:	89 50 28             	mov    %edx,0x28(%eax)
   120cc:	8b 45 d8             	mov    -0x28(%ebp),%eax
   120cf:	8b 50 28             	mov    0x28(%eax),%edx
   120d2:	8b 45 d8             	mov    -0x28(%ebp),%eax
   120d5:	89 50 30             	mov    %edx,0x30(%eax)
    frame->esi = frame->edi = frame->ebp = 0;
   120d8:	8b 45 d8             	mov    -0x28(%ebp),%eax
   120db:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
   120e2:	8b 45 d8             	mov    -0x28(%ebp),%eax
   120e5:	8b 50 1c             	mov    0x1c(%eax),%edx
   120e8:	8b 45 d8             	mov    -0x28(%ebp),%eax
   120eb:	89 50 14             	mov    %edx,0x14(%eax)
   120ee:	8b 45 d8             	mov    -0x28(%ebp),%eax
   120f1:	8b 50 14             	mov    0x14(%eax),%edx
   120f4:	8b 45 d8             	mov    -0x28(%ebp),%eax
   120f7:	89 50 18             	mov    %edx,0x18(%eax)
    frame->eflags = EFALGS_IF | EFALGS_DEFAULT;
   120fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
   120fd:	c7 00 02 02 00 00    	movl   $0x202,(%eax)
    frame->esp = stack_top - sizeof(uint32_t) * SYSCALL_PARAM_COUNT;
   12103:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12106:	83 e8 14             	sub    $0x14,%eax
   12109:	89 c2                	mov    %eax,%edx
   1210b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1210e:	89 50 50             	mov    %edx,0x50(%eax)

    // 更新当前的页目录
    task->tss.cr3 = new_page_dir;
   12111:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12114:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12117:	89 90 98 02 00 00    	mov    %edx,0x298(%eax)
    mmu_set_page_dir(new_page_dir);
   1211d:	83 ec 0c             	sub    $0xc,%esp
   12120:	ff 75 ec             	pushl  -0x14(%ebp)
   12123:	e8 e9 ee ff ff       	call   11011 <mmu_set_page_dir>
   12128:	83 c4 10             	add    $0x10,%esp

    memory_destroy_uvm(old_page_dir);
   1212b:	83 ec 0c             	sub    $0xc,%esp
   1212e:	ff 75 f0             	pushl  -0x10(%ebp)
   12131:	e8 7a e9 ff ff       	call   10ab0 <memory_destroy_uvm>
   12136:	83 c4 10             	add    $0x10,%esp
    return 0;
   12139:	b8 00 00 00 00       	mov    $0x0,%eax
   1213e:	eb 3d                	jmp    1217d <sys_execve+0x1bb>
        goto execve_failed;
   12140:	90                   	nop
   12141:	eb 07                	jmp    1214a <sys_execve+0x188>
        goto execve_failed;
   12143:	90                   	nop
   12144:	eb 04                	jmp    1214a <sys_execve+0x188>
        goto execve_failed;
   12146:	90                   	nop
   12147:	eb 01                	jmp    1214a <sys_execve+0x188>
        goto execve_failed;
   12149:	90                   	nop
execve_failed:
    if (new_page_dir)
   1214a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1214e:	74 28                	je     12178 <sys_execve+0x1b6>
    {
        task->tss.cr3 = old_page_dir;
   12150:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12153:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12156:	89 90 98 02 00 00    	mov    %edx,0x298(%eax)
        mmu_set_page_dir(old_page_dir);
   1215c:	83 ec 0c             	sub    $0xc,%esp
   1215f:	ff 75 f0             	pushl  -0x10(%ebp)
   12162:	e8 aa ee ff ff       	call   11011 <mmu_set_page_dir>
   12167:	83 c4 10             	add    $0x10,%esp
        memory_destroy_uvm(new_page_dir);
   1216a:	83 ec 0c             	sub    $0xc,%esp
   1216d:	ff 75 ec             	pushl  -0x14(%ebp)
   12170:	e8 3b e9 ff ff       	call   10ab0 <memory_destroy_uvm>
   12175:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   12178:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   1217d:	c9                   	leave  
   1217e:	c3                   	ret    

0001217f <sys_exit>:

void sys_exit(int status)
{
   1217f:	55                   	push   %ebp
   12180:	89 e5                	mov    %esp,%ebp
   12182:	83 ec 28             	sub    $0x28,%esp
    task_t *curr_task = task_current();
   12185:	e8 82 f5 ff ff       	call   1170c <task_current>
   1218a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    for (int fd = 0; fd < TASK_OFILE_NR; fd++)
   1218d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12194:	eb 39                	jmp    121cf <sys_exit+0x50>
    {
        file_t *file = curr_task->file_table[fd];
   12196:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12199:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1219c:	83 c2 18             	add    $0x18,%edx
   1219f:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
   121a3:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if (file)
   121a6:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   121aa:	74 1f                	je     121cb <sys_exit+0x4c>
        {
            sys_close(fd);
   121ac:	83 ec 0c             	sub    $0xc,%esp
   121af:	ff 75 f4             	pushl  -0xc(%ebp)
   121b2:	e8 ef 3a 00 00       	call   15ca6 <sys_close>
   121b7:	83 c4 10             	add    $0x10,%esp
            curr_task->file_table[fd] = (file_t *)0;
   121ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
   121bd:	8b 55 f4             	mov    -0xc(%ebp),%edx
   121c0:	83 c2 18             	add    $0x18,%edx
   121c3:	c7 44 90 04 00 00 00 	movl   $0x0,0x4(%eax,%edx,4)
   121ca:	00 
    for (int fd = 0; fd < TASK_OFILE_NR; fd++)
   121cb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   121cf:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   121d3:	7e c1                	jle    12196 <sys_exit+0x17>
        }
    }

    int move_child = 0;
   121d5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    mutex_lock(&task_table_mutex);
   121dc:	83 ec 0c             	sub    $0xc,%esp
   121df:	68 00 4a 03 00       	push   $0x34a00
   121e4:	e8 8a 41 00 00       	call   16373 <mutex_lock>
   121e9:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < TASK_NR; i++)
   121ec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   121f3:	eb 31                	jmp    12226 <sys_exit+0xa7>
    {
        task_t *task = task_table + i;
   121f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   121f8:	69 c0 e8 02 00 00    	imul   $0x2e8,%eax,%eax
   121fe:	05 00 d6 01 00       	add    $0x1d600,%eax
   12203:	89 45 dc             	mov    %eax,-0x24(%ebp)
        if (task->parent == curr_task)
   12206:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12209:	8b 40 48             	mov    0x48(%eax),%eax
   1220c:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   1220f:	75 11                	jne    12222 <sys_exit+0xa3>
        {
            task->parent = (task_t *)0;
   12211:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12214:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
            move_child = 1;
   1221b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    for (int i = 0; i < TASK_NR; i++)
   12222:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12226:	83 7d ec 7f          	cmpl   $0x7f,-0x14(%ebp)
   1222a:	7e c9                	jle    121f5 <sys_exit+0x76>
        }
    }
    mutex_unlock(&task_table_mutex);
   1222c:	83 ec 0c             	sub    $0xc,%esp
   1222f:	68 00 4a 03 00       	push   $0x34a00
   12234:	e8 d1 41 00 00       	call   1640a <mutex_unlock>
   12239:	83 c4 10             	add    $0x10,%esp

    int state = irq_enter_protection();
   1223c:	e8 3b 0d 00 00       	call   12f7c <irq_enter_protection>
   12241:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    // 如果有移动子进程，则唤醒init进程
    task_t *parent = curr_task->parent;
   12244:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12247:	8b 40 48             	mov    0x48(%eax),%eax
   1224a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (move_child && (parent != &task_manager.first_task))
   1224d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   12251:	74 23                	je     12276 <sys_exit+0xf7>
   12253:	81 7d e0 28 c0 01 00 	cmpl   $0x1c028,-0x20(%ebp)
   1225a:	74 1a                	je     12276 <sys_exit+0xf7>
    {
        if (task_manager.first_task.state == TASK_WAITTING)
   1225c:	a1 28 c0 01 00       	mov    0x1c028,%eax
   12261:	83 f8 04             	cmp    $0x4,%eax
   12264:	75 10                	jne    12276 <sys_exit+0xf7>
        {
            task_set_ready(&task_manager.first_task);
   12266:	83 ec 0c             	sub    $0xc,%esp
   12269:	68 28 c0 01 00       	push   $0x1c028
   1226e:	e8 f3 f3 ff ff       	call   11666 <task_set_ready>
   12273:	83 c4 10             	add    $0x10,%esp
        }
    }

    // 如果有父任务在wait，则唤醒父任务进行回收
    // 如果父进程没有等待，则一直处理僵死状态？
    if (parent->state == TASK_WAITTING)
   12276:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12279:	8b 00                	mov    (%eax),%eax
   1227b:	83 f8 04             	cmp    $0x4,%eax
   1227e:	75 0e                	jne    1228e <sys_exit+0x10f>
    {
        task_set_ready(parent);
   12280:	83 ec 0c             	sub    $0xc,%esp
   12283:	ff 75 e0             	pushl  -0x20(%ebp)
   12286:	e8 db f3 ff ff       	call   11666 <task_set_ready>
   1228b:	83 c4 10             	add    $0x10,%esp
    }

    curr_task->exit_status = status;
   1228e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12291:	8b 55 08             	mov    0x8(%ebp),%edx
   12294:	89 50 60             	mov    %edx,0x60(%eax)
    curr_task->state = TASK_ZOMBIE;
   12297:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1229a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    task_set_block(curr_task);
   122a0:	83 ec 0c             	sub    $0xc,%esp
   122a3:	ff 75 e8             	pushl  -0x18(%ebp)
   122a6:	e8 f1 f3 ff ff       	call   1169c <task_set_block>
   122ab:	83 c4 10             	add    $0x10,%esp
    task_dispatch();
   122ae:	e8 c4 f4 ff ff       	call   11777 <task_dispatch>
    irq_leave_protection(state);
   122b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   122b6:	83 ec 0c             	sub    $0xc,%esp
   122b9:	50                   	push   %eax
   122ba:	e8 d5 0c 00 00       	call   12f94 <irq_leave_protection>
   122bf:	83 c4 10             	add    $0x10,%esp
}
   122c2:	90                   	nop
   122c3:	c9                   	leave  
   122c4:	c3                   	ret    

000122c5 <sys_wait>:

int sys_wait(int *status)
{
   122c5:	55                   	push   %ebp
   122c6:	89 e5                	mov    %esp,%ebp
   122c8:	83 ec 28             	sub    $0x28,%esp
    task_t *curr_task = task_current();
   122cb:	e8 3c f4 ff ff       	call   1170c <task_current>
   122d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (;;)
    {
        mutex_lock(&task_table_mutex);
   122d3:	83 ec 0c             	sub    $0xc,%esp
   122d6:	68 00 4a 03 00       	push   $0x34a00
   122db:	e8 93 40 00 00       	call   16373 <mutex_lock>
   122e0:	83 c4 10             	add    $0x10,%esp
        for (int i = 0; i < TASK_NR; i++)
   122e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   122ea:	e9 98 00 00 00       	jmp    12387 <sys_wait+0xc2>
        {
            task_t *task = task_table + i;
   122ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
   122f2:	69 c0 e8 02 00 00    	imul   $0x2e8,%eax,%eax
   122f8:	05 00 d6 01 00       	add    $0x1d600,%eax
   122fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
            if (task->parent != curr_task)
   12300:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12303:	8b 40 48             	mov    0x48(%eax),%eax
   12306:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12309:	75 77                	jne    12382 <sys_wait+0xbd>
            {
                continue;
            }

            if (task->state == TASK_ZOMBIE)
   1230b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1230e:	8b 00                	mov    (%eax),%eax
   12310:	83 f8 05             	cmp    $0x5,%eax
   12313:	75 6e                	jne    12383 <sys_wait+0xbe>
            {
                int pid = task->pid;
   12315:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12318:	8b 40 44             	mov    0x44(%eax),%eax
   1231b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                *status = task->exit_status;
   1231e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12321:	8b 50 60             	mov    0x60(%eax),%edx
   12324:	8b 45 08             	mov    0x8(%ebp),%eax
   12327:	89 10                	mov    %edx,(%eax)
                memory_destroy_uvm(task->tss.cr3);
   12329:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1232c:	8b 80 98 02 00 00    	mov    0x298(%eax),%eax
   12332:	83 ec 0c             	sub    $0xc,%esp
   12335:	50                   	push   %eax
   12336:	e8 75 e7 ff ff       	call   10ab0 <memory_destroy_uvm>
   1233b:	83 c4 10             	add    $0x10,%esp
                memory_free_page(task->tss.esp0 - MEM_PAGE_SIZE);
   1233e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12341:	8b 80 80 02 00 00    	mov    0x280(%eax),%eax
   12347:	2d 00 10 00 00       	sub    $0x1000,%eax
   1234c:	83 ec 0c             	sub    $0xc,%esp
   1234f:	50                   	push   %eax
   12350:	e8 ae e6 ff ff       	call   10a03 <memory_free_page>
   12355:	83 c4 10             	add    $0x10,%esp
                kernel_memset((void *)task, 0, sizeof(task_t));
   12358:	83 ec 04             	sub    $0x4,%esp
   1235b:	68 e8 02 00 00       	push   $0x2e8
   12360:	6a 00                	push   $0x0
   12362:	ff 75 e8             	pushl  -0x18(%ebp)
   12365:	e8 b9 46 00 00       	call   16a23 <kernel_memset>
   1236a:	83 c4 10             	add    $0x10,%esp
                mutex_unlock(&task_table_mutex);
   1236d:	83 ec 0c             	sub    $0xc,%esp
   12370:	68 00 4a 03 00       	push   $0x34a00
   12375:	e8 90 40 00 00       	call   1640a <mutex_unlock>
   1237a:	83 c4 10             	add    $0x10,%esp
                return pid;
   1237d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12380:	eb 58                	jmp    123da <sys_wait+0x115>
                continue;
   12382:	90                   	nop
        for (int i = 0; i < TASK_NR; i++)
   12383:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12387:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   1238b:	0f 8e 5e ff ff ff    	jle    122ef <sys_wait+0x2a>
            }
        }
        mutex_unlock(&task_table_mutex);
   12391:	83 ec 0c             	sub    $0xc,%esp
   12394:	68 00 4a 03 00       	push   $0x34a00
   12399:	e8 6c 40 00 00       	call   1640a <mutex_unlock>
   1239e:	83 c4 10             	add    $0x10,%esp
        irq_state_t state = irq_enter_protection();
   123a1:	e8 d6 0b 00 00       	call   12f7c <irq_enter_protection>
   123a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_block(curr_task);
   123a9:	83 ec 0c             	sub    $0xc,%esp
   123ac:	ff 75 f0             	pushl  -0x10(%ebp)
   123af:	e8 e8 f2 ff ff       	call   1169c <task_set_block>
   123b4:	83 c4 10             	add    $0x10,%esp
        curr_task->state = TASK_WAITTING;
   123b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   123ba:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
        task_dispatch();
   123c0:	e8 b2 f3 ff ff       	call   11777 <task_dispatch>
        mutex_unlock(&task_table_mutex);
   123c5:	83 ec 0c             	sub    $0xc,%esp
   123c8:	68 00 4a 03 00       	push   $0x34a00
   123cd:	e8 38 40 00 00       	call   1640a <mutex_unlock>
   123d2:	83 c4 10             	add    $0x10,%esp
    {
   123d5:	e9 f9 fe ff ff       	jmp    122d3 <sys_wait+0xe>
    }

    return 0;
   123da:	c9                   	leave  
   123db:	c3                   	ret    

000123dc <lgdt>:
{
   123dc:	55                   	push   %ebp
   123dd:	89 e5                	mov    %esp,%ebp
   123df:	83 ec 10             	sub    $0x10,%esp
    gdt.start31_16 = start >> 16;
   123e2:	8b 45 08             	mov    0x8(%ebp),%eax
   123e5:	c1 e8 10             	shr    $0x10,%eax
   123e8:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    gdt.start15_0 = start & 0xFFFF;
   123ec:	8b 45 08             	mov    0x8(%ebp),%eax
   123ef:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    gdt.limit = size - 1;
   123f3:	8b 45 0c             	mov    0xc(%ebp),%eax
   123f6:	83 e8 01             	sub    $0x1,%eax
   123f9:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__("lgdt %[g]" ::[g] "m"(gdt));
   123fd:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
}
   12401:	90                   	nop
   12402:	c9                   	leave  
   12403:	c3                   	ret    

00012404 <far_jump>:
{
   12404:	55                   	push   %ebp
   12405:	89 e5                	mov    %esp,%ebp
   12407:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[] = {offset, selector};
   1240a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1240d:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12410:	8b 45 08             	mov    0x8(%ebp),%eax
   12413:	89 45 fc             	mov    %eax,-0x4(%ebp)
    __asm__ __volatile__("ljmpl *(%[a])" ::[a] "r"(addr));
   12416:	8d 45 f8             	lea    -0x8(%ebp),%eax
   12419:	ff 28                	ljmp   *(%eax)
}
   1241b:	90                   	nop
   1241c:	c9                   	leave  
   1241d:	c3                   	ret    

0001241e <list_node_prev>:
{
   1241e:	55                   	push   %ebp
   1241f:	89 e5                	mov    %esp,%ebp
    return node->prev;
   12421:	8b 45 08             	mov    0x8(%ebp),%eax
   12424:	8b 40 04             	mov    0x4(%eax),%eax
}
   12427:	5d                   	pop    %ebp
   12428:	c3                   	ret    

00012429 <list_node_next>:
{
   12429:	55                   	push   %ebp
   1242a:	89 e5                	mov    %esp,%ebp
    return node->next;
   1242c:	8b 45 08             	mov    0x8(%ebp),%eax
   1242f:	8b 00                	mov    (%eax),%eax
}
   12431:	5d                   	pop    %ebp
   12432:	c3                   	ret    

00012433 <segment_desc_set>:
 * @param base 基地址
 * @param limit 段限长
 * @param attr 属性
 */
void segment_desc_set(int selector, uint32_t base, uint32_t limit, uint16_t attr)
{
   12433:	55                   	push   %ebp
   12434:	89 e5                	mov    %esp,%ebp
   12436:	83 ec 14             	sub    $0x14,%esp
   12439:	8b 45 14             	mov    0x14(%ebp),%eax
   1243c:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    segment_desc_t *desc = gdt_table + selector / sizeof(segment_desc_t);
   12440:	8b 45 08             	mov    0x8(%ebp),%eax
   12443:	83 e0 f8             	and    $0xfffffff8,%eax
   12446:	05 20 4a 03 00       	add    $0x34a20,%eax
   1244b:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if (limit > 0xfffff)
   1244e:	81 7d 10 ff ff 0f 00 	cmpl   $0xfffff,0x10(%ebp)
   12455:	76 0f                	jbe    12466 <segment_desc_set+0x33>
    {
        attr |= 0x8000;
   12457:	66 81 4d ec 00 80    	orw    $0x8000,-0x14(%ebp)
        limit /= 0x1000;
   1245d:	8b 45 10             	mov    0x10(%ebp),%eax
   12460:	c1 e8 0c             	shr    $0xc,%eax
   12463:	89 45 10             	mov    %eax,0x10(%ebp)
    }

    desc->limit15_0 = limit & 0xffff;
   12466:	8b 45 10             	mov    0x10(%ebp),%eax
   12469:	89 c2                	mov    %eax,%edx
   1246b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1246e:	66 89 10             	mov    %dx,(%eax)
    desc->base15_0 = base & 0xffff;
   12471:	8b 45 0c             	mov    0xc(%ebp),%eax
   12474:	89 c2                	mov    %eax,%edx
   12476:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12479:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->base23_16 = (base >> 16) & 0xff;
   1247d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12480:	c1 e8 10             	shr    $0x10,%eax
   12483:	89 c2                	mov    %eax,%edx
   12485:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12488:	88 50 04             	mov    %dl,0x4(%eax)
    desc->attr = attr | ((limit >> 16) & 0xf) << 8;
   1248b:	8b 45 10             	mov    0x10(%ebp),%eax
   1248e:	c1 e8 10             	shr    $0x10,%eax
   12491:	c1 e0 08             	shl    $0x8,%eax
   12494:	66 25 00 0f          	and    $0xf00,%ax
   12498:	66 0b 45 ec          	or     -0x14(%ebp),%ax
   1249c:	89 c2                	mov    %eax,%edx
   1249e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   124a1:	66 89 50 05          	mov    %dx,0x5(%eax)
    desc->base31_24 = (base >> 24) & 0xff;
   124a5:	8b 45 0c             	mov    0xc(%ebp),%eax
   124a8:	c1 e8 18             	shr    $0x18,%eax
   124ab:	89 c2                	mov    %eax,%edx
   124ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
   124b0:	88 50 07             	mov    %dl,0x7(%eax)
}
   124b3:	90                   	nop
   124b4:	c9                   	leave  
   124b5:	c3                   	ret    

000124b6 <gate_desc_set>:
 * @param selector 选择子
 * @param offset 偏移
 * @param attr 属性
 */
void gate_desc_set(gate_desc_t *desc, uint16_t selector, uint32_t offset, uint16_t attr)
{
   124b6:	55                   	push   %ebp
   124b7:	89 e5                	mov    %esp,%ebp
   124b9:	83 ec 08             	sub    $0x8,%esp
   124bc:	8b 55 0c             	mov    0xc(%ebp),%edx
   124bf:	8b 45 14             	mov    0x14(%ebp),%eax
   124c2:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   124c6:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    desc->offset15_0 = offset & 0xffff;
   124ca:	8b 45 10             	mov    0x10(%ebp),%eax
   124cd:	89 c2                	mov    %eax,%edx
   124cf:	8b 45 08             	mov    0x8(%ebp),%eax
   124d2:	66 89 10             	mov    %dx,(%eax)
    desc->selector = selector;
   124d5:	8b 45 08             	mov    0x8(%ebp),%eax
   124d8:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   124dc:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->attr = attr;
   124e0:	8b 45 08             	mov    0x8(%ebp),%eax
   124e3:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
   124e7:	66 89 50 04          	mov    %dx,0x4(%eax)
    desc->offset31_16 = (offset >> 16) & 0xffff;
   124eb:	8b 45 10             	mov    0x10(%ebp),%eax
   124ee:	c1 e8 10             	shr    $0x10,%eax
   124f1:	89 c2                	mov    %eax,%edx
   124f3:	8b 45 08             	mov    0x8(%ebp),%eax
   124f6:	66 89 50 06          	mov    %dx,0x6(%eax)
}
   124fa:	90                   	nop
   124fb:	c9                   	leave  
   124fc:	c3                   	ret    

000124fd <gdt_alloc_desc>:

int gdt_alloc_desc(void)
{
   124fd:	55                   	push   %ebp
   124fe:	89 e5                	mov    %esp,%ebp
   12500:	83 ec 18             	sub    $0x18,%esp
    // irq_state_t state = irq_enter_protection();
    mutex_lock(&mutex);
   12503:	83 ec 0c             	sub    $0xc,%esp
   12506:	68 20 52 03 00       	push   $0x35220
   1250b:	e8 63 3e 00 00       	call   16373 <mutex_lock>
   12510:	83 c4 10             	add    $0x10,%esp
    for (int i = 1; i < GDT_TABLE_SIZE; i++)
   12513:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   1251a:	eb 2c                	jmp    12548 <gdt_alloc_desc+0x4b>
    {
        if (gdt_table[i].attr == 0)
   1251c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1251f:	0f b7 04 c5 25 4a 03 	movzwl 0x34a25(,%eax,8),%eax
   12526:	00 
   12527:	66 85 c0             	test   %ax,%ax
   1252a:	75 18                	jne    12544 <gdt_alloc_desc+0x47>
        {
            // irq_leave_protection(state);
            mutex_unlock(&mutex);
   1252c:	83 ec 0c             	sub    $0xc,%esp
   1252f:	68 20 52 03 00       	push   $0x35220
   12534:	e8 d1 3e 00 00       	call   1640a <mutex_unlock>
   12539:	83 c4 10             	add    $0x10,%esp
            return i * sizeof(segment_desc_t);
   1253c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1253f:	c1 e0 03             	shl    $0x3,%eax
   12542:	eb 22                	jmp    12566 <gdt_alloc_desc+0x69>
    for (int i = 1; i < GDT_TABLE_SIZE; i++)
   12544:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12548:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   1254f:	7e cb                	jle    1251c <gdt_alloc_desc+0x1f>
        }
    }
    // irq_leave_protection(state);
    mutex_unlock(&mutex);
   12551:	83 ec 0c             	sub    $0xc,%esp
   12554:	68 20 52 03 00       	push   $0x35220
   12559:	e8 ac 3e 00 00       	call   1640a <mutex_unlock>
   1255e:	83 c4 10             	add    $0x10,%esp
    return -1;
   12561:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   12566:	c9                   	leave  
   12567:	c3                   	ret    

00012568 <gdt_free_sel>:

void gdt_free_sel(int sel)
{
   12568:	55                   	push   %ebp
   12569:	89 e5                	mov    %esp,%ebp
   1256b:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&mutex);
   1256e:	83 ec 0c             	sub    $0xc,%esp
   12571:	68 20 52 03 00       	push   $0x35220
   12576:	e8 f8 3d 00 00       	call   16373 <mutex_lock>
   1257b:	83 c4 10             	add    $0x10,%esp
    gdt_table[sel / sizeof(segment_desc_t)].attr = 0;
   1257e:	8b 45 08             	mov    0x8(%ebp),%eax
   12581:	c1 e8 03             	shr    $0x3,%eax
   12584:	66 c7 04 c5 25 4a 03 	movw   $0x0,0x34a25(,%eax,8)
   1258b:	00 00 00 
    mutex_unlock(&mutex);
   1258e:	83 ec 0c             	sub    $0xc,%esp
   12591:	68 20 52 03 00       	push   $0x35220
   12596:	e8 6f 3e 00 00       	call   1640a <mutex_unlock>
   1259b:	83 c4 10             	add    $0x10,%esp
}
   1259e:	90                   	nop
   1259f:	c9                   	leave  
   125a0:	c3                   	ret    

000125a1 <init_gdt>:

/**
 * init_gdt - 初始化GDT
 */
void init_gdt(void)
{
   125a1:	55                   	push   %ebp
   125a2:	89 e5                	mov    %esp,%ebp
   125a4:	83 ec 10             	sub    $0x10,%esp
    for (int i = 0; i < GDT_TABLE_SIZE; i++)
   125a7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   125ae:	eb 19                	jmp    125c9 <init_gdt+0x28>
    {
        segment_desc_set(i * sizeof(segment_desc_t), 0, 0, 0);
   125b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   125b3:	c1 e0 03             	shl    $0x3,%eax
   125b6:	6a 00                	push   $0x0
   125b8:	6a 00                	push   $0x0
   125ba:	6a 00                	push   $0x0
   125bc:	50                   	push   %eax
   125bd:	e8 71 fe ff ff       	call   12433 <segment_desc_set>
   125c2:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < GDT_TABLE_SIZE; i++)
   125c5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   125c9:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
   125d0:	7e de                	jle    125b0 <init_gdt+0xf>
    }
    // 数据段
    segment_desc_set(KERNEL_SELECTOR_DS, 0x00000000, 0xFFFFFFFF,
   125d2:	68 92 40 00 00       	push   $0x4092
   125d7:	6a ff                	push   $0xffffffff
   125d9:	6a 00                	push   $0x0
   125db:	6a 10                	push   $0x10
   125dd:	e8 51 fe ff ff       	call   12433 <segment_desc_set>
   125e2:	83 c4 10             	add    $0x10,%esp
                     SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D);

    // 只能用非一致代码段，以便通过调用门更改当前任务的CPL执行关键的资源访问操作
    segment_desc_set(KERNEL_SELECTOR_CS, 0x00000000, 0xFFFFFFFF,
   125e5:	68 9a 40 00 00       	push   $0x409a
   125ea:	6a ff                	push   $0xffffffff
   125ec:	6a 00                	push   $0x0
   125ee:	6a 08                	push   $0x8
   125f0:	e8 3e fe ff ff       	call   12433 <segment_desc_set>
   125f5:	83 c4 10             	add    $0x10,%esp
                     SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D);

    // 调用门
    gate_desc_set((gate_desc_t *)(gdt_table + (SELECTOR_SYSCALL >> 3)),
   125f8:	ba fb 02 01 00       	mov    $0x102fb,%edx
   125fd:	b8 38 4a 03 00       	mov    $0x34a38,%eax
   12602:	68 05 ec 00 00       	push   $0xec05
   12607:	52                   	push   %edx
   12608:	6a 08                	push   $0x8
   1260a:	50                   	push   %eax
   1260b:	e8 a6 fe ff ff       	call   124b6 <gate_desc_set>
   12610:	83 c4 10             	add    $0x10,%esp
                  KERNEL_SELECTOR_CS,
                  (uint32_t)exception_handler_syscall,
                  GATE_P_PRESENT | GATE_DPL3 | GATE_TYPE_SYSCALL | SYSCALL_PARAM_COUNT);

    // 加载gdt
    lgdt((uint32_t)gdt_table, sizeof(gdt_table));
   12613:	b8 20 4a 03 00       	mov    $0x34a20,%eax
   12618:	68 00 08 00 00       	push   $0x800
   1261d:	50                   	push   %eax
   1261e:	e8 b9 fd ff ff       	call   123dc <lgdt>
   12623:	83 c4 08             	add    $0x8,%esp
}
   12626:	90                   	nop
   12627:	c9                   	leave  
   12628:	c3                   	ret    

00012629 <cpu_init>:

/**
 * cpu_init - 初始化CPU
 */
void cpu_init(void)
{
   12629:	55                   	push   %ebp
   1262a:	89 e5                	mov    %esp,%ebp
   1262c:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   1262f:	83 ec 0c             	sub    $0xc,%esp
   12632:	68 20 52 03 00       	push   $0x35220
   12637:	e8 09 3d 00 00       	call   16345 <mutex_init>
   1263c:	83 c4 10             	add    $0x10,%esp
    init_gdt();
   1263f:	e8 5d ff ff ff       	call   125a1 <init_gdt>
}
   12644:	90                   	nop
   12645:	c9                   	leave  
   12646:	c3                   	ret    

00012647 <switch_to_tss>:

void switch_to_tss(int tss_sel)
{
   12647:	55                   	push   %ebp
   12648:	89 e5                	mov    %esp,%ebp
    far_jump(tss_sel, 0);
   1264a:	8b 45 08             	mov    0x8(%ebp),%eax
   1264d:	6a 00                	push   $0x0
   1264f:	50                   	push   %eax
   12650:	e8 af fd ff ff       	call   12404 <far_jump>
   12655:	83 c4 08             	add    $0x8,%esp
   12658:	90                   	nop
   12659:	c9                   	leave  
   1265a:	c3                   	ret    

0001265b <inb>:
{
   1265b:	55                   	push   %ebp
   1265c:	89 e5                	mov    %esp,%ebp
   1265e:	83 ec 14             	sub    $0x14,%esp
   12661:	8b 45 08             	mov    0x8(%ebp),%eax
   12664:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]" : [v] "=a"(rv) : [p] "d"(port));
   12668:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   1266c:	89 c2                	mov    %eax,%edx
   1266e:	ec                   	in     (%dx),%al
   1266f:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   12672:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   12676:	c9                   	leave  
   12677:	c3                   	ret    

00012678 <outb>:
{
   12678:	55                   	push   %ebp
   12679:	89 e5                	mov    %esp,%ebp
   1267b:	83 ec 08             	sub    $0x8,%esp
   1267e:	8b 55 08             	mov    0x8(%ebp),%edx
   12681:	8b 45 0c             	mov    0xc(%ebp),%eax
   12684:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   12688:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]" : : [p] "d"(port), [v] "a"(data));
   1268b:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   1268f:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   12693:	ee                   	out    %al,(%dx)
}
   12694:	90                   	nop
   12695:	c9                   	leave  
   12696:	c3                   	ret    

00012697 <cli>:
{
   12697:	55                   	push   %ebp
   12698:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("cli");
   1269a:	fa                   	cli    
}
   1269b:	90                   	nop
   1269c:	5d                   	pop    %ebp
   1269d:	c3                   	ret    

0001269e <sti>:
{
   1269e:	55                   	push   %ebp
   1269f:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("sti");
   126a1:	fb                   	sti    
}
   126a2:	90                   	nop
   126a3:	5d                   	pop    %ebp
   126a4:	c3                   	ret    

000126a5 <lidt>:
{
   126a5:	55                   	push   %ebp
   126a6:	89 e5                	mov    %esp,%ebp
   126a8:	83 ec 10             	sub    $0x10,%esp
    idt.start31_16 = start >> 16;
   126ab:	8b 45 08             	mov    0x8(%ebp),%eax
   126ae:	c1 e8 10             	shr    $0x10,%eax
   126b1:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    idt.start15_0 = start & 0xFFFF;
   126b5:	8b 45 08             	mov    0x8(%ebp),%eax
   126b8:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    idt.limit = size - 1;
   126bc:	8b 45 0c             	mov    0xc(%ebp),%eax
   126bf:	83 e8 01             	sub    $0x1,%eax
   126c2:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__("lidt %[g]" ::[g] "m"(idt));
   126c6:	0f 01 5d fa          	lidtl  -0x6(%ebp)
}
   126ca:	90                   	nop
   126cb:	c9                   	leave  
   126cc:	c3                   	ret    

000126cd <hlt>:
{
   126cd:	55                   	push   %ebp
   126ce:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   126d0:	f4                   	hlt    
}
   126d1:	90                   	nop
   126d2:	5d                   	pop    %ebp
   126d3:	c3                   	ret    

000126d4 <read_eflags>:
{
   126d4:	55                   	push   %ebp
   126d5:	89 e5                	mov    %esp,%ebp
   126d7:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__("pushfl\n\tpopl %%eax" : "=a"(eflags));
   126da:	9c                   	pushf  
   126db:	58                   	pop    %eax
   126dc:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return eflags;
   126df:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   126e2:	c9                   	leave  
   126e3:	c3                   	ret    

000126e4 <write_eflags>:
{
   126e4:	55                   	push   %ebp
   126e5:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("pushl %%eax\n\tpopfl" ::"a"(eflags));
   126e7:	8b 45 08             	mov    0x8(%ebp),%eax
   126ea:	50                   	push   %eax
   126eb:	9d                   	popf   
}
   126ec:	90                   	nop
   126ed:	5d                   	pop    %ebp
   126ee:	c3                   	ret    

000126ef <read_cr2>:
 * @brief 读cr2
 *
 * @return uint32_t
 */
static inline uint32_t read_cr2()
{
   126ef:	55                   	push   %ebp
   126f0:	89 e5                	mov    %esp,%ebp
   126f2:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr2;
    __asm__ __volatile__("mov %%cr2, %[v]" : [v] "=r"(cr2));
   126f5:	0f 20 d0             	mov    %cr2,%eax
   126f8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return cr2;
   126fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   126fe:	c9                   	leave  
   126ff:	c3                   	ret    

00012700 <init_pic>:
#define IDT_TABLE_NR 128 // IDT表大小

static gate_desc_t idt_table[IDT_TABLE_NR]; // 中断描述表

static void init_pic(void)
{
   12700:	55                   	push   %ebp
   12701:	89 e5                	mov    %esp,%ebp
    // 边缘触发，级联，需要配置icw4, 8086模式
    outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   12703:	6a 11                	push   $0x11
   12705:	6a 20                	push   $0x20
   12707:	e8 6c ff ff ff       	call   12678 <outb>
   1270c:	83 c4 08             	add    $0x8,%esp

    // 对应的中断号起始序号0x20
    outb(PIC0_ICW2, IRQ_PIC_START);
   1270f:	6a 20                	push   $0x20
   12711:	6a 21                	push   $0x21
   12713:	e8 60 ff ff ff       	call   12678 <outb>
   12718:	83 c4 08             	add    $0x8,%esp

    // 主片IRQ2有从片
    outb(PIC0_ICW3, 1 << 2);
   1271b:	6a 04                	push   $0x4
   1271d:	6a 21                	push   $0x21
   1271f:	e8 54 ff ff ff       	call   12678 <outb>
   12724:	83 c4 08             	add    $0x8,%esp

    // 普通全嵌套、非缓冲、非自动结束、8086模式
    outb(PIC0_ICW4, PIC_ICW4_8086);
   12727:	6a 01                	push   $0x1
   12729:	6a 21                	push   $0x21
   1272b:	e8 48 ff ff ff       	call   12678 <outb>
   12730:	83 c4 08             	add    $0x8,%esp

    // 边缘触发，级联，需要配置icw4, 8086模式
    outb(PIC1_ICW1, PIC_ICW1_ICW4 | PIC_ICW1_ALWAYS_1);
   12733:	6a 11                	push   $0x11
   12735:	68 a0 00 00 00       	push   $0xa0
   1273a:	e8 39 ff ff ff       	call   12678 <outb>
   1273f:	83 c4 08             	add    $0x8,%esp

    // 起始中断序号，要加上8
    outb(PIC1_ICW2, IRQ_PIC_START + 8);
   12742:	6a 28                	push   $0x28
   12744:	68 a1 00 00 00       	push   $0xa1
   12749:	e8 2a ff ff ff       	call   12678 <outb>
   1274e:	83 c4 08             	add    $0x8,%esp

    // 没有从片，连接到主片的IRQ2上
    outb(PIC1_ICW3, 2);
   12751:	6a 02                	push   $0x2
   12753:	68 a1 00 00 00       	push   $0xa1
   12758:	e8 1b ff ff ff       	call   12678 <outb>
   1275d:	83 c4 08             	add    $0x8,%esp

    // 普通全嵌套、非缓冲、非自动结束、8086模式
    outb(PIC1_ICW4, PIC_ICW4_8086);
   12760:	6a 01                	push   $0x1
   12762:	68 a1 00 00 00       	push   $0xa1
   12767:	e8 0c ff ff ff       	call   12678 <outb>
   1276c:	83 c4 08             	add    $0x8,%esp

    // 禁止所有中断, 允许从PIC1传来的中断
    outb(PIC0_IMR, 0xFF & ~(1 << 2));
   1276f:	68 fb 00 00 00       	push   $0xfb
   12774:	6a 21                	push   $0x21
   12776:	e8 fd fe ff ff       	call   12678 <outb>
   1277b:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_IMR, 0xFF);
   1277e:	68 ff 00 00 00       	push   $0xff
   12783:	68 a1 00 00 00       	push   $0xa1
   12788:	e8 eb fe ff ff       	call   12678 <outb>
   1278d:	83 c4 08             	add    $0x8,%esp
}
   12790:	90                   	nop
   12791:	c9                   	leave  
   12792:	c3                   	ret    

00012793 <dump_core_regs>:

static void dump_core_regs(exception_frame_t *frame)
{
   12793:	55                   	push   %ebp
   12794:	89 e5                	mov    %esp,%ebp
   12796:	57                   	push   %edi
   12797:	56                   	push   %esi
   12798:	53                   	push   %ebx
   12799:	83 ec 2c             	sub    $0x2c,%esp
    // 打印CPU寄存器相关内容
    uint32_t esp, ss;
    if (frame->cs & 0x7)
   1279c:	8b 45 08             	mov    0x8(%ebp),%eax
   1279f:	8b 40 3c             	mov    0x3c(%eax),%eax
   127a2:	83 e0 07             	and    $0x7,%eax
   127a5:	85 c0                	test   %eax,%eax
   127a7:	74 14                	je     127bd <dump_core_regs+0x2a>
    {
        ss = frame->ds;
   127a9:	8b 45 08             	mov    0x8(%ebp),%eax
   127ac:	8b 40 0c             	mov    0xc(%eax),%eax
   127af:	89 45 e0             	mov    %eax,-0x20(%ebp)
        esp = frame->esp;
   127b2:	8b 45 08             	mov    0x8(%ebp),%eax
   127b5:	8b 40 1c             	mov    0x1c(%eax),%eax
   127b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   127bb:	eb 12                	jmp    127cf <dump_core_regs+0x3c>
    }
    else
    {
        ss = frame->ss3;
   127bd:	8b 45 08             	mov    0x8(%ebp),%eax
   127c0:	8b 40 48             	mov    0x48(%eax),%eax
   127c3:	89 45 e0             	mov    %eax,-0x20(%ebp)
        esp = frame->esp3;
   127c6:	8b 45 08             	mov    0x8(%ebp),%eax
   127c9:	8b 40 44             	mov    0x44(%eax),%eax
   127cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
    log_printf("IRQ: %d, error code: %d.", frame->num, frame->error_code);
   127cf:	8b 45 08             	mov    0x8(%ebp),%eax
   127d2:	8b 50 34             	mov    0x34(%eax),%edx
   127d5:	8b 45 08             	mov    0x8(%ebp),%eax
   127d8:	8b 40 30             	mov    0x30(%eax),%eax
   127db:	83 ec 04             	sub    $0x4,%esp
   127de:	52                   	push   %edx
   127df:	50                   	push   %eax
   127e0:	68 8c 75 01 00       	push   $0x1758c
   127e5:	e8 15 48 00 00       	call   16fff <log_printf>
   127ea:	83 c4 10             	add    $0x10,%esp
    log_printf("CS: %d\nDS: %d\nES: %d\nSS: %d\nFS:%d\nGS:%d",
   127ed:	8b 45 08             	mov    0x8(%ebp),%eax
   127f0:	8b 30                	mov    (%eax),%esi
   127f2:	8b 45 08             	mov    0x8(%ebp),%eax
   127f5:	8b 58 04             	mov    0x4(%eax),%ebx
   127f8:	8b 45 08             	mov    0x8(%ebp),%eax
   127fb:	8b 48 08             	mov    0x8(%eax),%ecx
   127fe:	8b 45 08             	mov    0x8(%ebp),%eax
   12801:	8b 50 0c             	mov    0xc(%eax),%edx
   12804:	8b 45 08             	mov    0x8(%ebp),%eax
   12807:	8b 40 3c             	mov    0x3c(%eax),%eax
   1280a:	83 ec 04             	sub    $0x4,%esp
   1280d:	56                   	push   %esi
   1280e:	53                   	push   %ebx
   1280f:	ff 75 e0             	pushl  -0x20(%ebp)
   12812:	51                   	push   %ecx
   12813:	52                   	push   %edx
   12814:	50                   	push   %eax
   12815:	68 a8 75 01 00       	push   $0x175a8
   1281a:	e8 e0 47 00 00       	call   16fff <log_printf>
   1281f:	83 c4 20             	add    $0x20,%esp
               frame->cs, frame->ds, frame->es, ss, frame->fs, frame->gs);
    log_printf("EAX:0x%x\n"
   12822:	8b 45 08             	mov    0x8(%ebp),%eax
   12825:	8b 40 18             	mov    0x18(%eax),%eax
   12828:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1282b:	8b 45 08             	mov    0x8(%ebp),%eax
   1282e:	8b 78 14             	mov    0x14(%eax),%edi
   12831:	8b 45 08             	mov    0x8(%ebp),%eax
   12834:	8b 70 10             	mov    0x10(%eax),%esi
   12837:	8b 45 08             	mov    0x8(%ebp),%eax
   1283a:	8b 58 24             	mov    0x24(%eax),%ebx
   1283d:	8b 45 08             	mov    0x8(%ebp),%eax
   12840:	8b 48 28             	mov    0x28(%eax),%ecx
   12843:	8b 45 08             	mov    0x8(%ebp),%eax
   12846:	8b 50 20             	mov    0x20(%eax),%edx
   12849:	8b 45 08             	mov    0x8(%ebp),%eax
   1284c:	8b 40 2c             	mov    0x2c(%eax),%eax
   1284f:	83 ec 0c             	sub    $0xc,%esp
   12852:	ff 75 e4             	pushl  -0x1c(%ebp)
   12855:	ff 75 d4             	pushl  -0x2c(%ebp)
   12858:	57                   	push   %edi
   12859:	56                   	push   %esi
   1285a:	53                   	push   %ebx
   1285b:	51                   	push   %ecx
   1285c:	52                   	push   %edx
   1285d:	50                   	push   %eax
   1285e:	68 d0 75 01 00       	push   $0x175d0
   12863:	e8 97 47 00 00       	call   16fff <log_printf>
   12868:	83 c4 30             	add    $0x30,%esp
               "ESI:0x%x\n"
               "EBP:0x%x\n"
               "ESP:0x%x\n",
               frame->eax, frame->ebx, frame->ecx, frame->edx,
               frame->edi, frame->esi, frame->ebp, esp);
    log_printf("EIP:0x%x\nEFLAGS:0x%x\n", frame->eip, frame->eflags);
   1286b:	8b 45 08             	mov    0x8(%ebp),%eax
   1286e:	8b 50 40             	mov    0x40(%eax),%edx
   12871:	8b 45 08             	mov    0x8(%ebp),%eax
   12874:	8b 40 38             	mov    0x38(%eax),%eax
   12877:	83 ec 04             	sub    $0x4,%esp
   1287a:	52                   	push   %edx
   1287b:	50                   	push   %eax
   1287c:	68 19 76 01 00       	push   $0x17619
   12881:	e8 79 47 00 00       	call   16fff <log_printf>
   12886:	83 c4 10             	add    $0x10,%esp
}
   12889:	90                   	nop
   1288a:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1288d:	5b                   	pop    %ebx
   1288e:	5e                   	pop    %esi
   1288f:	5f                   	pop    %edi
   12890:	5d                   	pop    %ebp
   12891:	c3                   	ret    

00012892 <do_default_handler>:
/**
 * @brief 默认异常处理函数 ---停机
 */
static void
do_default_handler(exception_frame_t *frame, const char *message)
{
   12892:	55                   	push   %ebp
   12893:	89 e5                	mov    %esp,%ebp
   12895:	83 ec 08             	sub    $0x8,%esp
    log_printf("---------------------------");
   12898:	83 ec 0c             	sub    $0xc,%esp
   1289b:	68 2f 76 01 00       	push   $0x1762f
   128a0:	e8 5a 47 00 00       	call   16fff <log_printf>
   128a5:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: %s", message);
   128a8:	83 ec 08             	sub    $0x8,%esp
   128ab:	ff 75 0c             	pushl  0xc(%ebp)
   128ae:	68 4b 76 01 00       	push   $0x1764b
   128b3:	e8 47 47 00 00       	call   16fff <log_printf>
   128b8:	83 c4 10             	add    $0x10,%esp
    dump_core_regs(frame);
   128bb:	83 ec 0c             	sub    $0xc,%esp
   128be:	ff 75 08             	pushl  0x8(%ebp)
   128c1:	e8 cd fe ff ff       	call   12793 <dump_core_regs>
   128c6:	83 c4 10             	add    $0x10,%esp
    for (;;)
    {
        hlt();
   128c9:	e8 ff fd ff ff       	call   126cd <hlt>
   128ce:	eb f9                	jmp    128c9 <do_default_handler+0x37>

000128d0 <do_handler_unknown>:
    }
}

// 异常处理函数
void do_handler_unknown(exception_frame_t *frame)
{
   128d0:	55                   	push   %ebp
   128d1:	89 e5                	mov    %esp,%ebp
   128d3:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Unknown exception.");
   128d6:	83 ec 08             	sub    $0x8,%esp
   128d9:	68 65 76 01 00       	push   $0x17665
   128de:	ff 75 08             	pushl  0x8(%ebp)
   128e1:	e8 ac ff ff ff       	call   12892 <do_default_handler>
   128e6:	83 c4 10             	add    $0x10,%esp
}
   128e9:	90                   	nop
   128ea:	c9                   	leave  
   128eb:	c3                   	ret    

000128ec <do_handler_divider>:

void do_handler_divider(exception_frame_t *frame)
{
   128ec:	55                   	push   %ebp
   128ed:	89 e5                	mov    %esp,%ebp
   128ef:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Device Error.");
   128f2:	83 ec 08             	sub    $0x8,%esp
   128f5:	68 78 76 01 00       	push   $0x17678
   128fa:	ff 75 08             	pushl  0x8(%ebp)
   128fd:	e8 90 ff ff ff       	call   12892 <do_default_handler>
   12902:	83 c4 10             	add    $0x10,%esp
}
   12905:	90                   	nop
   12906:	c9                   	leave  
   12907:	c3                   	ret    

00012908 <do_handler_Debug>:

void do_handler_Debug(exception_frame_t *frame)
{
   12908:	55                   	push   %ebp
   12909:	89 e5                	mov    %esp,%ebp
   1290b:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Debug Exception");
   1290e:	83 ec 08             	sub    $0x8,%esp
   12911:	68 86 76 01 00       	push   $0x17686
   12916:	ff 75 08             	pushl  0x8(%ebp)
   12919:	e8 74 ff ff ff       	call   12892 <do_default_handler>
   1291e:	83 c4 10             	add    $0x10,%esp
}
   12921:	90                   	nop
   12922:	c9                   	leave  
   12923:	c3                   	ret    

00012924 <do_handler_NMI>:

void do_handler_NMI(exception_frame_t *frame)
{
   12924:	55                   	push   %ebp
   12925:	89 e5                	mov    %esp,%ebp
   12927:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "NMI Interrupt.");
   1292a:	83 ec 08             	sub    $0x8,%esp
   1292d:	68 96 76 01 00       	push   $0x17696
   12932:	ff 75 08             	pushl  0x8(%ebp)
   12935:	e8 58 ff ff ff       	call   12892 <do_default_handler>
   1293a:	83 c4 10             	add    $0x10,%esp
}
   1293d:	90                   	nop
   1293e:	c9                   	leave  
   1293f:	c3                   	ret    

00012940 <do_handler_breakpoint>:

void do_handler_breakpoint(exception_frame_t *frame)
{
   12940:	55                   	push   %ebp
   12941:	89 e5                	mov    %esp,%ebp
   12943:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Breakpoint.");
   12946:	83 ec 08             	sub    $0x8,%esp
   12949:	68 a5 76 01 00       	push   $0x176a5
   1294e:	ff 75 08             	pushl  0x8(%ebp)
   12951:	e8 3c ff ff ff       	call   12892 <do_default_handler>
   12956:	83 c4 10             	add    $0x10,%esp
}
   12959:	90                   	nop
   1295a:	c9                   	leave  
   1295b:	c3                   	ret    

0001295c <do_handler_overflow>:

void do_handler_overflow(exception_frame_t *frame)
{
   1295c:	55                   	push   %ebp
   1295d:	89 e5                	mov    %esp,%ebp
   1295f:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Overflow.");
   12962:	83 ec 08             	sub    $0x8,%esp
   12965:	68 b1 76 01 00       	push   $0x176b1
   1296a:	ff 75 08             	pushl  0x8(%ebp)
   1296d:	e8 20 ff ff ff       	call   12892 <do_default_handler>
   12972:	83 c4 10             	add    $0x10,%esp
}
   12975:	90                   	nop
   12976:	c9                   	leave  
   12977:	c3                   	ret    

00012978 <do_handler_bound_range>:

void do_handler_bound_range(exception_frame_t *frame)
{
   12978:	55                   	push   %ebp
   12979:	89 e5                	mov    %esp,%ebp
   1297b:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "BOUND Range Exceeded.");
   1297e:	83 ec 08             	sub    $0x8,%esp
   12981:	68 bb 76 01 00       	push   $0x176bb
   12986:	ff 75 08             	pushl  0x8(%ebp)
   12989:	e8 04 ff ff ff       	call   12892 <do_default_handler>
   1298e:	83 c4 10             	add    $0x10,%esp
}
   12991:	90                   	nop
   12992:	c9                   	leave  
   12993:	c3                   	ret    

00012994 <do_handler_invalid_opcode>:

void do_handler_invalid_opcode(exception_frame_t *frame)
{
   12994:	55                   	push   %ebp
   12995:	89 e5                	mov    %esp,%ebp
   12997:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Invalid Opcode.");
   1299a:	83 ec 08             	sub    $0x8,%esp
   1299d:	68 d1 76 01 00       	push   $0x176d1
   129a2:	ff 75 08             	pushl  0x8(%ebp)
   129a5:	e8 e8 fe ff ff       	call   12892 <do_default_handler>
   129aa:	83 c4 10             	add    $0x10,%esp
}
   129ad:	90                   	nop
   129ae:	c9                   	leave  
   129af:	c3                   	ret    

000129b0 <do_handler_device_unavailable>:

void do_handler_device_unavailable(exception_frame_t *frame)
{
   129b0:	55                   	push   %ebp
   129b1:	89 e5                	mov    %esp,%ebp
   129b3:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Device Not Available.");
   129b6:	83 ec 08             	sub    $0x8,%esp
   129b9:	68 e1 76 01 00       	push   $0x176e1
   129be:	ff 75 08             	pushl  0x8(%ebp)
   129c1:	e8 cc fe ff ff       	call   12892 <do_default_handler>
   129c6:	83 c4 10             	add    $0x10,%esp
}
   129c9:	90                   	nop
   129ca:	c9                   	leave  
   129cb:	c3                   	ret    

000129cc <do_handler_double_fault>:

void do_handler_double_fault(exception_frame_t *frame)
{
   129cc:	55                   	push   %ebp
   129cd:	89 e5                	mov    %esp,%ebp
   129cf:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Double Fault.");
   129d2:	83 ec 08             	sub    $0x8,%esp
   129d5:	68 f7 76 01 00       	push   $0x176f7
   129da:	ff 75 08             	pushl  0x8(%ebp)
   129dd:	e8 b0 fe ff ff       	call   12892 <do_default_handler>
   129e2:	83 c4 10             	add    $0x10,%esp
}
   129e5:	90                   	nop
   129e6:	c9                   	leave  
   129e7:	c3                   	ret    

000129e8 <do_handler_invalid_tss>:

void do_handler_invalid_tss(exception_frame_t *frame)
{
   129e8:	55                   	push   %ebp
   129e9:	89 e5                	mov    %esp,%ebp
   129eb:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Invalid TSS");
   129ee:	83 ec 08             	sub    $0x8,%esp
   129f1:	68 05 77 01 00       	push   $0x17705
   129f6:	ff 75 08             	pushl  0x8(%ebp)
   129f9:	e8 94 fe ff ff       	call   12892 <do_default_handler>
   129fe:	83 c4 10             	add    $0x10,%esp
}
   12a01:	90                   	nop
   12a02:	c9                   	leave  
   12a03:	c3                   	ret    

00012a04 <do_handler_segment_not_present>:

void do_handler_segment_not_present(exception_frame_t *frame)
{
   12a04:	55                   	push   %ebp
   12a05:	89 e5                	mov    %esp,%ebp
   12a07:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Segment Not Present.");
   12a0a:	83 ec 08             	sub    $0x8,%esp
   12a0d:	68 11 77 01 00       	push   $0x17711
   12a12:	ff 75 08             	pushl  0x8(%ebp)
   12a15:	e8 78 fe ff ff       	call   12892 <do_default_handler>
   12a1a:	83 c4 10             	add    $0x10,%esp
}
   12a1d:	90                   	nop
   12a1e:	c9                   	leave  
   12a1f:	c3                   	ret    

00012a20 <do_handler_stack_segment_fault>:

void do_handler_stack_segment_fault(exception_frame_t *frame)
{
   12a20:	55                   	push   %ebp
   12a21:	89 e5                	mov    %esp,%ebp
   12a23:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Stack-Segment Fault.");
   12a26:	83 ec 08             	sub    $0x8,%esp
   12a29:	68 26 77 01 00       	push   $0x17726
   12a2e:	ff 75 08             	pushl  0x8(%ebp)
   12a31:	e8 5c fe ff ff       	call   12892 <do_default_handler>
   12a36:	83 c4 10             	add    $0x10,%esp
}
   12a39:	90                   	nop
   12a3a:	c9                   	leave  
   12a3b:	c3                   	ret    

00012a3c <do_handler_general_protection>:

void do_handler_general_protection(exception_frame_t *frame)
{
   12a3c:	55                   	push   %ebp
   12a3d:	89 e5                	mov    %esp,%ebp
   12a3f:	83 ec 08             	sub    $0x8,%esp
    log_printf("========================= General Protection.=========================\n");
   12a42:	83 ec 0c             	sub    $0xc,%esp
   12a45:	68 3c 77 01 00       	push   $0x1773c
   12a4a:	e8 b0 45 00 00       	call   16fff <log_printf>
   12a4f:	83 c4 10             	add    $0x10,%esp

    log_printf("IRQ/Exception happend: General Protection.");
   12a52:	83 ec 0c             	sub    $0xc,%esp
   12a55:	68 84 77 01 00       	push   $0x17784
   12a5a:	e8 a0 45 00 00       	call   16fff <log_printf>
   12a5f:	83 c4 10             	add    $0x10,%esp
    if (frame->error_code & ERR_EXT)
   12a62:	8b 45 08             	mov    0x8(%ebp),%eax
   12a65:	8b 40 34             	mov    0x34(%eax),%eax
   12a68:	83 e0 01             	and    $0x1,%eax
   12a6b:	85 c0                	test   %eax,%eax
   12a6d:	74 12                	je     12a81 <do_handler_general_protection+0x45>
    {
        log_printf("the exception occurred during delivery of an "
   12a6f:	83 ec 0c             	sub    $0xc,%esp
   12a72:	68 b0 77 01 00       	push   $0x177b0
   12a77:	e8 83 45 00 00       	call   16fff <log_printf>
   12a7c:	83 c4 10             	add    $0x10,%esp
   12a7f:	eb 10                	jmp    12a91 <do_handler_general_protection+0x55>
                   "event external to the program, such as an interrupt"
                   "or an earlier exception.");
    }
    else
    {
        log_printf("the exception occurred during delivery of a"
   12a81:	83 ec 0c             	sub    $0xc,%esp
   12a84:	68 2c 78 01 00       	push   $0x1782c
   12a89:	e8 71 45 00 00       	call   16fff <log_printf>
   12a8e:	83 c4 10             	add    $0x10,%esp
                   "software interrupt (INT n, INT3, or INTO).");
    }

    if (frame->error_code & ERR_IDT)
   12a91:	8b 45 08             	mov    0x8(%ebp),%eax
   12a94:	8b 40 34             	mov    0x34(%eax),%eax
   12a97:	83 e0 02             	and    $0x2,%eax
   12a9a:	85 c0                	test   %eax,%eax
   12a9c:	74 12                	je     12ab0 <do_handler_general_protection+0x74>
    {
        log_printf("the index portion of the error code refers "
   12a9e:	83 ec 0c             	sub    $0xc,%esp
   12aa1:	68 84 78 01 00       	push   $0x17884
   12aa6:	e8 54 45 00 00       	call   16fff <log_printf>
   12aab:	83 c4 10             	add    $0x10,%esp
   12aae:	eb 10                	jmp    12ac0 <do_handler_general_protection+0x84>
                   "to a gate descriptor in the IDT");
    }
    else
    {
        log_printf("the index refers to a descriptor in the GDT");
   12ab0:	83 ec 0c             	sub    $0xc,%esp
   12ab3:	68 d0 78 01 00       	push   $0x178d0
   12ab8:	e8 42 45 00 00       	call   16fff <log_printf>
   12abd:	83 c4 10             	add    $0x10,%esp
    }

    log_printf("segment index: %d", frame->error_code & 0xFFF8);
   12ac0:	8b 45 08             	mov    0x8(%ebp),%eax
   12ac3:	8b 40 34             	mov    0x34(%eax),%eax
   12ac6:	25 f8 ff 00 00       	and    $0xfff8,%eax
   12acb:	83 ec 08             	sub    $0x8,%esp
   12ace:	50                   	push   %eax
   12acf:	68 fc 78 01 00       	push   $0x178fc
   12ad4:	e8 26 45 00 00       	call   16fff <log_printf>
   12ad9:	83 c4 10             	add    $0x10,%esp

    dump_core_regs(frame);
   12adc:	83 ec 0c             	sub    $0xc,%esp
   12adf:	ff 75 08             	pushl  0x8(%ebp)
   12ae2:	e8 ac fc ff ff       	call   12793 <dump_core_regs>
   12ae7:	83 c4 10             	add    $0x10,%esp
    while (1)
    {
        hlt();
   12aea:	e8 de fb ff ff       	call   126cd <hlt>
   12aef:	eb f9                	jmp    12aea <do_handler_general_protection+0xae>

00012af1 <do_handler_page_fault>:
    }
}

void do_handler_page_fault(exception_frame_t *frame)
{
   12af1:	55                   	push   %ebp
   12af2:	89 e5                	mov    %esp,%ebp
   12af4:	83 ec 08             	sub    $0x8,%esp
    log_printf("========================= Page Fault =========================\n");
   12af7:	83 ec 0c             	sub    $0xc,%esp
   12afa:	68 10 79 01 00       	push   $0x17910
   12aff:	e8 fb 44 00 00       	call   16fff <log_printf>
   12b04:	83 c4 10             	add    $0x10,%esp

    if (frame->error_code & ERR_PAGE_P)
   12b07:	8b 45 08             	mov    0x8(%ebp),%eax
   12b0a:	8b 40 34             	mov    0x34(%eax),%eax
   12b0d:	83 e0 01             	and    $0x1,%eax
   12b10:	85 c0                	test   %eax,%eax
   12b12:	74 18                	je     12b2c <do_handler_page_fault+0x3b>
    {
        log_printf("\tpage-level protection violation: 0x%x.", read_cr2());
   12b14:	e8 d6 fb ff ff       	call   126ef <read_cr2>
   12b19:	83 ec 08             	sub    $0x8,%esp
   12b1c:	50                   	push   %eax
   12b1d:	68 50 79 01 00       	push   $0x17950
   12b22:	e8 d8 44 00 00       	call   16fff <log_printf>
   12b27:	83 c4 10             	add    $0x10,%esp
   12b2a:	eb 16                	jmp    12b42 <do_handler_page_fault+0x51>
    }
    else
    {
        log_printf("\tPage doesn't present 0x%x", read_cr2());
   12b2c:	e8 be fb ff ff       	call   126ef <read_cr2>
   12b31:	83 ec 08             	sub    $0x8,%esp
   12b34:	50                   	push   %eax
   12b35:	68 78 79 01 00       	push   $0x17978
   12b3a:	e8 c0 44 00 00       	call   16fff <log_printf>
   12b3f:	83 c4 10             	add    $0x10,%esp
    }

    if (frame->error_code & ERR_PAGE_WR)
   12b42:	8b 45 08             	mov    0x8(%ebp),%eax
   12b45:	8b 40 34             	mov    0x34(%eax),%eax
   12b48:	83 e0 02             	and    $0x2,%eax
   12b4b:	85 c0                	test   %eax,%eax
   12b4d:	74 12                	je     12b61 <do_handler_page_fault+0x70>
    {
        log_printf("\tThe access causing the fault was a write.");
   12b4f:	83 ec 0c             	sub    $0xc,%esp
   12b52:	68 94 79 01 00       	push   $0x17994
   12b57:	e8 a3 44 00 00       	call   16fff <log_printf>
   12b5c:	83 c4 10             	add    $0x10,%esp
   12b5f:	eb 10                	jmp    12b71 <do_handler_page_fault+0x80>
    }
    else
    {
        log_printf("\tThe access causing the fault was a read.");
   12b61:	83 ec 0c             	sub    $0xc,%esp
   12b64:	68 c0 79 01 00       	push   $0x179c0
   12b69:	e8 91 44 00 00       	call   16fff <log_printf>
   12b6e:	83 c4 10             	add    $0x10,%esp
    }

    if (frame->error_code & ERR_PAGE_US)
   12b71:	8b 45 08             	mov    0x8(%ebp),%eax
   12b74:	8b 40 34             	mov    0x34(%eax),%eax
   12b77:	83 e0 04             	and    $0x4,%eax
   12b7a:	85 c0                	test   %eax,%eax
   12b7c:	74 12                	je     12b90 <do_handler_page_fault+0x9f>
    {
        log_printf("\tA supervisor-mode access caused the fault.");
   12b7e:	83 ec 0c             	sub    $0xc,%esp
   12b81:	68 ec 79 01 00       	push   $0x179ec
   12b86:	e8 74 44 00 00       	call   16fff <log_printf>
   12b8b:	83 c4 10             	add    $0x10,%esp
   12b8e:	eb 10                	jmp    12ba0 <do_handler_page_fault+0xaf>
    }
    else
    {
        log_printf("\tA user-mode access caused the fault.");
   12b90:	83 ec 0c             	sub    $0xc,%esp
   12b93:	68 18 7a 01 00       	push   $0x17a18
   12b98:	e8 62 44 00 00       	call   16fff <log_printf>
   12b9d:	83 c4 10             	add    $0x10,%esp
    }
    dump_core_regs(frame);
   12ba0:	83 ec 0c             	sub    $0xc,%esp
   12ba3:	ff 75 08             	pushl  0x8(%ebp)
   12ba6:	e8 e8 fb ff ff       	call   12793 <dump_core_regs>
   12bab:	83 c4 10             	add    $0x10,%esp
    for (;;)
    {
        hlt();
   12bae:	e8 1a fb ff ff       	call   126cd <hlt>
   12bb3:	eb f9                	jmp    12bae <do_handler_page_fault+0xbd>

00012bb5 <do_handler_fpu_error>:
    }
}

void do_handler_fpu_error(exception_frame_t *frame)
{
   12bb5:	55                   	push   %ebp
   12bb6:	89 e5                	mov    %esp,%ebp
   12bb8:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "X87 FPU Floating Point Error.");
   12bbb:	83 ec 08             	sub    $0x8,%esp
   12bbe:	68 3e 7a 01 00       	push   $0x17a3e
   12bc3:	ff 75 08             	pushl  0x8(%ebp)
   12bc6:	e8 c7 fc ff ff       	call   12892 <do_default_handler>
   12bcb:	83 c4 10             	add    $0x10,%esp
}
   12bce:	90                   	nop
   12bcf:	c9                   	leave  
   12bd0:	c3                   	ret    

00012bd1 <do_handler_alignment_check>:

void do_handler_alignment_check(exception_frame_t *frame)
{
   12bd1:	55                   	push   %ebp
   12bd2:	89 e5                	mov    %esp,%ebp
   12bd4:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Alignment Check.");
   12bd7:	83 ec 08             	sub    $0x8,%esp
   12bda:	68 5c 7a 01 00       	push   $0x17a5c
   12bdf:	ff 75 08             	pushl  0x8(%ebp)
   12be2:	e8 ab fc ff ff       	call   12892 <do_default_handler>
   12be7:	83 c4 10             	add    $0x10,%esp
}
   12bea:	90                   	nop
   12beb:	c9                   	leave  
   12bec:	c3                   	ret    

00012bed <do_handler_machine_check>:

void do_handler_machine_check(exception_frame_t *frame)
{
   12bed:	55                   	push   %ebp
   12bee:	89 e5                	mov    %esp,%ebp
   12bf0:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Machine Check.");
   12bf3:	83 ec 08             	sub    $0x8,%esp
   12bf6:	68 6d 7a 01 00       	push   $0x17a6d
   12bfb:	ff 75 08             	pushl  0x8(%ebp)
   12bfe:	e8 8f fc ff ff       	call   12892 <do_default_handler>
   12c03:	83 c4 10             	add    $0x10,%esp
}
   12c06:	90                   	nop
   12c07:	c9                   	leave  
   12c08:	c3                   	ret    

00012c09 <do_handler_smd_exception>:

void do_handler_smd_exception(exception_frame_t *frame)
{
   12c09:	55                   	push   %ebp
   12c0a:	89 e5                	mov    %esp,%ebp
   12c0c:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "SIMD Floating Point Exception.");
   12c0f:	83 ec 08             	sub    $0x8,%esp
   12c12:	68 7c 7a 01 00       	push   $0x17a7c
   12c17:	ff 75 08             	pushl  0x8(%ebp)
   12c1a:	e8 73 fc ff ff       	call   12892 <do_default_handler>
   12c1f:	83 c4 10             	add    $0x10,%esp
}
   12c22:	90                   	nop
   12c23:	c9                   	leave  
   12c24:	c3                   	ret    

00012c25 <do_handler_virtual_exception>:

void do_handler_virtual_exception(exception_frame_t *frame)
{
   12c25:	55                   	push   %ebp
   12c26:	89 e5                	mov    %esp,%ebp
   12c28:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame, "Virtualization Exception.");
   12c2b:	83 ec 08             	sub    $0x8,%esp
   12c2e:	68 9b 7a 01 00       	push   $0x17a9b
   12c33:	ff 75 08             	pushl  0x8(%ebp)
   12c36:	e8 57 fc ff ff       	call   12892 <do_default_handler>
   12c3b:	83 c4 10             	add    $0x10,%esp
}
   12c3e:	90                   	nop
   12c3f:	c9                   	leave  
   12c40:	c3                   	ret    

00012c41 <irq_init>:

/**
 * @brief 中断和异常初始化
 */
void irq_init(void)
{
   12c41:	55                   	push   %ebp
   12c42:	89 e5                	mov    %esp,%ebp
   12c44:	83 ec 18             	sub    $0x18,%esp
    for (uint32_t i = 0; i < IDT_TABLE_NR; i++)
   12c47:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12c4e:	eb 25                	jmp    12c75 <irq_init+0x34>
    {
        gate_desc_set(idt_table + i, KERNEL_SELECTOR_CS, (uint32_t)exception_handler_unknown,
   12c50:	ba 2b 00 01 00       	mov    $0x1002b,%edx
   12c55:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12c58:	c1 e0 03             	shl    $0x3,%eax
   12c5b:	05 40 52 03 00       	add    $0x35240,%eax
   12c60:	68 00 8e 00 00       	push   $0x8e00
   12c65:	52                   	push   %edx
   12c66:	6a 08                	push   $0x8
   12c68:	50                   	push   %eax
   12c69:	e8 48 f8 ff ff       	call   124b6 <gate_desc_set>
   12c6e:	83 c4 10             	add    $0x10,%esp
    for (uint32_t i = 0; i < IDT_TABLE_NR; i++)
   12c71:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12c75:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   12c79:	76 d5                	jbe    12c50 <irq_init+0xf>
                      GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_IDT);
    }

    // 设置异常处理接口
    irq_install(IRQ0_DE, exception_handler_divider);
   12c7b:	83 ec 08             	sub    $0x8,%esp
   12c7e:	68 4a 00 01 00       	push   $0x1004a
   12c83:	6a 00                	push   $0x0
   12c85:	e8 65 01 00 00       	call   12def <irq_install>
   12c8a:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ1_DB, exception_handler_Debug);
   12c8d:	83 ec 08             	sub    $0x8,%esp
   12c90:	68 69 00 01 00       	push   $0x10069
   12c95:	6a 01                	push   $0x1
   12c97:	e8 53 01 00 00       	call   12def <irq_install>
   12c9c:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ2_NMI, exception_handler_NMI);
   12c9f:	83 ec 08             	sub    $0x8,%esp
   12ca2:	68 88 00 01 00       	push   $0x10088
   12ca7:	6a 02                	push   $0x2
   12ca9:	e8 41 01 00 00       	call   12def <irq_install>
   12cae:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ3_BP, exception_handler_breakpoint);
   12cb1:	83 ec 08             	sub    $0x8,%esp
   12cb4:	68 a7 00 01 00       	push   $0x100a7
   12cb9:	6a 03                	push   $0x3
   12cbb:	e8 2f 01 00 00       	call   12def <irq_install>
   12cc0:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ4_OF, exception_handler_overflow);
   12cc3:	83 ec 08             	sub    $0x8,%esp
   12cc6:	68 c6 00 01 00       	push   $0x100c6
   12ccb:	6a 04                	push   $0x4
   12ccd:	e8 1d 01 00 00       	call   12def <irq_install>
   12cd2:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ5_BR, exception_handler_bound_range);
   12cd5:	83 ec 08             	sub    $0x8,%esp
   12cd8:	68 e5 00 01 00       	push   $0x100e5
   12cdd:	6a 05                	push   $0x5
   12cdf:	e8 0b 01 00 00       	call   12def <irq_install>
   12ce4:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ6_UD, exception_handler_invalid_opcode);
   12ce7:	83 ec 08             	sub    $0x8,%esp
   12cea:	68 04 01 01 00       	push   $0x10104
   12cef:	6a 06                	push   $0x6
   12cf1:	e8 f9 00 00 00       	call   12def <irq_install>
   12cf6:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ7_NM, exception_handler_device_unavailable);
   12cf9:	83 ec 08             	sub    $0x8,%esp
   12cfc:	68 23 01 01 00       	push   $0x10123
   12d01:	6a 07                	push   $0x7
   12d03:	e8 e7 00 00 00       	call   12def <irq_install>
   12d08:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ8_DF, exception_handler_double_fault);
   12d0b:	83 ec 08             	sub    $0x8,%esp
   12d0e:	68 42 01 01 00       	push   $0x10142
   12d13:	6a 08                	push   $0x8
   12d15:	e8 d5 00 00 00       	call   12def <irq_install>
   12d1a:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ10_TS, exception_handler_invalid_tss);
   12d1d:	83 ec 08             	sub    $0x8,%esp
   12d20:	68 5f 01 01 00       	push   $0x1015f
   12d25:	6a 0a                	push   $0xa
   12d27:	e8 c3 00 00 00       	call   12def <irq_install>
   12d2c:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ11_NP, exception_handler_segment_not_present);
   12d2f:	83 ec 08             	sub    $0x8,%esp
   12d32:	68 7c 01 01 00       	push   $0x1017c
   12d37:	6a 0b                	push   $0xb
   12d39:	e8 b1 00 00 00       	call   12def <irq_install>
   12d3e:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ12_SS, exception_handler_stack_segment_fault);
   12d41:	83 ec 08             	sub    $0x8,%esp
   12d44:	68 99 01 01 00       	push   $0x10199
   12d49:	6a 0c                	push   $0xc
   12d4b:	e8 9f 00 00 00       	call   12def <irq_install>
   12d50:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ13_GP, exception_handler_general_protection);
   12d53:	83 ec 08             	sub    $0x8,%esp
   12d56:	68 b6 01 01 00       	push   $0x101b6
   12d5b:	6a 0d                	push   $0xd
   12d5d:	e8 8d 00 00 00       	call   12def <irq_install>
   12d62:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ14_PF, exception_handler_page_fault);
   12d65:	83 ec 08             	sub    $0x8,%esp
   12d68:	68 d3 01 01 00       	push   $0x101d3
   12d6d:	6a 0e                	push   $0xe
   12d6f:	e8 7b 00 00 00       	call   12def <irq_install>
   12d74:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ16_MF, exception_handler_fpu_error);
   12d77:	83 ec 08             	sub    $0x8,%esp
   12d7a:	68 f0 01 01 00       	push   $0x101f0
   12d7f:	6a 10                	push   $0x10
   12d81:	e8 69 00 00 00       	call   12def <irq_install>
   12d86:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ17_AC, exception_handler_alignment_check);
   12d89:	83 ec 08             	sub    $0x8,%esp
   12d8c:	68 0f 02 01 00       	push   $0x1020f
   12d91:	6a 11                	push   $0x11
   12d93:	e8 57 00 00 00       	call   12def <irq_install>
   12d98:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ18_MC, exception_handler_machine_check);
   12d9b:	83 ec 08             	sub    $0x8,%esp
   12d9e:	68 2c 02 01 00       	push   $0x1022c
   12da3:	6a 12                	push   $0x12
   12da5:	e8 45 00 00 00       	call   12def <irq_install>
   12daa:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ19_XM, exception_handler_smd_exception);
   12dad:	83 ec 08             	sub    $0x8,%esp
   12db0:	68 4b 02 01 00       	push   $0x1024b
   12db5:	6a 13                	push   $0x13
   12db7:	e8 33 00 00 00       	call   12def <irq_install>
   12dbc:	83 c4 10             	add    $0x10,%esp
    irq_install(IRQ20_VE, exception_handler_virtual_exception);
   12dbf:	83 ec 08             	sub    $0x8,%esp
   12dc2:	68 6a 02 01 00       	push   $0x1026a
   12dc7:	6a 14                	push   $0x14
   12dc9:	e8 21 00 00 00       	call   12def <irq_install>
   12dce:	83 c4 10             	add    $0x10,%esp

    lidt((uint32_t)idt_table, sizeof(idt_table));
   12dd1:	b8 40 52 03 00       	mov    $0x35240,%eax
   12dd6:	83 ec 08             	sub    $0x8,%esp
   12dd9:	68 00 04 00 00       	push   $0x400
   12dde:	50                   	push   %eax
   12ddf:	e8 c1 f8 ff ff       	call   126a5 <lidt>
   12de4:	83 c4 10             	add    $0x10,%esp
    init_pic();
   12de7:	e8 14 f9 ff ff       	call   12700 <init_pic>
}
   12dec:	90                   	nop
   12ded:	c9                   	leave  
   12dee:	c3                   	ret    

00012def <irq_install>:

/**
 * @brief 安装中断或异常处理程序
 */
int irq_install(int irq_num, irq_handler_t handler)
{
   12def:	55                   	push   %ebp
   12df0:	89 e5                	mov    %esp,%ebp
   12df2:	83 ec 08             	sub    $0x8,%esp
    if (irq_num >= IDT_TABLE_NR)
   12df5:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   12df9:	7e 07                	jle    12e02 <irq_install+0x13>
    {
        return -1;
   12dfb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   12e00:	eb 25                	jmp    12e27 <irq_install+0x38>
    }

    gate_desc_set(idt_table + irq_num, KERNEL_SELECTOR_CS, (uint32_t)handler,
   12e02:	8b 45 0c             	mov    0xc(%ebp),%eax
   12e05:	8b 55 08             	mov    0x8(%ebp),%edx
   12e08:	c1 e2 03             	shl    $0x3,%edx
   12e0b:	81 c2 40 52 03 00    	add    $0x35240,%edx
   12e11:	68 00 8e 00 00       	push   $0x8e00
   12e16:	50                   	push   %eax
   12e17:	6a 08                	push   $0x8
   12e19:	52                   	push   %edx
   12e1a:	e8 97 f6 ff ff       	call   124b6 <gate_desc_set>
   12e1f:	83 c4 10             	add    $0x10,%esp
                  GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_IDT);
    return 0;
   12e22:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12e27:	c9                   	leave  
   12e28:	c3                   	ret    

00012e29 <irq_enable>:
/**
 * @brief 打开特定中断
 * @param irq_num 中断号
 */
void irq_enable(int irq_num)
{
   12e29:	55                   	push   %ebp
   12e2a:	89 e5                	mov    %esp,%ebp
   12e2c:	53                   	push   %ebx
   12e2d:	83 ec 10             	sub    $0x10,%esp
    if (irq_num < IRQ_PIC_START)
   12e30:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   12e34:	7e 78                	jle    12eae <irq_enable+0x85>
    {
        return;
    }

    irq_num -= IRQ_PIC_START;
   12e36:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if (irq_num < 8)
   12e3a:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12e3e:	7f 32                	jg     12e72 <irq_enable+0x49>
    {
        uint8_t mask = inb(PIC0_IMR) & ~(1 << irq_num);
   12e40:	6a 21                	push   $0x21
   12e42:	e8 14 f8 ff ff       	call   1265b <inb>
   12e47:	83 c4 04             	add    $0x4,%esp
   12e4a:	89 c2                	mov    %eax,%edx
   12e4c:	8b 45 08             	mov    0x8(%ebp),%eax
   12e4f:	bb 01 00 00 00       	mov    $0x1,%ebx
   12e54:	89 c1                	mov    %eax,%ecx
   12e56:	d3 e3                	shl    %cl,%ebx
   12e58:	89 d8                	mov    %ebx,%eax
   12e5a:	f7 d0                	not    %eax
   12e5c:	21 d0                	and    %edx,%eax
   12e5e:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR, mask);
   12e61:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   12e65:	50                   	push   %eax
   12e66:	6a 21                	push   $0x21
   12e68:	e8 0b f8 ff ff       	call   12678 <outb>
   12e6d:	83 c4 08             	add    $0x8,%esp
   12e70:	eb 3d                	jmp    12eaf <irq_enable+0x86>
    }
    else
    {
        irq_num -= 8;
   12e72:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) & ~(1 << irq_num);
   12e76:	68 a1 00 00 00       	push   $0xa1
   12e7b:	e8 db f7 ff ff       	call   1265b <inb>
   12e80:	83 c4 04             	add    $0x4,%esp
   12e83:	89 c2                	mov    %eax,%edx
   12e85:	8b 45 08             	mov    0x8(%ebp),%eax
   12e88:	bb 01 00 00 00       	mov    $0x1,%ebx
   12e8d:	89 c1                	mov    %eax,%ecx
   12e8f:	d3 e3                	shl    %cl,%ebx
   12e91:	89 d8                	mov    %ebx,%eax
   12e93:	f7 d0                	not    %eax
   12e95:	21 d0                	and    %edx,%eax
   12e97:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR, mask);
   12e9a:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   12e9e:	50                   	push   %eax
   12e9f:	68 a1 00 00 00       	push   $0xa1
   12ea4:	e8 cf f7 ff ff       	call   12678 <outb>
   12ea9:	83 c4 08             	add    $0x8,%esp
   12eac:	eb 01                	jmp    12eaf <irq_enable+0x86>
        return;
   12eae:	90                   	nop
    }
}
   12eaf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12eb2:	c9                   	leave  
   12eb3:	c3                   	ret    

00012eb4 <irq_disable>:
/**
 * @brief 关闭特定中断
 * @param irq_num 中断号
 */
void irq_disable(int irq_num)
{
   12eb4:	55                   	push   %ebp
   12eb5:	89 e5                	mov    %esp,%ebp
   12eb7:	53                   	push   %ebx
   12eb8:	83 ec 10             	sub    $0x10,%esp
    if (irq_num < IRQ_PIC_START)
   12ebb:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   12ebf:	7e 74                	jle    12f35 <irq_disable+0x81>
    {
        return;
    }

    irq_num -= IRQ_PIC_START;
   12ec1:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if (irq_num < 8)
   12ec5:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12ec9:	7f 30                	jg     12efb <irq_disable+0x47>
    {
        uint8_t mask = inb(PIC0_IMR) | (1 << irq_num);
   12ecb:	6a 21                	push   $0x21
   12ecd:	e8 89 f7 ff ff       	call   1265b <inb>
   12ed2:	83 c4 04             	add    $0x4,%esp
   12ed5:	89 c3                	mov    %eax,%ebx
   12ed7:	8b 45 08             	mov    0x8(%ebp),%eax
   12eda:	ba 01 00 00 00       	mov    $0x1,%edx
   12edf:	89 c1                	mov    %eax,%ecx
   12ee1:	d3 e2                	shl    %cl,%edx
   12ee3:	89 d0                	mov    %edx,%eax
   12ee5:	09 d8                	or     %ebx,%eax
   12ee7:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR, mask);
   12eea:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   12eee:	50                   	push   %eax
   12eef:	6a 21                	push   $0x21
   12ef1:	e8 82 f7 ff ff       	call   12678 <outb>
   12ef6:	83 c4 08             	add    $0x8,%esp
   12ef9:	eb 3b                	jmp    12f36 <irq_disable+0x82>
    }
    else
    {
        irq_num -= 8;
   12efb:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) | (1 << irq_num);
   12eff:	68 a1 00 00 00       	push   $0xa1
   12f04:	e8 52 f7 ff ff       	call   1265b <inb>
   12f09:	83 c4 04             	add    $0x4,%esp
   12f0c:	89 c3                	mov    %eax,%ebx
   12f0e:	8b 45 08             	mov    0x8(%ebp),%eax
   12f11:	ba 01 00 00 00       	mov    $0x1,%edx
   12f16:	89 c1                	mov    %eax,%ecx
   12f18:	d3 e2                	shl    %cl,%edx
   12f1a:	89 d0                	mov    %edx,%eax
   12f1c:	09 d8                	or     %ebx,%eax
   12f1e:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR, mask);
   12f21:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   12f25:	50                   	push   %eax
   12f26:	68 a1 00 00 00       	push   $0xa1
   12f2b:	e8 48 f7 ff ff       	call   12678 <outb>
   12f30:	83 c4 08             	add    $0x8,%esp
   12f33:	eb 01                	jmp    12f36 <irq_disable+0x82>
        return;
   12f35:	90                   	nop
    }
}
   12f36:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12f39:	c9                   	leave  
   12f3a:	c3                   	ret    

00012f3b <irq_disable_global>:

/**
 * @brief 关中断
 */
void irq_disable_global(void)
{
   12f3b:	55                   	push   %ebp
   12f3c:	89 e5                	mov    %esp,%ebp
    cli();
   12f3e:	e8 54 f7 ff ff       	call   12697 <cli>
}
   12f43:	90                   	nop
   12f44:	5d                   	pop    %ebp
   12f45:	c3                   	ret    

00012f46 <irq_enable_global>:

/**
 * @brief 开中断
 */
void irq_enable_global(void)
{
   12f46:	55                   	push   %ebp
   12f47:	89 e5                	mov    %esp,%ebp
    sti();
   12f49:	e8 50 f7 ff ff       	call   1269e <sti>
}
   12f4e:	90                   	nop
   12f4f:	5d                   	pop    %ebp
   12f50:	c3                   	ret    

00012f51 <pic_send_eoi>:
/**
 * @brief 发送中断结束信号
 * @param irq_num 中断号
 */
void pic_send_eoi(int irq_num)
{
   12f51:	55                   	push   %ebp
   12f52:	89 e5                	mov    %esp,%ebp
    irq_num -= IRQ_PIC_START;
   12f54:	83 6d 08 20          	subl   $0x20,0x8(%ebp)

    // 从片也可能需要发送EOI
    if (irq_num >= 8)
   12f58:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12f5c:	7e 0f                	jle    12f6d <pic_send_eoi+0x1c>
    {
        outb(PIC1_OCW2, PIC_OCW2_EOI);
   12f5e:	6a 20                	push   $0x20
   12f60:	68 a0 00 00 00       	push   $0xa0
   12f65:	e8 0e f7 ff ff       	call   12678 <outb>
   12f6a:	83 c4 08             	add    $0x8,%esp
    }

    outb(PIC0_OCW2, PIC_OCW2_EOI);
   12f6d:	6a 20                	push   $0x20
   12f6f:	6a 20                	push   $0x20
   12f71:	e8 02 f7 ff ff       	call   12678 <outb>
   12f76:	83 c4 08             	add    $0x8,%esp
}
   12f79:	90                   	nop
   12f7a:	c9                   	leave  
   12f7b:	c3                   	ret    

00012f7c <irq_enter_protection>:

irq_state_t irq_enter_protection(void)
{
   12f7c:	55                   	push   %ebp
   12f7d:	89 e5                	mov    %esp,%ebp
   12f7f:	83 ec 10             	sub    $0x10,%esp
    irq_state_t state = read_eflags();
   12f82:	e8 4d f7 ff ff       	call   126d4 <read_eflags>
   12f87:	89 45 fc             	mov    %eax,-0x4(%ebp)
    irq_disable_global();
   12f8a:	e8 ac ff ff ff       	call   12f3b <irq_disable_global>

    return state;
   12f8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12f92:	c9                   	leave  
   12f93:	c3                   	ret    

00012f94 <irq_leave_protection>:

void irq_leave_protection(irq_state_t state)
{
   12f94:	55                   	push   %ebp
   12f95:	89 e5                	mov    %esp,%ebp
    write_eflags(state);
   12f97:	ff 75 08             	pushl  0x8(%ebp)
   12f9a:	e8 45 f7 ff ff       	call   126e4 <write_eflags>
   12f9f:	83 c4 04             	add    $0x4,%esp
}
   12fa2:	90                   	nop
   12fa3:	c9                   	leave  
   12fa4:	c3                   	ret    

00012fa5 <list_node_prev>:
{
   12fa5:	55                   	push   %ebp
   12fa6:	89 e5                	mov    %esp,%ebp
    return node->prev;
   12fa8:	8b 45 08             	mov    0x8(%ebp),%eax
   12fab:	8b 40 04             	mov    0x4(%eax),%eax
}
   12fae:	5d                   	pop    %ebp
   12faf:	c3                   	ret    

00012fb0 <list_node_next>:
{
   12fb0:	55                   	push   %ebp
   12fb1:	89 e5                	mov    %esp,%ebp
    return node->next;
   12fb3:	8b 45 08             	mov    0x8(%ebp),%eax
   12fb6:	8b 00                	mov    (%eax),%eax
}
   12fb8:	5d                   	pop    %ebp
   12fb9:	c3                   	ret    

00012fba <inb>:
{
   12fba:	55                   	push   %ebp
   12fbb:	89 e5                	mov    %esp,%ebp
   12fbd:	83 ec 14             	sub    $0x14,%esp
   12fc0:	8b 45 08             	mov    0x8(%ebp),%eax
   12fc3:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]" : [v] "=a"(rv) : [p] "d"(port));
   12fc7:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   12fcb:	89 c2                	mov    %eax,%edx
   12fcd:	ec                   	in     (%dx),%al
   12fce:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   12fd1:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   12fd5:	c9                   	leave  
   12fd6:	c3                   	ret    

00012fd7 <outb>:
{
   12fd7:	55                   	push   %ebp
   12fd8:	89 e5                	mov    %esp,%ebp
   12fda:	83 ec 08             	sub    $0x8,%esp
   12fdd:	8b 55 08             	mov    0x8(%ebp),%edx
   12fe0:	8b 45 0c             	mov    0xc(%ebp),%eax
   12fe3:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   12fe7:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]" : : [p] "d"(port), [v] "a"(data));
   12fea:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12fee:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   12ff2:	ee                   	out    %al,(%dx)
}
   12ff3:	90                   	nop
   12ff4:	c9                   	leave  
   12ff5:	c3                   	ret    

00012ff6 <read_cursor_pos>:

static int curr_console_idx = 0;

static int
read_cursor_pos(void)
{
   12ff6:	55                   	push   %ebp
   12ff7:	89 e5                	mov    %esp,%ebp
   12ff9:	83 ec 18             	sub    $0x18,%esp
    int state = irq_enter_protection();
   12ffc:	e8 7b ff ff ff       	call   12f7c <irq_enter_protection>
   13001:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int pos;
    outb(0x3d4, 0xF);
   13004:	83 ec 08             	sub    $0x8,%esp
   13007:	6a 0f                	push   $0xf
   13009:	68 d4 03 00 00       	push   $0x3d4
   1300e:	e8 c4 ff ff ff       	call   12fd7 <outb>
   13013:	83 c4 10             	add    $0x10,%esp
    pos = inb(0x3d5);
   13016:	83 ec 0c             	sub    $0xc,%esp
   13019:	68 d5 03 00 00       	push   $0x3d5
   1301e:	e8 97 ff ff ff       	call   12fba <inb>
   13023:	83 c4 10             	add    $0x10,%esp
   13026:	0f b6 c0             	movzbl %al,%eax
   13029:	89 45 f0             	mov    %eax,-0x10(%ebp)
    outb(0x3d4, 0xE);
   1302c:	83 ec 08             	sub    $0x8,%esp
   1302f:	6a 0e                	push   $0xe
   13031:	68 d4 03 00 00       	push   $0x3d4
   13036:	e8 9c ff ff ff       	call   12fd7 <outb>
   1303b:	83 c4 10             	add    $0x10,%esp
    pos |= inb(0x3d5) << 8;
   1303e:	83 ec 0c             	sub    $0xc,%esp
   13041:	68 d5 03 00 00       	push   $0x3d5
   13046:	e8 6f ff ff ff       	call   12fba <inb>
   1304b:	83 c4 10             	add    $0x10,%esp
   1304e:	0f b6 c0             	movzbl %al,%eax
   13051:	c1 e0 08             	shl    $0x8,%eax
   13054:	09 45 f0             	or     %eax,-0x10(%ebp)
    irq_leave_protection(state);
   13057:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1305a:	83 ec 0c             	sub    $0xc,%esp
   1305d:	50                   	push   %eax
   1305e:	e8 31 ff ff ff       	call   12f94 <irq_leave_protection>
   13063:	83 c4 10             	add    $0x10,%esp
    return pos;
   13066:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   13069:	c9                   	leave  
   1306a:	c3                   	ret    

0001306b <update_cursor_pos>:

static int update_cursor_pos(console_t *console)
{
   1306b:	55                   	push   %ebp
   1306c:	89 e5                	mov    %esp,%ebp
   1306e:	83 ec 18             	sub    $0x18,%esp
    uint16_t pos = (console - console_buff) * console->display_rows * console->display_cols;
   13071:	8b 45 08             	mov    0x8(%ebp),%eax
   13074:	ba 40 56 03 00       	mov    $0x35640,%edx
   13079:	29 d0                	sub    %edx,%eax
   1307b:	c1 f8 03             	sar    $0x3,%eax
   1307e:	69 c0 c5 4e ec c4    	imul   $0xc4ec4ec5,%eax,%eax
   13084:	89 c2                	mov    %eax,%edx
   13086:	8b 45 08             	mov    0x8(%ebp),%eax
   13089:	8b 40 10             	mov    0x10(%eax),%eax
   1308c:	0f af d0             	imul   %eax,%edx
   1308f:	8b 45 08             	mov    0x8(%ebp),%eax
   13092:	8b 40 14             	mov    0x14(%eax),%eax
   13095:	0f af c2             	imul   %edx,%eax
   13098:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
    pos += console->cursor_row * console->display_cols + console->cursor_col;
   1309c:	8b 45 08             	mov    0x8(%ebp),%eax
   1309f:	8b 40 08             	mov    0x8(%eax),%eax
   130a2:	89 c2                	mov    %eax,%edx
   130a4:	8b 45 08             	mov    0x8(%ebp),%eax
   130a7:	8b 40 14             	mov    0x14(%eax),%eax
   130aa:	0f af d0             	imul   %eax,%edx
   130ad:	8b 45 08             	mov    0x8(%ebp),%eax
   130b0:	8b 40 0c             	mov    0xc(%eax),%eax
   130b3:	01 d0                	add    %edx,%eax
   130b5:	66 01 45 f6          	add    %ax,-0xa(%ebp)
    int state = irq_enter_protection();
   130b9:	e8 be fe ff ff       	call   12f7c <irq_enter_protection>
   130be:	89 45 f0             	mov    %eax,-0x10(%ebp)
    outb(0x3d4, 0xF);
   130c1:	83 ec 08             	sub    $0x8,%esp
   130c4:	6a 0f                	push   $0xf
   130c6:	68 d4 03 00 00       	push   $0x3d4
   130cb:	e8 07 ff ff ff       	call   12fd7 <outb>
   130d0:	83 c4 10             	add    $0x10,%esp
    outb(0x3d5, (uint8_t)(pos & 0xFF));
   130d3:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   130d7:	0f b6 c0             	movzbl %al,%eax
   130da:	83 ec 08             	sub    $0x8,%esp
   130dd:	50                   	push   %eax
   130de:	68 d5 03 00 00       	push   $0x3d5
   130e3:	e8 ef fe ff ff       	call   12fd7 <outb>
   130e8:	83 c4 10             	add    $0x10,%esp
    outb(0x3d4, 0xE);
   130eb:	83 ec 08             	sub    $0x8,%esp
   130ee:	6a 0e                	push   $0xe
   130f0:	68 d4 03 00 00       	push   $0x3d4
   130f5:	e8 dd fe ff ff       	call   12fd7 <outb>
   130fa:	83 c4 10             	add    $0x10,%esp
    outb(0x3d5, (uint8_t)((pos >> 8) & 0xFF));
   130fd:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   13101:	66 c1 e8 08          	shr    $0x8,%ax
   13105:	0f b6 c0             	movzbl %al,%eax
   13108:	83 ec 08             	sub    $0x8,%esp
   1310b:	50                   	push   %eax
   1310c:	68 d5 03 00 00       	push   $0x3d5
   13111:	e8 c1 fe ff ff       	call   12fd7 <outb>
   13116:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   13119:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1311c:	83 ec 0c             	sub    $0xc,%esp
   1311f:	50                   	push   %eax
   13120:	e8 6f fe ff ff       	call   12f94 <irq_leave_protection>
   13125:	83 c4 10             	add    $0x10,%esp
    return pos;
   13128:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
}
   1312c:	c9                   	leave  
   1312d:	c3                   	ret    

0001312e <erase_rows>:

static void erase_rows(console_t *console, int start, int end)
{
   1312e:	55                   	push   %ebp
   1312f:	89 e5                	mov    %esp,%ebp
   13131:	83 ec 10             	sub    $0x10,%esp
    display_char_t *disp_start = console->disp_base + start * console->display_cols;
   13134:	8b 45 08             	mov    0x8(%ebp),%eax
   13137:	8b 50 04             	mov    0x4(%eax),%edx
   1313a:	8b 45 08             	mov    0x8(%ebp),%eax
   1313d:	8b 40 14             	mov    0x14(%eax),%eax
   13140:	0f af 45 0c          	imul   0xc(%ebp),%eax
   13144:	01 c0                	add    %eax,%eax
   13146:	01 d0                	add    %edx,%eax
   13148:	89 45 fc             	mov    %eax,-0x4(%ebp)
    display_char_t *disp_end = console->disp_base + (end + 1) * console->display_cols;
   1314b:	8b 45 08             	mov    0x8(%ebp),%eax
   1314e:	8b 50 04             	mov    0x4(%eax),%edx
   13151:	8b 45 10             	mov    0x10(%ebp),%eax
   13154:	8d 48 01             	lea    0x1(%eax),%ecx
   13157:	8b 45 08             	mov    0x8(%ebp),%eax
   1315a:	8b 40 14             	mov    0x14(%eax),%eax
   1315d:	0f af c1             	imul   %ecx,%eax
   13160:	01 c0                	add    %eax,%eax
   13162:	01 d0                	add    %edx,%eax
   13164:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while (disp_start < disp_end)
   13167:	eb 4d                	jmp    131b6 <erase_rows+0x88>
    {
        disp_start->c = ' ';
   13169:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1316c:	c6 00 20             	movb   $0x20,(%eax)
        disp_start->foregroud = console->foregroud;
   1316f:	8b 45 08             	mov    0x8(%ebp),%eax
   13172:	8b 40 18             	mov    0x18(%eax),%eax
   13175:	c1 e0 04             	shl    $0x4,%eax
   13178:	c0 f8 04             	sar    $0x4,%al
   1317b:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1317e:	83 e0 0f             	and    $0xf,%eax
   13181:	89 c1                	mov    %eax,%ecx
   13183:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   13187:	83 e0 f0             	and    $0xfffffff0,%eax
   1318a:	09 c8                	or     %ecx,%eax
   1318c:	88 42 01             	mov    %al,0x1(%edx)
        disp_start->background = console->background;
   1318f:	8b 45 08             	mov    0x8(%ebp),%eax
   13192:	8b 40 1c             	mov    0x1c(%eax),%eax
   13195:	c1 e0 05             	shl    $0x5,%eax
   13198:	c0 f8 05             	sar    $0x5,%al
   1319b:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1319e:	83 e0 07             	and    $0x7,%eax
   131a1:	c1 e0 04             	shl    $0x4,%eax
   131a4:	89 c1                	mov    %eax,%ecx
   131a6:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   131aa:	83 e0 8f             	and    $0xffffff8f,%eax
   131ad:	09 c8                	or     %ecx,%eax
   131af:	88 42 01             	mov    %al,0x1(%edx)
        disp_start++;
   131b2:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
    while (disp_start < disp_end)
   131b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   131b9:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   131bc:	72 ab                	jb     13169 <erase_rows+0x3b>
    }
}
   131be:	90                   	nop
   131bf:	c9                   	leave  
   131c0:	c3                   	ret    

000131c1 <scroll_up>:

static void scroll_up(console_t *console, int lines)
{
   131c1:	55                   	push   %ebp
   131c2:	89 e5                	mov    %esp,%ebp
   131c4:	83 ec 18             	sub    $0x18,%esp
    display_char_t *dest = console->disp_base;
   131c7:	8b 45 08             	mov    0x8(%ebp),%eax
   131ca:	8b 40 04             	mov    0x4(%eax),%eax
   131cd:	89 45 f4             	mov    %eax,-0xc(%ebp)

    display_char_t *src = console->disp_base + console->display_cols * lines;
   131d0:	8b 45 08             	mov    0x8(%ebp),%eax
   131d3:	8b 50 04             	mov    0x4(%eax),%edx
   131d6:	8b 45 08             	mov    0x8(%ebp),%eax
   131d9:	8b 40 14             	mov    0x14(%eax),%eax
   131dc:	0f af 45 0c          	imul   0xc(%ebp),%eax
   131e0:	01 c0                	add    %eax,%eax
   131e2:	01 d0                	add    %edx,%eax
   131e4:	89 45 f0             	mov    %eax,-0x10(%ebp)

    uint32_t size = (console->display_rows - lines) * console->display_cols * sizeof(display_char_t);
   131e7:	8b 45 08             	mov    0x8(%ebp),%eax
   131ea:	8b 40 10             	mov    0x10(%eax),%eax
   131ed:	2b 45 0c             	sub    0xc(%ebp),%eax
   131f0:	89 c2                	mov    %eax,%edx
   131f2:	8b 45 08             	mov    0x8(%ebp),%eax
   131f5:	8b 40 14             	mov    0x14(%eax),%eax
   131f8:	0f af c2             	imul   %edx,%eax
   131fb:	01 c0                	add    %eax,%eax
   131fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
    kernel_memcpy(dest, src, size);
   13200:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13203:	83 ec 04             	sub    $0x4,%esp
   13206:	50                   	push   %eax
   13207:	ff 75 f0             	pushl  -0x10(%ebp)
   1320a:	ff 75 f4             	pushl  -0xc(%ebp)
   1320d:	e8 c2 37 00 00       	call   169d4 <kernel_memcpy>
   13212:	83 c4 10             	add    $0x10,%esp

    erase_rows(console, console->display_rows - lines, console->display_rows - 1);
   13215:	8b 45 08             	mov    0x8(%ebp),%eax
   13218:	8b 40 10             	mov    0x10(%eax),%eax
   1321b:	8d 50 ff             	lea    -0x1(%eax),%edx
   1321e:	8b 45 08             	mov    0x8(%ebp),%eax
   13221:	8b 40 10             	mov    0x10(%eax),%eax
   13224:	2b 45 0c             	sub    0xc(%ebp),%eax
   13227:	83 ec 04             	sub    $0x4,%esp
   1322a:	52                   	push   %edx
   1322b:	50                   	push   %eax
   1322c:	ff 75 08             	pushl  0x8(%ebp)
   1322f:	e8 fa fe ff ff       	call   1312e <erase_rows>
   13234:	83 c4 10             	add    $0x10,%esp

    console->cursor_row -= lines;
   13237:	8b 45 08             	mov    0x8(%ebp),%eax
   1323a:	8b 40 08             	mov    0x8(%eax),%eax
   1323d:	2b 45 0c             	sub    0xc(%ebp),%eax
   13240:	89 c2                	mov    %eax,%edx
   13242:	8b 45 08             	mov    0x8(%ebp),%eax
   13245:	89 50 08             	mov    %edx,0x8(%eax)
}
   13248:	90                   	nop
   13249:	c9                   	leave  
   1324a:	c3                   	ret    

0001324b <clear_display>:

static void clear_display(console_t *console)
{
   1324b:	55                   	push   %ebp
   1324c:	89 e5                	mov    %esp,%ebp
   1324e:	83 ec 10             	sub    $0x10,%esp
    int size = console->display_cols * console->display_rows;
   13251:	8b 45 08             	mov    0x8(%ebp),%eax
   13254:	8b 50 14             	mov    0x14(%eax),%edx
   13257:	8b 45 08             	mov    0x8(%ebp),%eax
   1325a:	8b 40 10             	mov    0x10(%eax),%eax
   1325d:	0f af c2             	imul   %edx,%eax
   13260:	89 45 f4             	mov    %eax,-0xc(%ebp)
    display_char_t *p = console->disp_base;
   13263:	8b 45 08             	mov    0x8(%ebp),%eax
   13266:	8b 40 04             	mov    0x4(%eax),%eax
   13269:	89 45 fc             	mov    %eax,-0x4(%ebp)
    for (int i = 0; i < size; i++)
   1326c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   13273:	eb 51                	jmp    132c6 <clear_display+0x7b>
    {
        p->c = ' ';
   13275:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13278:	c6 00 20             	movb   $0x20,(%eax)
        p->foregroud = console->foregroud;
   1327b:	8b 45 08             	mov    0x8(%ebp),%eax
   1327e:	8b 40 18             	mov    0x18(%eax),%eax
   13281:	c1 e0 04             	shl    $0x4,%eax
   13284:	c0 f8 04             	sar    $0x4,%al
   13287:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1328a:	83 e0 0f             	and    $0xf,%eax
   1328d:	89 c1                	mov    %eax,%ecx
   1328f:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   13293:	83 e0 f0             	and    $0xfffffff0,%eax
   13296:	09 c8                	or     %ecx,%eax
   13298:	88 42 01             	mov    %al,0x1(%edx)
        p->background = console->background;
   1329b:	8b 45 08             	mov    0x8(%ebp),%eax
   1329e:	8b 40 1c             	mov    0x1c(%eax),%eax
   132a1:	c1 e0 05             	shl    $0x5,%eax
   132a4:	c0 f8 05             	sar    $0x5,%al
   132a7:	8b 55 fc             	mov    -0x4(%ebp),%edx
   132aa:	83 e0 07             	and    $0x7,%eax
   132ad:	c1 e0 04             	shl    $0x4,%eax
   132b0:	89 c1                	mov    %eax,%ecx
   132b2:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   132b6:	83 e0 8f             	and    $0xffffff8f,%eax
   132b9:	09 c8                	or     %ecx,%eax
   132bb:	88 42 01             	mov    %al,0x1(%edx)
        p++;
   132be:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
    for (int i = 0; i < size; i++)
   132c2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   132c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   132c9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   132cc:	7c a7                	jl     13275 <clear_display+0x2a>
    }
}
   132ce:	90                   	nop
   132cf:	c9                   	leave  
   132d0:	c3                   	ret    

000132d1 <move_forward>:

static void move_forward(console_t *console, int n)
{
   132d1:	55                   	push   %ebp
   132d2:	89 e5                	mov    %esp,%ebp
   132d4:	83 ec 18             	sub    $0x18,%esp
    for (int i = 0; i < n; i++)
   132d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   132de:	eb 5c                	jmp    1333c <move_forward+0x6b>
    {
        if (++console->cursor_col >= console->display_cols)
   132e0:	8b 45 08             	mov    0x8(%ebp),%eax
   132e3:	8b 40 0c             	mov    0xc(%eax),%eax
   132e6:	8d 50 01             	lea    0x1(%eax),%edx
   132e9:	8b 45 08             	mov    0x8(%ebp),%eax
   132ec:	89 50 0c             	mov    %edx,0xc(%eax)
   132ef:	8b 45 08             	mov    0x8(%ebp),%eax
   132f2:	8b 50 0c             	mov    0xc(%eax),%edx
   132f5:	8b 45 08             	mov    0x8(%ebp),%eax
   132f8:	8b 40 14             	mov    0x14(%eax),%eax
   132fb:	39 c2                	cmp    %eax,%edx
   132fd:	7c 39                	jl     13338 <move_forward+0x67>
        {
            console->cursor_col = 0;
   132ff:	8b 45 08             	mov    0x8(%ebp),%eax
   13302:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            if (++console->cursor_row >= console->display_rows)
   13309:	8b 45 08             	mov    0x8(%ebp),%eax
   1330c:	8b 40 08             	mov    0x8(%eax),%eax
   1330f:	8d 50 01             	lea    0x1(%eax),%edx
   13312:	8b 45 08             	mov    0x8(%ebp),%eax
   13315:	89 50 08             	mov    %edx,0x8(%eax)
   13318:	8b 45 08             	mov    0x8(%ebp),%eax
   1331b:	8b 50 08             	mov    0x8(%eax),%edx
   1331e:	8b 45 08             	mov    0x8(%ebp),%eax
   13321:	8b 40 10             	mov    0x10(%eax),%eax
   13324:	39 c2                	cmp    %eax,%edx
   13326:	7c 10                	jl     13338 <move_forward+0x67>
            {
                scroll_up(console, 1);
   13328:	83 ec 08             	sub    $0x8,%esp
   1332b:	6a 01                	push   $0x1
   1332d:	ff 75 08             	pushl  0x8(%ebp)
   13330:	e8 8c fe ff ff       	call   131c1 <scroll_up>
   13335:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < n; i++)
   13338:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1333c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1333f:	3b 45 0c             	cmp    0xc(%ebp),%eax
   13342:	7c 9c                	jl     132e0 <move_forward+0xf>
            }
        }
    }
}
   13344:	90                   	nop
   13345:	c9                   	leave  
   13346:	c3                   	ret    

00013347 <show_char>:

static void show_char(console_t *console, char c)
{
   13347:	55                   	push   %ebp
   13348:	89 e5                	mov    %esp,%ebp
   1334a:	83 ec 28             	sub    $0x28,%esp
   1334d:	8b 45 0c             	mov    0xc(%ebp),%eax
   13350:	88 45 e4             	mov    %al,-0x1c(%ebp)
    int offset = console->cursor_row * console->display_cols + console->cursor_col;
   13353:	8b 45 08             	mov    0x8(%ebp),%eax
   13356:	8b 50 08             	mov    0x8(%eax),%edx
   13359:	8b 45 08             	mov    0x8(%ebp),%eax
   1335c:	8b 40 14             	mov    0x14(%eax),%eax
   1335f:	0f af d0             	imul   %eax,%edx
   13362:	8b 45 08             	mov    0x8(%ebp),%eax
   13365:	8b 40 0c             	mov    0xc(%eax),%eax
   13368:	01 d0                	add    %edx,%eax
   1336a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    display_char_t *p = console->disp_base + offset;
   1336d:	8b 45 08             	mov    0x8(%ebp),%eax
   13370:	8b 40 04             	mov    0x4(%eax),%eax
   13373:	8b 55 f4             	mov    -0xc(%ebp),%edx
   13376:	01 d2                	add    %edx,%edx
   13378:	01 d0                	add    %edx,%eax
   1337a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    p->c = c;
   1337d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13380:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
   13384:	88 10                	mov    %dl,(%eax)
    p->foregroud = console->foregroud;
   13386:	8b 45 08             	mov    0x8(%ebp),%eax
   13389:	8b 40 18             	mov    0x18(%eax),%eax
   1338c:	c1 e0 04             	shl    $0x4,%eax
   1338f:	c0 f8 04             	sar    $0x4,%al
   13392:	8b 55 f0             	mov    -0x10(%ebp),%edx
   13395:	83 e0 0f             	and    $0xf,%eax
   13398:	89 c1                	mov    %eax,%ecx
   1339a:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   1339e:	83 e0 f0             	and    $0xfffffff0,%eax
   133a1:	09 c8                	or     %ecx,%eax
   133a3:	88 42 01             	mov    %al,0x1(%edx)
    p->background = console->background;
   133a6:	8b 45 08             	mov    0x8(%ebp),%eax
   133a9:	8b 40 1c             	mov    0x1c(%eax),%eax
   133ac:	c1 e0 05             	shl    $0x5,%eax
   133af:	c0 f8 05             	sar    $0x5,%al
   133b2:	8b 55 f0             	mov    -0x10(%ebp),%edx
   133b5:	83 e0 07             	and    $0x7,%eax
   133b8:	c1 e0 04             	shl    $0x4,%eax
   133bb:	89 c1                	mov    %eax,%ecx
   133bd:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   133c1:	83 e0 8f             	and    $0xffffff8f,%eax
   133c4:	09 c8                	or     %ecx,%eax
   133c6:	88 42 01             	mov    %al,0x1(%edx)
    move_forward(console, 1);
   133c9:	83 ec 08             	sub    $0x8,%esp
   133cc:	6a 01                	push   $0x1
   133ce:	ff 75 08             	pushl  0x8(%ebp)
   133d1:	e8 fb fe ff ff       	call   132d1 <move_forward>
   133d6:	83 c4 10             	add    $0x10,%esp
}
   133d9:	90                   	nop
   133da:	c9                   	leave  
   133db:	c3                   	ret    

000133dc <console_init>:

int console_init(int idx)
{
   133dc:	55                   	push   %ebp
   133dd:	89 e5                	mov    %esp,%ebp
   133df:	83 ec 18             	sub    $0x18,%esp

    console_t *console = &console_buff[idx];
   133e2:	8b 45 08             	mov    0x8(%ebp),%eax
   133e5:	6b c0 68             	imul   $0x68,%eax,%eax
   133e8:	05 40 56 03 00       	add    $0x35640,%eax
   133ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
    console->display_cols = CONSOLE_COL_MAX;
   133f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   133f3:	c7 40 14 50 00 00 00 	movl   $0x50,0x14(%eax)
    console->display_rows = CONSOLE_ROW_MAX;
   133fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   133fd:	c7 40 10 19 00 00 00 	movl   $0x19,0x10(%eax)
    console->disp_base = (display_char_t *)CONSOLE_DISP_ADDR + idx * CONSOLE_ROW_MAX * CONSOLE_COL_MAX;
   13404:	8b 45 08             	mov    0x8(%ebp),%eax
   13407:	69 c0 a0 0f 00 00    	imul   $0xfa0,%eax,%eax
   1340d:	8d 90 00 80 0b 00    	lea    0xb8000(%eax),%edx
   13413:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13416:	89 50 04             	mov    %edx,0x4(%eax)
    console->foregroud = COLOR_White;
   13419:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1341c:	c7 40 18 0f 00 00 00 	movl   $0xf,0x18(%eax)
    console->background = COLOR_Black;
   13423:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13426:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

    if (idx == 0)
   1342d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13431:	75 30                	jne    13463 <console_init+0x87>
    {
        int cursor_pos = read_cursor_pos();
   13433:	e8 be fb ff ff       	call   12ff6 <read_cursor_pos>
   13438:	89 45 f0             	mov    %eax,-0x10(%ebp)
        console->cursor_row = cursor_pos / console->display_cols;
   1343b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1343e:	8b 48 14             	mov    0x14(%eax),%ecx
   13441:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13444:	99                   	cltd   
   13445:	f7 f9                	idiv   %ecx
   13447:	89 c2                	mov    %eax,%edx
   13449:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1344c:	89 50 08             	mov    %edx,0x8(%eax)
        console->cursor_col = cursor_pos % console->display_cols;
   1344f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13452:	8b 48 14             	mov    0x14(%eax),%ecx
   13455:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13458:	99                   	cltd   
   13459:	f7 f9                	idiv   %ecx
   1345b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1345e:	89 50 0c             	mov    %edx,0xc(%eax)
   13461:	eb 30                	jmp    13493 <console_init+0xb7>
    }
    else
    {
        console->cursor_row = 0;
   13463:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13466:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        console->cursor_col = 0;
   1346d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13470:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
        clear_display(console);
   13477:	83 ec 0c             	sub    $0xc,%esp
   1347a:	ff 75 f4             	pushl  -0xc(%ebp)
   1347d:	e8 c9 fd ff ff       	call   1324b <clear_display>
   13482:	83 c4 10             	add    $0x10,%esp
        update_cursor_pos(console);
   13485:	83 ec 0c             	sub    $0xc,%esp
   13488:	ff 75 f4             	pushl  -0xc(%ebp)
   1348b:	e8 db fb ff ff       	call   1306b <update_cursor_pos>
   13490:	83 c4 10             	add    $0x10,%esp
    }
    console->old_cursor_col = console->cursor_col;
   13493:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13496:	8b 50 0c             	mov    0xc(%eax),%edx
   13499:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1349c:	89 50 50             	mov    %edx,0x50(%eax)
    console->old_cursor_row = console->cursor_row;
   1349f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   134a2:	8b 50 08             	mov    0x8(%eax),%edx
   134a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   134a8:	89 50 4c             	mov    %edx,0x4c(%eax)
    console->write_state = CONSOLE_WRITE_NORMAL;
   134ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
   134ae:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    mutex_init(&console->mutex);
   134b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   134b7:	83 c0 54             	add    $0x54,%eax
   134ba:	83 ec 0c             	sub    $0xc,%esp
   134bd:	50                   	push   %eax
   134be:	e8 82 2e 00 00       	call   16345 <mutex_init>
   134c3:	83 c4 10             	add    $0x10,%esp
    // clear_display(console);

    return 0;
   134c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   134cb:	c9                   	leave  
   134cc:	c3                   	ret    

000134cd <move_to_col0>:

static void move_to_col0(console_t *console)
{
   134cd:	55                   	push   %ebp
   134ce:	89 e5                	mov    %esp,%ebp
    console->cursor_col = 0;
   134d0:	8b 45 08             	mov    0x8(%ebp),%eax
   134d3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
   134da:	90                   	nop
   134db:	5d                   	pop    %ebp
   134dc:	c3                   	ret    

000134dd <move_next_line>:
static void move_next_line(console_t *console)
{
   134dd:	55                   	push   %ebp
   134de:	89 e5                	mov    %esp,%ebp
   134e0:	83 ec 08             	sub    $0x8,%esp
    console->cursor_row++;
   134e3:	8b 45 08             	mov    0x8(%ebp),%eax
   134e6:	8b 40 08             	mov    0x8(%eax),%eax
   134e9:	8d 50 01             	lea    0x1(%eax),%edx
   134ec:	8b 45 08             	mov    0x8(%ebp),%eax
   134ef:	89 50 08             	mov    %edx,0x8(%eax)

    // 超出当前屏幕显示的所有行，上移一行
    if (console->cursor_row >= console->display_rows)
   134f2:	8b 45 08             	mov    0x8(%ebp),%eax
   134f5:	8b 50 08             	mov    0x8(%eax),%edx
   134f8:	8b 45 08             	mov    0x8(%ebp),%eax
   134fb:	8b 40 10             	mov    0x10(%eax),%eax
   134fe:	39 c2                	cmp    %eax,%edx
   13500:	7c 10                	jl     13512 <move_next_line+0x35>
    {
        scroll_up(console, 1);
   13502:	83 ec 08             	sub    $0x8,%esp
   13505:	6a 01                	push   $0x1
   13507:	ff 75 08             	pushl  0x8(%ebp)
   1350a:	e8 b2 fc ff ff       	call   131c1 <scroll_up>
   1350f:	83 c4 10             	add    $0x10,%esp
    }
}
   13512:	90                   	nop
   13513:	c9                   	leave  
   13514:	c3                   	ret    

00013515 <move_backword>:

static int move_backword(console_t *console, int n)
{
   13515:	55                   	push   %ebp
   13516:	89 e5                	mov    %esp,%ebp
   13518:	83 ec 10             	sub    $0x10,%esp
    int status = -1;
   1351b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
    for (int i = 0; i < n; i++)
   13522:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   13529:	eb 55                	jmp    13580 <move_backword+0x6b>
    {
        if (console->cursor_col > 0)
   1352b:	8b 45 08             	mov    0x8(%ebp),%eax
   1352e:	8b 40 0c             	mov    0xc(%eax),%eax
   13531:	85 c0                	test   %eax,%eax
   13533:	7e 18                	jle    1354d <move_backword+0x38>
        {
            console->cursor_col--;
   13535:	8b 45 08             	mov    0x8(%ebp),%eax
   13538:	8b 40 0c             	mov    0xc(%eax),%eax
   1353b:	8d 50 ff             	lea    -0x1(%eax),%edx
   1353e:	8b 45 08             	mov    0x8(%ebp),%eax
   13541:	89 50 0c             	mov    %edx,0xc(%eax)
            status = 0;
   13544:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1354b:	eb 2f                	jmp    1357c <move_backword+0x67>
        }
        else if (console->cursor_row > 0)
   1354d:	8b 45 08             	mov    0x8(%ebp),%eax
   13550:	8b 40 08             	mov    0x8(%eax),%eax
   13553:	85 c0                	test   %eax,%eax
   13555:	7e 25                	jle    1357c <move_backword+0x67>
        {
            console->cursor_row--;
   13557:	8b 45 08             	mov    0x8(%ebp),%eax
   1355a:	8b 40 08             	mov    0x8(%eax),%eax
   1355d:	8d 50 ff             	lea    -0x1(%eax),%edx
   13560:	8b 45 08             	mov    0x8(%ebp),%eax
   13563:	89 50 08             	mov    %edx,0x8(%eax)
            console->cursor_col = console->display_cols - 1;
   13566:	8b 45 08             	mov    0x8(%ebp),%eax
   13569:	8b 40 14             	mov    0x14(%eax),%eax
   1356c:	8d 50 ff             	lea    -0x1(%eax),%edx
   1356f:	8b 45 08             	mov    0x8(%ebp),%eax
   13572:	89 50 0c             	mov    %edx,0xc(%eax)
            status = 0;
   13575:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for (int i = 0; i < n; i++)
   1357c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   13580:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13583:	3b 45 0c             	cmp    0xc(%ebp),%eax
   13586:	7c a3                	jl     1352b <move_backword+0x16>
        }
    }
    return status;
   13588:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1358b:	c9                   	leave  
   1358c:	c3                   	ret    

0001358d <erase_backword>:

static void erase_backword(console_t *console)
{
   1358d:	55                   	push   %ebp
   1358e:	89 e5                	mov    %esp,%ebp
   13590:	83 ec 08             	sub    $0x8,%esp
    if (move_backword(console, 1) == 0)
   13593:	6a 01                	push   $0x1
   13595:	ff 75 08             	pushl  0x8(%ebp)
   13598:	e8 78 ff ff ff       	call   13515 <move_backword>
   1359d:	83 c4 08             	add    $0x8,%esp
   135a0:	85 c0                	test   %eax,%eax
   135a2:	75 20                	jne    135c4 <erase_backword+0x37>
    {
        show_char(console, ' ');
   135a4:	83 ec 08             	sub    $0x8,%esp
   135a7:	6a 20                	push   $0x20
   135a9:	ff 75 08             	pushl  0x8(%ebp)
   135ac:	e8 96 fd ff ff       	call   13347 <show_char>
   135b1:	83 c4 10             	add    $0x10,%esp
        move_backword(console, 1);
   135b4:	83 ec 08             	sub    $0x8,%esp
   135b7:	6a 01                	push   $0x1
   135b9:	ff 75 08             	pushl  0x8(%ebp)
   135bc:	e8 54 ff ff ff       	call   13515 <move_backword>
   135c1:	83 c4 10             	add    $0x10,%esp
    }
}
   135c4:	90                   	nop
   135c5:	c9                   	leave  
   135c6:	c3                   	ret    

000135c7 <write_normal>:

static void write_normal(console_t *console, char ch)
{
   135c7:	55                   	push   %ebp
   135c8:	89 e5                	mov    %esp,%ebp
   135ca:	83 ec 18             	sub    $0x18,%esp
   135cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   135d0:	88 45 f4             	mov    %al,-0xc(%ebp)
    switch (ch)
   135d3:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   135d7:	83 f8 0d             	cmp    $0xd,%eax
   135da:	74 4a                	je     13626 <write_normal+0x5f>
   135dc:	83 f8 0d             	cmp    $0xd,%eax
   135df:	7f 0c                	jg     135ed <write_normal+0x26>
   135e1:	83 f8 08             	cmp    $0x8,%eax
   135e4:	74 2e                	je     13614 <write_normal+0x4d>
   135e6:	83 f8 0a             	cmp    $0xa,%eax
   135e9:	74 4b                	je     13636 <write_normal+0x6f>
   135eb:	eb 59                	jmp    13646 <write_normal+0x7f>
   135ed:	83 f8 1b             	cmp    $0x1b,%eax
   135f0:	74 07                	je     135f9 <write_normal+0x32>
   135f2:	83 f8 7f             	cmp    $0x7f,%eax
   135f5:	74 0d                	je     13604 <write_normal+0x3d>
   135f7:	eb 4d                	jmp    13646 <write_normal+0x7f>
    {
    case ASCII_ESC:
        console->write_state = CONSOLE_WRITE_ESC;
   135f9:	8b 45 08             	mov    0x8(%ebp),%eax
   135fc:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        break;
   13602:	eb 62                	jmp    13666 <write_normal+0x9f>
    case 0x7f:
        erase_backword(console);
   13604:	83 ec 0c             	sub    $0xc,%esp
   13607:	ff 75 08             	pushl  0x8(%ebp)
   1360a:	e8 7e ff ff ff       	call   1358d <erase_backword>
   1360f:	83 c4 10             	add    $0x10,%esp
        break;
   13612:	eb 52                	jmp    13666 <write_normal+0x9f>
    case '\b':
        move_backword(console, 1);
   13614:	83 ec 08             	sub    $0x8,%esp
   13617:	6a 01                	push   $0x1
   13619:	ff 75 08             	pushl  0x8(%ebp)
   1361c:	e8 f4 fe ff ff       	call   13515 <move_backword>
   13621:	83 c4 10             	add    $0x10,%esp
        break;
   13624:	eb 40                	jmp    13666 <write_normal+0x9f>
    case '\r':
        move_to_col0(console);
   13626:	83 ec 0c             	sub    $0xc,%esp
   13629:	ff 75 08             	pushl  0x8(%ebp)
   1362c:	e8 9c fe ff ff       	call   134cd <move_to_col0>
   13631:	83 c4 10             	add    $0x10,%esp
        break;
   13634:	eb 30                	jmp    13666 <write_normal+0x9f>
    case '\n':
        move_next_line(console);
   13636:	83 ec 0c             	sub    $0xc,%esp
   13639:	ff 75 08             	pushl  0x8(%ebp)
   1363c:	e8 9c fe ff ff       	call   134dd <move_next_line>
   13641:	83 c4 10             	add    $0x10,%esp
        break;
   13644:	eb 20                	jmp    13666 <write_normal+0x9f>
    default:
        if (ch >= ' ' && ch <= '~')
   13646:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
   1364a:	7e 19                	jle    13665 <write_normal+0x9e>
   1364c:	80 7d f4 7f          	cmpb   $0x7f,-0xc(%ebp)
   13650:	74 13                	je     13665 <write_normal+0x9e>
            // 后续实现
            show_char(console, ch);
   13652:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   13656:	83 ec 08             	sub    $0x8,%esp
   13659:	50                   	push   %eax
   1365a:	ff 75 08             	pushl  0x8(%ebp)
   1365d:	e8 e5 fc ff ff       	call   13347 <show_char>
   13662:	83 c4 10             	add    $0x10,%esp
        break;
   13665:	90                   	nop
    }
}
   13666:	90                   	nop
   13667:	c9                   	leave  
   13668:	c3                   	ret    

00013669 <save_cursor>:

void save_cursor(console_t *console)
{
   13669:	55                   	push   %ebp
   1366a:	89 e5                	mov    %esp,%ebp
    console->old_cursor_col = console->cursor_col;
   1366c:	8b 45 08             	mov    0x8(%ebp),%eax
   1366f:	8b 50 0c             	mov    0xc(%eax),%edx
   13672:	8b 45 08             	mov    0x8(%ebp),%eax
   13675:	89 50 50             	mov    %edx,0x50(%eax)
    console->old_cursor_row = console->cursor_row;
   13678:	8b 45 08             	mov    0x8(%ebp),%eax
   1367b:	8b 50 08             	mov    0x8(%eax),%edx
   1367e:	8b 45 08             	mov    0x8(%ebp),%eax
   13681:	89 50 4c             	mov    %edx,0x4c(%eax)
}
   13684:	90                   	nop
   13685:	5d                   	pop    %ebp
   13686:	c3                   	ret    

00013687 <restore_cursor>:

void restore_cursor(console_t *console)
{
   13687:	55                   	push   %ebp
   13688:	89 e5                	mov    %esp,%ebp
    console->cursor_col = console->old_cursor_col;
   1368a:	8b 45 08             	mov    0x8(%ebp),%eax
   1368d:	8b 50 50             	mov    0x50(%eax),%edx
   13690:	8b 45 08             	mov    0x8(%ebp),%eax
   13693:	89 50 0c             	mov    %edx,0xc(%eax)
    console->cursor_row = console->old_cursor_row;
   13696:	8b 45 08             	mov    0x8(%ebp),%eax
   13699:	8b 50 4c             	mov    0x4c(%eax),%edx
   1369c:	8b 45 08             	mov    0x8(%ebp),%eax
   1369f:	89 50 08             	mov    %edx,0x8(%eax)
}
   136a2:	90                   	nop
   136a3:	5d                   	pop    %ebp
   136a4:	c3                   	ret    

000136a5 <clear_esc_param>:

static void clear_esc_param(console_t *console)
{
   136a5:	55                   	push   %ebp
   136a6:	89 e5                	mov    %esp,%ebp
   136a8:	83 ec 10             	sub    $0x10,%esp
    for (int i = 0; i < ESC_PARAM_MAX; i++)
   136ab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   136b2:	eb 14                	jmp    136c8 <clear_esc_param+0x23>
    {
        console->esc_param[i] = 0;
   136b4:	8b 45 08             	mov    0x8(%ebp),%eax
   136b7:	8b 55 fc             	mov    -0x4(%ebp),%edx
   136ba:	83 c2 08             	add    $0x8,%edx
   136bd:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
    for (int i = 0; i < ESC_PARAM_MAX; i++)
   136c4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   136c8:	83 7d fc 09          	cmpl   $0x9,-0x4(%ebp)
   136cc:	7e e6                	jle    136b4 <clear_esc_param+0xf>
    }
    console->esc_param_index = 0;
   136ce:	8b 45 08             	mov    0x8(%ebp),%eax
   136d1:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
}
   136d8:	90                   	nop
   136d9:	c9                   	leave  
   136da:	c3                   	ret    

000136db <write_esc>:

static void write_esc(console_t *console, char ch)
{
   136db:	55                   	push   %ebp
   136dc:	89 e5                	mov    %esp,%ebp
   136de:	83 ec 04             	sub    $0x4,%esp
   136e1:	8b 45 0c             	mov    0xc(%ebp),%eax
   136e4:	88 45 fc             	mov    %al,-0x4(%ebp)
    switch (ch)
   136e7:	0f be 45 fc          	movsbl -0x4(%ebp),%eax
   136eb:	83 f8 38             	cmp    $0x38,%eax
   136ee:	74 20                	je     13710 <write_esc+0x35>
   136f0:	83 f8 5b             	cmp    $0x5b,%eax
   136f3:	74 31                	je     13726 <write_esc+0x4b>
   136f5:	83 f8 37             	cmp    $0x37,%eax
   136f8:	75 42                	jne    1373c <write_esc+0x61>
    {
    case '7':
        save_cursor(console);
   136fa:	ff 75 08             	pushl  0x8(%ebp)
   136fd:	e8 67 ff ff ff       	call   13669 <save_cursor>
   13702:	83 c4 04             	add    $0x4,%esp
        console->write_state = CONSOLE_WRITE_NORMAL;
   13705:	8b 45 08             	mov    0x8(%ebp),%eax
   13708:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        break;
   1370e:	eb 36                	jmp    13746 <write_esc+0x6b>
    case '8':
        restore_cursor(console);
   13710:	ff 75 08             	pushl  0x8(%ebp)
   13713:	e8 6f ff ff ff       	call   13687 <restore_cursor>
   13718:	83 c4 04             	add    $0x4,%esp
        console->write_state = CONSOLE_WRITE_NORMAL;
   1371b:	8b 45 08             	mov    0x8(%ebp),%eax
   1371e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        break;
   13724:	eb 20                	jmp    13746 <write_esc+0x6b>
    case '[':
        clear_esc_param(console);
   13726:	ff 75 08             	pushl  0x8(%ebp)
   13729:	e8 77 ff ff ff       	call   136a5 <clear_esc_param>
   1372e:	83 c4 04             	add    $0x4,%esp
        console->write_state = CONSOLE_WRITE_SQUARE;
   13731:	8b 45 08             	mov    0x8(%ebp),%eax
   13734:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        break;
   1373a:	eb 0a                	jmp    13746 <write_esc+0x6b>
    default:
        console->write_state = CONSOLE_WRITE_NORMAL;
   1373c:	8b 45 08             	mov    0x8(%ebp),%eax
   1373f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        break;
   13745:	90                   	nop
    }
}
   13746:	90                   	nop
   13747:	c9                   	leave  
   13748:	c3                   	ret    

00013749 <set_font_style>:

static void set_font_style(console_t *console)
{
   13749:	55                   	push   %ebp
   1374a:	89 e5                	mov    %esp,%ebp
   1374c:	83 ec 10             	sub    $0x10,%esp
            COLOR_Blue,
            COLOR_Magenta,
            COLOR_Cyan,
            COLOR_White,
        };
    for (int i = 0; i <= console->esc_param_index; i++)
   1374f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   13756:	eb 77                	jmp    137cf <set_font_style+0x86>
    {
        int param = console->esc_param[i];
   13758:	8b 45 08             	mov    0x8(%ebp),%eax
   1375b:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1375e:	83 c2 08             	add    $0x8,%edx
   13761:	8b 04 90             	mov    (%eax,%edx,4),%eax
   13764:	89 45 f8             	mov    %eax,-0x8(%ebp)
        if ((param >= 30) && (param <= 37))
   13767:	83 7d f8 1d          	cmpl   $0x1d,-0x8(%ebp)
   1376b:	7e 1b                	jle    13788 <set_font_style+0x3f>
   1376d:	83 7d f8 25          	cmpl   $0x25,-0x8(%ebp)
   13771:	7f 15                	jg     13788 <set_font_style+0x3f>
        {
            console->foregroud = color_table[param - 30];
   13773:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13776:	83 e8 1e             	sub    $0x1e,%eax
   13779:	8b 14 85 80 7b 01 00 	mov    0x17b80(,%eax,4),%edx
   13780:	8b 45 08             	mov    0x8(%ebp),%eax
   13783:	89 50 18             	mov    %edx,0x18(%eax)
   13786:	eb 43                	jmp    137cb <set_font_style+0x82>
        }
        else if ((param >= 40) && (param <= 47))
   13788:	83 7d f8 27          	cmpl   $0x27,-0x8(%ebp)
   1378c:	7e 1b                	jle    137a9 <set_font_style+0x60>
   1378e:	83 7d f8 2f          	cmpl   $0x2f,-0x8(%ebp)
   13792:	7f 15                	jg     137a9 <set_font_style+0x60>
        {
            console->background = color_table[param - 40];
   13794:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13797:	83 e8 28             	sub    $0x28,%eax
   1379a:	8b 14 85 80 7b 01 00 	mov    0x17b80(,%eax,4),%edx
   137a1:	8b 45 08             	mov    0x8(%ebp),%eax
   137a4:	89 50 1c             	mov    %edx,0x1c(%eax)
   137a7:	eb 22                	jmp    137cb <set_font_style+0x82>
        }
        else if (param == 39)
   137a9:	83 7d f8 27          	cmpl   $0x27,-0x8(%ebp)
   137ad:	75 0c                	jne    137bb <set_font_style+0x72>
        {
            console->foregroud = COLOR_White;
   137af:	8b 45 08             	mov    0x8(%ebp),%eax
   137b2:	c7 40 18 0f 00 00 00 	movl   $0xf,0x18(%eax)
   137b9:	eb 10                	jmp    137cb <set_font_style+0x82>
        }
        else if (param == 49)
   137bb:	83 7d f8 31          	cmpl   $0x31,-0x8(%ebp)
   137bf:	75 0a                	jne    137cb <set_font_style+0x82>
        {
            console->background = COLOR_Black;
   137c1:	8b 45 08             	mov    0x8(%ebp),%eax
   137c4:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    for (int i = 0; i <= console->esc_param_index; i++)
   137cb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   137cf:	8b 45 08             	mov    0x8(%ebp),%eax
   137d2:	8b 40 48             	mov    0x48(%eax),%eax
   137d5:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   137d8:	0f 8e 7a ff ff ff    	jle    13758 <set_font_style+0xf>
        }
    }
}
   137de:	90                   	nop
   137df:	c9                   	leave  
   137e0:	c3                   	ret    

000137e1 <eraase_in_display>:

static void eraase_in_display(console_t *console)
{
   137e1:	55                   	push   %ebp
   137e2:	89 e5                	mov    %esp,%ebp
   137e4:	83 ec 10             	sub    $0x10,%esp
    if (console->esc_param_index < 0)
   137e7:	8b 45 08             	mov    0x8(%ebp),%eax
   137ea:	8b 40 48             	mov    0x48(%eax),%eax
   137ed:	85 c0                	test   %eax,%eax
   137ef:	78 3e                	js     1382f <eraase_in_display+0x4e>
    {
        return;
    }
    int param = console->esc_param[0];
   137f1:	8b 45 08             	mov    0x8(%ebp),%eax
   137f4:	8b 40 20             	mov    0x20(%eax),%eax
   137f7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (param == 2)
   137fa:	83 7d fc 02          	cmpl   $0x2,-0x4(%ebp)
   137fe:	75 30                	jne    13830 <eraase_in_display+0x4f>
    {
        erase_rows(console, 0, console->display_rows - 1);
   13800:	8b 45 08             	mov    0x8(%ebp),%eax
   13803:	8b 40 10             	mov    0x10(%eax),%eax
   13806:	83 e8 01             	sub    $0x1,%eax
   13809:	50                   	push   %eax
   1380a:	6a 00                	push   $0x0
   1380c:	ff 75 08             	pushl  0x8(%ebp)
   1380f:	e8 1a f9 ff ff       	call   1312e <erase_rows>
   13814:	83 c4 0c             	add    $0xc,%esp
        console->cursor_col = console->cursor_row = 0;
   13817:	8b 45 08             	mov    0x8(%ebp),%eax
   1381a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   13821:	8b 45 08             	mov    0x8(%ebp),%eax
   13824:	8b 50 08             	mov    0x8(%eax),%edx
   13827:	8b 45 08             	mov    0x8(%ebp),%eax
   1382a:	89 50 0c             	mov    %edx,0xc(%eax)
   1382d:	eb 01                	jmp    13830 <eraase_in_display+0x4f>
        return;
   1382f:	90                   	nop
    }
}
   13830:	c9                   	leave  
   13831:	c3                   	ret    

00013832 <move_cursor>:

static void move_cursor(console_t *console, int row, int col)
{
   13832:	55                   	push   %ebp
   13833:	89 e5                	mov    %esp,%ebp
    console->cursor_row = console->esc_param[0];
   13835:	8b 45 08             	mov    0x8(%ebp),%eax
   13838:	8b 50 20             	mov    0x20(%eax),%edx
   1383b:	8b 45 08             	mov    0x8(%ebp),%eax
   1383e:	89 50 08             	mov    %edx,0x8(%eax)
    console->cursor_col = console->esc_param[1];
   13841:	8b 45 08             	mov    0x8(%ebp),%eax
   13844:	8b 50 24             	mov    0x24(%eax),%edx
   13847:	8b 45 08             	mov    0x8(%ebp),%eax
   1384a:	89 50 0c             	mov    %edx,0xc(%eax)
}
   1384d:	90                   	nop
   1384e:	5d                   	pop    %ebp
   1384f:	c3                   	ret    

00013850 <move_left>:

static void move_left(console_t *console, int n)
{
   13850:	55                   	push   %ebp
   13851:	89 e5                	mov    %esp,%ebp
   13853:	83 ec 10             	sub    $0x10,%esp
    if (n == 0)
   13856:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1385a:	75 07                	jne    13863 <move_left+0x13>
    {
        n = 1;
   1385c:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
    }

    int col = console->cursor_col - n;
   13863:	8b 45 08             	mov    0x8(%ebp),%eax
   13866:	8b 40 0c             	mov    0xc(%eax),%eax
   13869:	2b 45 0c             	sub    0xc(%ebp),%eax
   1386c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    console->cursor_col = (col < 0) ? 0 : col;
   1386f:	b8 00 00 00 00       	mov    $0x0,%eax
   13874:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   13878:	0f 49 45 fc          	cmovns -0x4(%ebp),%eax
   1387c:	89 c2                	mov    %eax,%edx
   1387e:	8b 45 08             	mov    0x8(%ebp),%eax
   13881:	89 50 0c             	mov    %edx,0xc(%eax)
}
   13884:	90                   	nop
   13885:	c9                   	leave  
   13886:	c3                   	ret    

00013887 <move_right>:

static void move_right(console_t *console, int n)
{
   13887:	55                   	push   %ebp
   13888:	89 e5                	mov    %esp,%ebp
   1388a:	83 ec 10             	sub    $0x10,%esp
    if (n == 0)
   1388d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13891:	75 07                	jne    1389a <move_right+0x13>
    {
        n = 1;
   13893:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
    }

    int col = console->cursor_col + n;
   1389a:	8b 45 08             	mov    0x8(%ebp),%eax
   1389d:	8b 50 0c             	mov    0xc(%eax),%edx
   138a0:	8b 45 0c             	mov    0xc(%ebp),%eax
   138a3:	01 d0                	add    %edx,%eax
   138a5:	89 45 fc             	mov    %eax,-0x4(%ebp)
    console->cursor_col = (col >= console->display_cols) ? console->display_cols - 1 : col;
   138a8:	8b 45 08             	mov    0x8(%ebp),%eax
   138ab:	8b 40 14             	mov    0x14(%eax),%eax
   138ae:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   138b1:	7c 0b                	jl     138be <move_right+0x37>
   138b3:	8b 45 08             	mov    0x8(%ebp),%eax
   138b6:	8b 40 14             	mov    0x14(%eax),%eax
   138b9:	83 e8 01             	sub    $0x1,%eax
   138bc:	eb 03                	jmp    138c1 <move_right+0x3a>
   138be:	8b 45 fc             	mov    -0x4(%ebp),%eax
   138c1:	8b 55 08             	mov    0x8(%ebp),%edx
   138c4:	89 42 0c             	mov    %eax,0xc(%edx)
}
   138c7:	90                   	nop
   138c8:	c9                   	leave  
   138c9:	c3                   	ret    

000138ca <write_esc_square>:

static void write_esc_square(console_t *console, char c)
{
   138ca:	55                   	push   %ebp
   138cb:	89 e5                	mov    %esp,%ebp
   138cd:	83 ec 14             	sub    $0x14,%esp
   138d0:	8b 45 0c             	mov    0xc(%ebp),%eax
   138d3:	88 45 ec             	mov    %al,-0x14(%ebp)
    if ((c >= '0') && (c <= '9'))
   138d6:	80 7d ec 2f          	cmpb   $0x2f,-0x14(%ebp)
   138da:	7e 41                	jle    1391d <write_esc_square+0x53>
   138dc:	80 7d ec 39          	cmpb   $0x39,-0x14(%ebp)
   138e0:	7f 3b                	jg     1391d <write_esc_square+0x53>
    {
        int *param = &console->esc_param[console->esc_param_index];
   138e2:	8b 45 08             	mov    0x8(%ebp),%eax
   138e5:	8b 40 48             	mov    0x48(%eax),%eax
   138e8:	83 c0 08             	add    $0x8,%eax
   138eb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   138f2:	8b 45 08             	mov    0x8(%ebp),%eax
   138f5:	01 d0                	add    %edx,%eax
   138f7:	89 45 fc             	mov    %eax,-0x4(%ebp)
        *param = *param * 10 + c - '0';
   138fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
   138fd:	8b 10                	mov    (%eax),%edx
   138ff:	89 d0                	mov    %edx,%eax
   13901:	c1 e0 02             	shl    $0x2,%eax
   13904:	01 d0                	add    %edx,%eax
   13906:	01 c0                	add    %eax,%eax
   13908:	89 c2                	mov    %eax,%edx
   1390a:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
   1390e:	01 d0                	add    %edx,%eax
   13910:	8d 50 d0             	lea    -0x30(%eax),%edx
   13913:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13916:	89 10                	mov    %edx,(%eax)
    {
   13918:	e9 9c 00 00 00       	jmp    139b9 <write_esc_square+0xef>
    }
    else if ((c == ';') && console->esc_param_index < ESC_PARAM_MAX)
   1391d:	80 7d ec 3b          	cmpb   $0x3b,-0x14(%ebp)
   13921:	75 1c                	jne    1393f <write_esc_square+0x75>
   13923:	8b 45 08             	mov    0x8(%ebp),%eax
   13926:	8b 40 48             	mov    0x48(%eax),%eax
   13929:	83 f8 09             	cmp    $0x9,%eax
   1392c:	7f 11                	jg     1393f <write_esc_square+0x75>
    {
        console->esc_param_index++;
   1392e:	8b 45 08             	mov    0x8(%ebp),%eax
   13931:	8b 40 48             	mov    0x48(%eax),%eax
   13934:	8d 50 01             	lea    0x1(%eax),%edx
   13937:	8b 45 08             	mov    0x8(%ebp),%eax
   1393a:	89 50 48             	mov    %edx,0x48(%eax)
   1393d:	eb 7a                	jmp    139b9 <write_esc_square+0xef>
    }
    else
    {
        switch (c)
   1393f:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
   13943:	83 e8 43             	sub    $0x43,%eax
   13946:	83 f8 2a             	cmp    $0x2a,%eax
   13949:	77 64                	ja     139af <write_esc_square+0xe5>
   1394b:	8b 04 85 c0 7a 01 00 	mov    0x17ac0(,%eax,4),%eax
   13952:	ff e0                	jmp    *%eax
        {
        case 'm':
            set_font_style(console);
   13954:	ff 75 08             	pushl  0x8(%ebp)
   13957:	e8 ed fd ff ff       	call   13749 <set_font_style>
   1395c:	83 c4 04             	add    $0x4,%esp
            break;
   1395f:	eb 4f                	jmp    139b0 <write_esc_square+0xe6>
        case 'D':
            move_left(console, console->esc_param[0]);
   13961:	8b 45 08             	mov    0x8(%ebp),%eax
   13964:	8b 40 20             	mov    0x20(%eax),%eax
   13967:	50                   	push   %eax
   13968:	ff 75 08             	pushl  0x8(%ebp)
   1396b:	e8 e0 fe ff ff       	call   13850 <move_left>
   13970:	83 c4 08             	add    $0x8,%esp
            break;
   13973:	eb 3b                	jmp    139b0 <write_esc_square+0xe6>
        case 'C':
            move_right(console, console->esc_param[0]);
   13975:	8b 45 08             	mov    0x8(%ebp),%eax
   13978:	8b 40 20             	mov    0x20(%eax),%eax
   1397b:	50                   	push   %eax
   1397c:	ff 75 08             	pushl  0x8(%ebp)
   1397f:	e8 03 ff ff ff       	call   13887 <move_right>
   13984:	83 c4 08             	add    $0x8,%esp
            break;
   13987:	eb 27                	jmp    139b0 <write_esc_square+0xe6>
        case 'H':
        case 'f':
            move_cursor(console, console->esc_param[0], console->esc_param[1]);
   13989:	8b 45 08             	mov    0x8(%ebp),%eax
   1398c:	8b 50 24             	mov    0x24(%eax),%edx
   1398f:	8b 45 08             	mov    0x8(%ebp),%eax
   13992:	8b 40 20             	mov    0x20(%eax),%eax
   13995:	52                   	push   %edx
   13996:	50                   	push   %eax
   13997:	ff 75 08             	pushl  0x8(%ebp)
   1399a:	e8 93 fe ff ff       	call   13832 <move_cursor>
   1399f:	83 c4 0c             	add    $0xc,%esp
        case 'J':
            eraase_in_display(console);
   139a2:	ff 75 08             	pushl  0x8(%ebp)
   139a5:	e8 37 fe ff ff       	call   137e1 <eraase_in_display>
   139aa:	83 c4 04             	add    $0x4,%esp
            break;
   139ad:	eb 01                	jmp    139b0 <write_esc_square+0xe6>
        default:
            break;
   139af:	90                   	nop
        }
        console->write_state = CONSOLE_WRITE_NORMAL;
   139b0:	8b 45 08             	mov    0x8(%ebp),%eax
   139b3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
   139b9:	90                   	nop
   139ba:	c9                   	leave  
   139bb:	c3                   	ret    

000139bc <console_write>:
/**
 * 实现pwdget作为tty的输出
 * 可能有多个进程在写，注意保护
 */
int console_write(tty_t *tty)
{
   139bc:	55                   	push   %ebp
   139bd:	89 e5                	mov    %esp,%ebp
   139bf:	83 ec 18             	sub    $0x18,%esp
    console_t *console = console_buff + tty->console_idx;
   139c2:	8b 45 08             	mov    0x8(%ebp),%eax
   139c5:	8b 80 50 04 00 00    	mov    0x450(%eax),%eax
   139cb:	6b c0 68             	imul   $0x68,%eax,%eax
   139ce:	05 40 56 03 00       	add    $0x35640,%eax
   139d3:	89 45 f0             	mov    %eax,-0x10(%ebp)

    mutex_lock(&console->mutex);
   139d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   139d9:	83 c0 54             	add    $0x54,%eax
   139dc:	83 ec 0c             	sub    $0xc,%esp
   139df:	50                   	push   %eax
   139e0:	e8 8e 29 00 00       	call   16373 <mutex_lock>
   139e5:	83 c4 10             	add    $0x10,%esp
    int len = 0;
   139e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    do
    {
        char c;

        // 取字节数据
        int err = tty_fifo_get(&tty->ofifo, &c);
   139ef:	8b 45 08             	mov    0x8(%ebp),%eax
   139f2:	8d 90 00 02 00 00    	lea    0x200(%eax),%edx
   139f8:	83 ec 08             	sub    $0x8,%esp
   139fb:	8d 45 eb             	lea    -0x15(%ebp),%eax
   139fe:	50                   	push   %eax
   139ff:	52                   	push   %edx
   13a00:	e8 5c 18 00 00       	call   15261 <tty_fifo_get>
   13a05:	83 c4 10             	add    $0x10,%esp
   13a08:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (err < 0)
   13a0b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   13a0f:	79 29                	jns    13a3a <console_write+0x7e>
            write_esc_square(console, c);
            break;
        }
        len++;
    } while (1);
    mutex_unlock(&console->mutex);
   13a11:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13a14:	83 c0 54             	add    $0x54,%eax
   13a17:	83 ec 0c             	sub    $0xc,%esp
   13a1a:	50                   	push   %eax
   13a1b:	e8 ea 29 00 00       	call   1640a <mutex_unlock>
   13a20:	83 c4 10             	add    $0x10,%esp
    if (tty->console_idx == curr_console_idx)
   13a23:	8b 45 08             	mov    0x8(%ebp),%eax
   13a26:	8b 90 50 04 00 00    	mov    0x450(%eax),%edx
   13a2c:	a1 80 59 03 00       	mov    0x35980,%eax
   13a31:	39 c2                	cmp    %eax,%edx
   13a33:	74 7f                	je     13ab4 <console_write+0xf8>
   13a35:	e9 88 00 00 00       	jmp    13ac2 <console_write+0x106>
        sem_signal(&tty->osem);
   13a3a:	8b 45 08             	mov    0x8(%ebp),%eax
   13a3d:	05 14 02 00 00       	add    $0x214,%eax
   13a42:	83 ec 0c             	sub    $0xc,%esp
   13a45:	50                   	push   %eax
   13a46:	e8 2f 2b 00 00       	call   1657a <sem_signal>
   13a4b:	83 c4 10             	add    $0x10,%esp
        switch (console->write_state)
   13a4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13a51:	8b 00                	mov    (%eax),%eax
   13a53:	83 f8 01             	cmp    $0x1,%eax
   13a56:	74 24                	je     13a7c <console_write+0xc0>
   13a58:	83 f8 01             	cmp    $0x1,%eax
   13a5b:	72 07                	jb     13a64 <console_write+0xa8>
   13a5d:	83 f8 02             	cmp    $0x2,%eax
   13a60:	74 32                	je     13a94 <console_write+0xd8>
   13a62:	eb 47                	jmp    13aab <console_write+0xef>
            write_normal(console, c);
   13a64:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   13a68:	0f be c0             	movsbl %al,%eax
   13a6b:	83 ec 08             	sub    $0x8,%esp
   13a6e:	50                   	push   %eax
   13a6f:	ff 75 f0             	pushl  -0x10(%ebp)
   13a72:	e8 50 fb ff ff       	call   135c7 <write_normal>
   13a77:	83 c4 10             	add    $0x10,%esp
            break;
   13a7a:	eb 2f                	jmp    13aab <console_write+0xef>
            write_esc(console, c);
   13a7c:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   13a80:	0f be c0             	movsbl %al,%eax
   13a83:	83 ec 08             	sub    $0x8,%esp
   13a86:	50                   	push   %eax
   13a87:	ff 75 f0             	pushl  -0x10(%ebp)
   13a8a:	e8 4c fc ff ff       	call   136db <write_esc>
   13a8f:	83 c4 10             	add    $0x10,%esp
            break;
   13a92:	eb 17                	jmp    13aab <console_write+0xef>
            write_esc_square(console, c);
   13a94:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   13a98:	0f be c0             	movsbl %al,%eax
   13a9b:	83 ec 08             	sub    $0x8,%esp
   13a9e:	50                   	push   %eax
   13a9f:	ff 75 f0             	pushl  -0x10(%ebp)
   13aa2:	e8 23 fe ff ff       	call   138ca <write_esc_square>
   13aa7:	83 c4 10             	add    $0x10,%esp
            break;
   13aaa:	90                   	nop
        len++;
   13aab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    {
   13aaf:	e9 3b ff ff ff       	jmp    139ef <console_write+0x33>
    {
        update_cursor_pos(console);
   13ab4:	83 ec 0c             	sub    $0xc,%esp
   13ab7:	ff 75 f0             	pushl  -0x10(%ebp)
   13aba:	e8 ac f5 ff ff       	call   1306b <update_cursor_pos>
   13abf:	83 c4 10             	add    $0x10,%esp
    }
    return len;
   13ac2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13ac5:	c9                   	leave  
   13ac6:	c3                   	ret    

00013ac7 <console_close>:

void console_close(int console)
{
   13ac7:	55                   	push   %ebp
   13ac8:	89 e5                	mov    %esp,%ebp
}
   13aca:	90                   	nop
   13acb:	5d                   	pop    %ebp
   13acc:	c3                   	ret    

00013acd <console_select>:

int console_select(int index)
{
   13acd:	55                   	push   %ebp
   13ace:	89 e5                	mov    %esp,%ebp
   13ad0:	83 ec 18             	sub    $0x18,%esp
    console_t *console = console_buff + index;
   13ad3:	8b 45 08             	mov    0x8(%ebp),%eax
   13ad6:	6b c0 68             	imul   $0x68,%eax,%eax
   13ad9:	05 40 56 03 00       	add    $0x35640,%eax
   13ade:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (console->disp_base == 0)
   13ae1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13ae4:	8b 40 04             	mov    0x4(%eax),%eax
   13ae7:	85 c0                	test   %eax,%eax
   13ae9:	75 0e                	jne    13af9 <console_select+0x2c>
    {
        console_init(index);
   13aeb:	83 ec 0c             	sub    $0xc,%esp
   13aee:	ff 75 08             	pushl  0x8(%ebp)
   13af1:	e8 e6 f8 ff ff       	call   133dc <console_init>
   13af6:	83 c4 10             	add    $0x10,%esp
    }
    uint16_t pos = index *
                   console->display_cols * console->display_rows;
   13af9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13afc:	8b 40 14             	mov    0x14(%eax),%eax
    uint16_t pos = index *
   13aff:	89 c2                	mov    %eax,%edx
   13b01:	8b 45 08             	mov    0x8(%ebp),%eax
   13b04:	0f af d0             	imul   %eax,%edx
                   console->display_cols * console->display_rows;
   13b07:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13b0a:	8b 40 10             	mov    0x10(%eax),%eax
    uint16_t pos = index *
   13b0d:	0f af c2             	imul   %edx,%eax
   13b10:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

    outb(0x3D4, 0xC); // 写高地址
   13b14:	83 ec 08             	sub    $0x8,%esp
   13b17:	6a 0c                	push   $0xc
   13b19:	68 d4 03 00 00       	push   $0x3d4
   13b1e:	e8 b4 f4 ff ff       	call   12fd7 <outb>
   13b23:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5, (uint8_t)((pos >> 8) & 0xFF));
   13b26:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   13b2a:	66 c1 e8 08          	shr    $0x8,%ax
   13b2e:	0f b6 c0             	movzbl %al,%eax
   13b31:	83 ec 08             	sub    $0x8,%esp
   13b34:	50                   	push   %eax
   13b35:	68 d5 03 00 00       	push   $0x3d5
   13b3a:	e8 98 f4 ff ff       	call   12fd7 <outb>
   13b3f:	83 c4 10             	add    $0x10,%esp
    outb(0x3D4, 0xD); // 写低地址
   13b42:	83 ec 08             	sub    $0x8,%esp
   13b45:	6a 0d                	push   $0xd
   13b47:	68 d4 03 00 00       	push   $0x3d4
   13b4c:	e8 86 f4 ff ff       	call   12fd7 <outb>
   13b51:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5, (uint8_t)(pos & 0xFF));
   13b54:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   13b58:	0f b6 c0             	movzbl %al,%eax
   13b5b:	83 ec 08             	sub    $0x8,%esp
   13b5e:	50                   	push   %eax
   13b5f:	68 d5 03 00 00       	push   $0x3d5
   13b64:	e8 6e f4 ff ff       	call   12fd7 <outb>
   13b69:	83 c4 10             	add    $0x10,%esp

    curr_console_idx = index;
   13b6c:	8b 45 08             	mov    0x8(%ebp),%eax
   13b6f:	a3 80 59 03 00       	mov    %eax,0x35980
    update_cursor_pos(console);
   13b74:	83 ec 0c             	sub    $0xc,%esp
   13b77:	ff 75 f4             	pushl  -0xc(%ebp)
   13b7a:	e8 ec f4 ff ff       	call   1306b <update_cursor_pos>
   13b7f:	83 c4 10             	add    $0x10,%esp

    // char num = '0' + index;

    // show_char (console, num);
   13b82:	90                   	nop
   13b83:	c9                   	leave  
   13b84:	c3                   	ret    

00013b85 <dev_open>:

/**
 * @brief 打开指定的设备
 */
int dev_open(int major, int minor, void *data)
{
   13b85:	55                   	push   %ebp
   13b86:	89 e5                	mov    %esp,%ebp
   13b88:	83 ec 28             	sub    $0x28,%esp
    int state = irq_enter_protection();
   13b8b:	e8 ec f3 ff ff       	call   12f7c <irq_enter_protection>
   13b90:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    // 遍历：遇到已经打开的直接返回；否则找一个空闲项
    device_t *free_dev = (device_t *)0;
   13b93:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    for (int i = 0; i < sizeof(dev_table) / sizeof(dev_table[0]); i++)
   13b9a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13ba1:	eb 69                	jmp    13c0c <dev_open+0x87>
    {
        device_t *dev = &dev_table[i];
   13ba3:	8b 55 f0             	mov    -0x10(%ebp),%edx
   13ba6:	89 d0                	mov    %edx,%eax
   13ba8:	c1 e0 02             	shl    $0x2,%eax
   13bab:	01 d0                	add    %edx,%eax
   13bad:	c1 e0 02             	shl    $0x2,%eax
   13bb0:	05 a0 59 03 00       	add    $0x359a0,%eax
   13bb5:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if (dev->open_count == 0)
   13bb8:	8b 45 d8             	mov    -0x28(%ebp),%eax
   13bbb:	8b 40 10             	mov    0x10(%eax),%eax
   13bbe:	85 c0                	test   %eax,%eax
   13bc0:	75 08                	jne    13bca <dev_open+0x45>
        {
            // 纪录空闲值
            free_dev = dev;
   13bc2:	8b 45 d8             	mov    -0x28(%ebp),%eax
   13bc5:	89 45 f4             	mov    %eax,-0xc(%ebp)
   13bc8:	eb 3e                	jmp    13c08 <dev_open+0x83>
        }
        else if ((dev->desc->major == major) && (dev->minor == minor))
   13bca:	8b 45 d8             	mov    -0x28(%ebp),%eax
   13bcd:	8b 00                	mov    (%eax),%eax
   13bcf:	8b 40 20             	mov    0x20(%eax),%eax
   13bd2:	39 45 08             	cmp    %eax,0x8(%ebp)
   13bd5:	75 31                	jne    13c08 <dev_open+0x83>
   13bd7:	8b 45 d8             	mov    -0x28(%ebp),%eax
   13bda:	8b 40 08             	mov    0x8(%eax),%eax
   13bdd:	39 45 0c             	cmp    %eax,0xc(%ebp)
   13be0:	75 26                	jne    13c08 <dev_open+0x83>
        {
            // 找到了已经打开的？直接返回就好
            dev->open_count++;
   13be2:	8b 45 d8             	mov    -0x28(%ebp),%eax
   13be5:	8b 40 10             	mov    0x10(%eax),%eax
   13be8:	8d 50 01             	lea    0x1(%eax),%edx
   13beb:	8b 45 d8             	mov    -0x28(%ebp),%eax
   13bee:	89 50 10             	mov    %edx,0x10(%eax)
            irq_leave_protection(state);
   13bf1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13bf4:	83 ec 0c             	sub    $0xc,%esp
   13bf7:	50                   	push   %eax
   13bf8:	e8 97 f3 ff ff       	call   12f94 <irq_leave_protection>
   13bfd:	83 c4 10             	add    $0x10,%esp
            return i;
   13c00:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13c03:	e9 ca 00 00 00       	jmp    13cd2 <dev_open+0x14d>
    for (int i = 0; i < sizeof(dev_table) / sizeof(dev_table[0]); i++)
   13c08:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   13c0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13c0f:	83 f8 7f             	cmp    $0x7f,%eax
   13c12:	76 8f                	jbe    13ba3 <dev_open+0x1e>
        }
    }

    // 新打开设备？查找设备类型描述符, 看看是不是支持的类型
    dev_desc_t *desc = (dev_desc_t *)0;
   13c14:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for (int i = 0; i < sizeof(dev_desc_table) / sizeof(dev_desc_table[0]); i++)
   13c1b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   13c22:	eb 24                	jmp    13c48 <dev_open+0xc3>
    {
        dev_desc_t *d = dev_desc_table[i];
   13c24:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13c27:	8b 04 85 50 90 01 00 	mov    0x19050(,%eax,4),%eax
   13c2e:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if (d->major == major)
   13c31:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13c34:	8b 40 20             	mov    0x20(%eax),%eax
   13c37:	39 45 08             	cmp    %eax,0x8(%ebp)
   13c3a:	75 08                	jne    13c44 <dev_open+0xbf>
        {
            desc = d;
   13c3c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13c3f:	89 45 ec             	mov    %eax,-0x14(%ebp)
            break;
   13c42:	eb 0c                	jmp    13c50 <dev_open+0xcb>
    for (int i = 0; i < sizeof(dev_desc_table) / sizeof(dev_desc_table[0]); i++)
   13c44:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   13c48:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13c4b:	83 f8 01             	cmp    $0x1,%eax
   13c4e:	76 d4                	jbe    13c24 <dev_open+0x9f>
        }
    }
    if (desc && free_dev)
   13c50:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   13c54:	74 68                	je     13cbe <dev_open+0x139>
   13c56:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13c5a:	74 62                	je     13cbe <dev_open+0x139>
    {
        free_dev->minor = minor;
   13c5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13c5f:	8b 55 0c             	mov    0xc(%ebp),%edx
   13c62:	89 50 08             	mov    %edx,0x8(%eax)
        free_dev->data = data;
   13c65:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13c68:	8b 55 10             	mov    0x10(%ebp),%edx
   13c6b:	89 50 0c             	mov    %edx,0xc(%eax)
        free_dev->desc = desc;
   13c6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13c71:	8b 55 ec             	mov    -0x14(%ebp),%edx
   13c74:	89 10                	mov    %edx,(%eax)

        int err = desc->open(free_dev);
   13c76:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13c79:	8b 40 24             	mov    0x24(%eax),%eax
   13c7c:	83 ec 0c             	sub    $0xc,%esp
   13c7f:	ff 75 f4             	pushl  -0xc(%ebp)
   13c82:	ff d0                	call   *%eax
   13c84:	83 c4 10             	add    $0x10,%esp
   13c87:	89 45 dc             	mov    %eax,-0x24(%ebp)
        if (err == 0)
   13c8a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   13c8e:	75 2e                	jne    13cbe <dev_open+0x139>
        {
            free_dev->open_count = 1;
   13c90:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13c93:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
            irq_leave_protection(state);
   13c9a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13c9d:	83 ec 0c             	sub    $0xc,%esp
   13ca0:	50                   	push   %eax
   13ca1:	e8 ee f2 ff ff       	call   12f94 <irq_leave_protection>
   13ca6:	83 c4 10             	add    $0x10,%esp
            return free_dev - dev_table;
   13ca9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13cac:	ba a0 59 03 00       	mov    $0x359a0,%edx
   13cb1:	29 d0                	sub    %edx,%eax
   13cb3:	c1 f8 02             	sar    $0x2,%eax
   13cb6:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
   13cbc:	eb 14                	jmp    13cd2 <dev_open+0x14d>
        }
    }

    irq_leave_protection(state);
   13cbe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13cc1:	83 ec 0c             	sub    $0xc,%esp
   13cc4:	50                   	push   %eax
   13cc5:	e8 ca f2 ff ff       	call   12f94 <irq_leave_protection>
   13cca:	83 c4 10             	add    $0x10,%esp
    return -1;
   13ccd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   13cd2:	c9                   	leave  
   13cd3:	c3                   	ret    

00013cd4 <is_devid_valid>:

static int is_devid_valid(int dev_id)
{
   13cd4:	55                   	push   %ebp
   13cd5:	89 e5                	mov    %esp,%ebp
    if (dev_id < 0 || dev_id >= DEV_TABLE_SIZE)
   13cd7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13cdb:	78 06                	js     13ce3 <is_devid_valid+0xf>
   13cdd:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   13ce1:	7e 07                	jle    13cea <is_devid_valid+0x16>
    {
        return 1;
   13ce3:	b8 01 00 00 00       	mov    $0x1,%eax
   13ce8:	eb 24                	jmp    13d0e <is_devid_valid+0x3a>
    }
    if (dev_table[dev_id].desc == (dev_desc_t *)0)
   13cea:	8b 55 08             	mov    0x8(%ebp),%edx
   13ced:	89 d0                	mov    %edx,%eax
   13cef:	c1 e0 02             	shl    $0x2,%eax
   13cf2:	01 d0                	add    %edx,%eax
   13cf4:	c1 e0 02             	shl    $0x2,%eax
   13cf7:	05 a0 59 03 00       	add    $0x359a0,%eax
   13cfc:	8b 00                	mov    (%eax),%eax
   13cfe:	85 c0                	test   %eax,%eax
   13d00:	75 07                	jne    13d09 <is_devid_valid+0x35>
    {
        return 1;
   13d02:	b8 01 00 00 00       	mov    $0x1,%eax
   13d07:	eb 05                	jmp    13d0e <is_devid_valid+0x3a>
    }
    return 0;
   13d09:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13d0e:	5d                   	pop    %ebp
   13d0f:	c3                   	ret    

00013d10 <dev_read>:

/**
 * @brief 读取指定字节的数据
 */
int dev_read(int dev_id, int addr, char *buf, int size)
{
   13d10:	55                   	push   %ebp
   13d11:	89 e5                	mov    %esp,%ebp
   13d13:	83 ec 18             	sub    $0x18,%esp
    if (is_devid_valid(dev_id))
   13d16:	ff 75 08             	pushl  0x8(%ebp)
   13d19:	e8 b6 ff ff ff       	call   13cd4 <is_devid_valid>
   13d1e:	83 c4 04             	add    $0x4,%esp
   13d21:	85 c0                	test   %eax,%eax
   13d23:	74 07                	je     13d2c <dev_read+0x1c>
    {
        return -1;
   13d25:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13d2a:	eb 2e                	jmp    13d5a <dev_read+0x4a>
    }
    device_t *dev = dev_table + dev_id;
   13d2c:	8b 55 08             	mov    0x8(%ebp),%edx
   13d2f:	89 d0                	mov    %edx,%eax
   13d31:	c1 e0 02             	shl    $0x2,%eax
   13d34:	01 d0                	add    %edx,%eax
   13d36:	c1 e0 02             	shl    $0x2,%eax
   13d39:	05 a0 59 03 00       	add    $0x359a0,%eax
   13d3e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return dev->desc->read(dev, addr, buf, size);
   13d41:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13d44:	8b 00                	mov    (%eax),%eax
   13d46:	8b 40 28             	mov    0x28(%eax),%eax
   13d49:	ff 75 14             	pushl  0x14(%ebp)
   13d4c:	ff 75 10             	pushl  0x10(%ebp)
   13d4f:	ff 75 0c             	pushl  0xc(%ebp)
   13d52:	ff 75 f4             	pushl  -0xc(%ebp)
   13d55:	ff d0                	call   *%eax
   13d57:	83 c4 10             	add    $0x10,%esp
}
   13d5a:	c9                   	leave  
   13d5b:	c3                   	ret    

00013d5c <dev_write>:
/**
 * @brief 写指定字节的数据
 */
int dev_write(int dev_id, int addr, char *buf, int size)
{
   13d5c:	55                   	push   %ebp
   13d5d:	89 e5                	mov    %esp,%ebp
   13d5f:	83 ec 18             	sub    $0x18,%esp
    if (is_devid_valid(dev_id))
   13d62:	ff 75 08             	pushl  0x8(%ebp)
   13d65:	e8 6a ff ff ff       	call   13cd4 <is_devid_valid>
   13d6a:	83 c4 04             	add    $0x4,%esp
   13d6d:	85 c0                	test   %eax,%eax
   13d6f:	74 07                	je     13d78 <dev_write+0x1c>
    {
        return -1;
   13d71:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13d76:	eb 2e                	jmp    13da6 <dev_write+0x4a>
    }
    device_t *dev = dev_table + dev_id;
   13d78:	8b 55 08             	mov    0x8(%ebp),%edx
   13d7b:	89 d0                	mov    %edx,%eax
   13d7d:	c1 e0 02             	shl    $0x2,%eax
   13d80:	01 d0                	add    %edx,%eax
   13d82:	c1 e0 02             	shl    $0x2,%eax
   13d85:	05 a0 59 03 00       	add    $0x359a0,%eax
   13d8a:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return dev->desc->write(dev, addr, buf, size);
   13d8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13d90:	8b 00                	mov    (%eax),%eax
   13d92:	8b 40 2c             	mov    0x2c(%eax),%eax
   13d95:	ff 75 14             	pushl  0x14(%ebp)
   13d98:	ff 75 10             	pushl  0x10(%ebp)
   13d9b:	ff 75 0c             	pushl  0xc(%ebp)
   13d9e:	ff 75 f4             	pushl  -0xc(%ebp)
   13da1:	ff d0                	call   *%eax
   13da3:	83 c4 10             	add    $0x10,%esp
}
   13da6:	c9                   	leave  
   13da7:	c3                   	ret    

00013da8 <dev_control>:

/**
 * @brief 发送控制命令
 */
int dev_control(int dev_id, int cmd, int arg0, int arg1)
{
   13da8:	55                   	push   %ebp
   13da9:	89 e5                	mov    %esp,%ebp
   13dab:	83 ec 18             	sub    $0x18,%esp
    if (is_devid_valid(dev_id))
   13dae:	ff 75 08             	pushl  0x8(%ebp)
   13db1:	e8 1e ff ff ff       	call   13cd4 <is_devid_valid>
   13db6:	83 c4 04             	add    $0x4,%esp
   13db9:	85 c0                	test   %eax,%eax
   13dbb:	74 07                	je     13dc4 <dev_control+0x1c>
    {
        return -1;
   13dbd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13dc2:	eb 2e                	jmp    13df2 <dev_control+0x4a>
    }
    device_t *dev = dev_table + dev_id;
   13dc4:	8b 55 08             	mov    0x8(%ebp),%edx
   13dc7:	89 d0                	mov    %edx,%eax
   13dc9:	c1 e0 02             	shl    $0x2,%eax
   13dcc:	01 d0                	add    %edx,%eax
   13dce:	c1 e0 02             	shl    $0x2,%eax
   13dd1:	05 a0 59 03 00       	add    $0x359a0,%eax
   13dd6:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return dev->desc->control(dev, cmd, arg0, arg1);
   13dd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13ddc:	8b 00                	mov    (%eax),%eax
   13dde:	8b 40 30             	mov    0x30(%eax),%eax
   13de1:	ff 75 14             	pushl  0x14(%ebp)
   13de4:	ff 75 10             	pushl  0x10(%ebp)
   13de7:	ff 75 0c             	pushl  0xc(%ebp)
   13dea:	ff 75 f4             	pushl  -0xc(%ebp)
   13ded:	ff d0                	call   *%eax
   13def:	83 c4 10             	add    $0x10,%esp
}
   13df2:	c9                   	leave  
   13df3:	c3                   	ret    

00013df4 <dev_close>:

/**
 * @brief 关闭设备
 */
void dev_close(int dev_id)
{
   13df4:	55                   	push   %ebp
   13df5:	89 e5                	mov    %esp,%ebp
   13df7:	83 ec 18             	sub    $0x18,%esp
    if (is_devid_valid(dev_id))
   13dfa:	ff 75 08             	pushl  0x8(%ebp)
   13dfd:	e8 d2 fe ff ff       	call   13cd4 <is_devid_valid>
   13e02:	83 c4 04             	add    $0x4,%esp
   13e05:	85 c0                	test   %eax,%eax
   13e07:	75 6c                	jne    13e75 <dev_close+0x81>
    {
        return;
    }
    device_t *dev = dev_table + dev_id;
   13e09:	8b 55 08             	mov    0x8(%ebp),%edx
   13e0c:	89 d0                	mov    %edx,%eax
   13e0e:	c1 e0 02             	shl    $0x2,%eax
   13e11:	01 d0                	add    %edx,%eax
   13e13:	c1 e0 02             	shl    $0x2,%eax
   13e16:	05 a0 59 03 00       	add    $0x359a0,%eax
   13e1b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int state = irq_enter_protection();
   13e1e:	e8 59 f1 ff ff       	call   12f7c <irq_enter_protection>
   13e23:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (--dev->open_count == 0)
   13e26:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13e29:	8b 40 10             	mov    0x10(%eax),%eax
   13e2c:	8d 50 ff             	lea    -0x1(%eax),%edx
   13e2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13e32:	89 50 10             	mov    %edx,0x10(%eax)
   13e35:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13e38:	8b 40 10             	mov    0x10(%eax),%eax
   13e3b:	85 c0                	test   %eax,%eax
   13e3d:	75 25                	jne    13e64 <dev_close+0x70>
    {
        dev->desc->close(dev);
   13e3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13e42:	8b 00                	mov    (%eax),%eax
   13e44:	8b 40 34             	mov    0x34(%eax),%eax
   13e47:	83 ec 0c             	sub    $0xc,%esp
   13e4a:	ff 75 f4             	pushl  -0xc(%ebp)
   13e4d:	ff d0                	call   *%eax
   13e4f:	83 c4 10             	add    $0x10,%esp
        kernel_memset((void *)dev, 0, sizeof(device_t));
   13e52:	83 ec 04             	sub    $0x4,%esp
   13e55:	6a 14                	push   $0x14
   13e57:	6a 00                	push   $0x0
   13e59:	ff 75 f4             	pushl  -0xc(%ebp)
   13e5c:	e8 c2 2b 00 00       	call   16a23 <kernel_memset>
   13e61:	83 c4 10             	add    $0x10,%esp
    }
    irq_leave_protection(state);
   13e64:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13e67:	83 ec 0c             	sub    $0xc,%esp
   13e6a:	50                   	push   %eax
   13e6b:	e8 24 f1 ff ff       	call   12f94 <irq_leave_protection>
   13e70:	83 c4 10             	add    $0x10,%esp
   13e73:	eb 01                	jmp    13e76 <dev_close+0x82>
        return;
   13e75:	90                   	nop
   13e76:	c9                   	leave  
   13e77:	c3                   	ret    

00013e78 <list_node_prev>:
{
   13e78:	55                   	push   %ebp
   13e79:	89 e5                	mov    %esp,%ebp
    return node->prev;
   13e7b:	8b 45 08             	mov    0x8(%ebp),%eax
   13e7e:	8b 40 04             	mov    0x4(%eax),%eax
}
   13e81:	5d                   	pop    %ebp
   13e82:	c3                   	ret    

00013e83 <list_node_next>:
{
   13e83:	55                   	push   %ebp
   13e84:	89 e5                	mov    %esp,%ebp
    return node->next;
   13e86:	8b 45 08             	mov    0x8(%ebp),%eax
   13e89:	8b 00                	mov    (%eax),%eax
}
   13e8b:	5d                   	pop    %ebp
   13e8c:	c3                   	ret    

00013e8d <inb>:
{
   13e8d:	55                   	push   %ebp
   13e8e:	89 e5                	mov    %esp,%ebp
   13e90:	83 ec 14             	sub    $0x14,%esp
   13e93:	8b 45 08             	mov    0x8(%ebp),%eax
   13e96:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]" : [v] "=a"(rv) : [p] "d"(port));
   13e9a:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   13e9e:	89 c2                	mov    %eax,%edx
   13ea0:	ec                   	in     (%dx),%al
   13ea1:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   13ea4:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   13ea8:	c9                   	leave  
   13ea9:	c3                   	ret    

00013eaa <inw>:
{
   13eaa:	55                   	push   %ebp
   13eab:	89 e5                	mov    %esp,%ebp
   13ead:	83 ec 14             	sub    $0x14,%esp
   13eb0:	8b 45 08             	mov    0x8(%ebp),%eax
   13eb3:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("in %1, %0" : "=a"(rv) : "dN"(port));
   13eb7:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   13ebb:	89 c2                	mov    %eax,%edx
   13ebd:	66 ed                	in     (%dx),%ax
   13ebf:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    return rv;
   13ec3:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   13ec7:	c9                   	leave  
   13ec8:	c3                   	ret    

00013ec9 <outb>:
{
   13ec9:	55                   	push   %ebp
   13eca:	89 e5                	mov    %esp,%ebp
   13ecc:	83 ec 08             	sub    $0x8,%esp
   13ecf:	8b 55 08             	mov    0x8(%ebp),%edx
   13ed2:	8b 45 0c             	mov    0xc(%ebp),%eax
   13ed5:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   13ed9:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]" : : [p] "d"(port), [v] "a"(data));
   13edc:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   13ee0:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   13ee4:	ee                   	out    %al,(%dx)
}
   13ee5:	90                   	nop
   13ee6:	c9                   	leave  
   13ee7:	c3                   	ret    

00013ee8 <outw>:
{
    __asm__ __volatile__("mov %[v], %%cr2" ::[v] "r"(v));
}

static inline void outw(uint16_t port, uint16_t data)
{
   13ee8:	55                   	push   %ebp
   13ee9:	89 e5                	mov    %esp,%ebp
   13eeb:	83 ec 08             	sub    $0x8,%esp
   13eee:	8b 55 08             	mov    0x8(%ebp),%edx
   13ef1:	8b 45 0c             	mov    0xc(%ebp),%eax
   13ef4:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   13ef8:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    __asm__ __volatile__("out %[v], %[p]" : : [p] "d"(port), [v] "a"(data));
   13efc:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   13f00:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
   13f04:	66 ef                	out    %ax,(%dx)
}
   13f06:	90                   	nop
   13f07:	c9                   	leave  
   13f08:	c3                   	ret    

00013f09 <disk_send_cmd>:
static int task_on_op;
/**
 * @brief 发送命令
 */
static void disk_send_cmd(disk_t *disk, uint32_t start_sector, uint32_t sector_count, int cmd)
{
   13f09:	55                   	push   %ebp
   13f0a:	89 e5                	mov    %esp,%ebp
    outb(DISK_DRIVE(disk), DISK_DRIVE_BASE | disk->drive);
   13f0c:	8b 45 08             	mov    0x8(%ebp),%eax
   13f0f:	8b 40 20             	mov    0x20(%eax),%eax
   13f12:	83 c8 e0             	or     $0xffffffe0,%eax
   13f15:	0f b6 d0             	movzbl %al,%edx
   13f18:	8b 45 08             	mov    0x8(%ebp),%eax
   13f1b:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   13f1f:	83 c0 06             	add    $0x6,%eax
   13f22:	0f b7 c0             	movzwl %ax,%eax
   13f25:	52                   	push   %edx
   13f26:	50                   	push   %eax
   13f27:	e8 9d ff ff ff       	call   13ec9 <outb>
   13f2c:	83 c4 08             	add    $0x8,%esp
    // 必须先写高字节
    outb(DISK_SECTOR_COUNT(disk), (uint8_t)(sector_count >> 8)); // 扇区数高8位
   13f2f:	8b 45 10             	mov    0x10(%ebp),%eax
   13f32:	c1 e8 08             	shr    $0x8,%eax
   13f35:	0f b6 d0             	movzbl %al,%edx
   13f38:	8b 45 08             	mov    0x8(%ebp),%eax
   13f3b:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   13f3f:	83 c0 02             	add    $0x2,%eax
   13f42:	0f b7 c0             	movzwl %ax,%eax
   13f45:	52                   	push   %edx
   13f46:	50                   	push   %eax
   13f47:	e8 7d ff ff ff       	call   13ec9 <outb>
   13f4c:	83 c4 08             	add    $0x8,%esp
    outb(DISK_LBA_LOW(disk), (uint8_t)(start_sector >> 24));     // LBA参数的24~31位
   13f4f:	8b 45 0c             	mov    0xc(%ebp),%eax
   13f52:	c1 e8 18             	shr    $0x18,%eax
   13f55:	0f b6 d0             	movzbl %al,%edx
   13f58:	8b 45 08             	mov    0x8(%ebp),%eax
   13f5b:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   13f5f:	83 c0 03             	add    $0x3,%eax
   13f62:	0f b7 c0             	movzwl %ax,%eax
   13f65:	52                   	push   %edx
   13f66:	50                   	push   %eax
   13f67:	e8 5d ff ff ff       	call   13ec9 <outb>
   13f6c:	83 c4 08             	add    $0x8,%esp
    outb(DISK_LBA_MID(disk), 0);                                 // 高于32位不支持
   13f6f:	8b 45 08             	mov    0x8(%ebp),%eax
   13f72:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   13f76:	83 c0 04             	add    $0x4,%eax
   13f79:	0f b7 c0             	movzwl %ax,%eax
   13f7c:	6a 00                	push   $0x0
   13f7e:	50                   	push   %eax
   13f7f:	e8 45 ff ff ff       	call   13ec9 <outb>
   13f84:	83 c4 08             	add    $0x8,%esp
    outb(DISK_LBA_HIGH(disk), 0);                                // 高于32位不支持
   13f87:	8b 45 08             	mov    0x8(%ebp),%eax
   13f8a:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   13f8e:	83 c0 05             	add    $0x5,%eax
   13f91:	0f b7 c0             	movzwl %ax,%eax
   13f94:	6a 00                	push   $0x0
   13f96:	50                   	push   %eax
   13f97:	e8 2d ff ff ff       	call   13ec9 <outb>
   13f9c:	83 c4 08             	add    $0x8,%esp
    outb(DISK_SECTOR_COUNT(disk), (uint8_t)(sector_count));      // 扇区数量低8位
   13f9f:	8b 45 10             	mov    0x10(%ebp),%eax
   13fa2:	0f b6 d0             	movzbl %al,%edx
   13fa5:	8b 45 08             	mov    0x8(%ebp),%eax
   13fa8:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   13fac:	83 c0 02             	add    $0x2,%eax
   13faf:	0f b7 c0             	movzwl %ax,%eax
   13fb2:	52                   	push   %edx
   13fb3:	50                   	push   %eax
   13fb4:	e8 10 ff ff ff       	call   13ec9 <outb>
   13fb9:	83 c4 08             	add    $0x8,%esp
    outb(DISK_LBA_LOW(disk), (uint8_t)(start_sector >> 0));      // LBA参数的0-7
   13fbc:	8b 45 0c             	mov    0xc(%ebp),%eax
   13fbf:	0f b6 d0             	movzbl %al,%edx
   13fc2:	8b 45 08             	mov    0x8(%ebp),%eax
   13fc5:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   13fc9:	83 c0 03             	add    $0x3,%eax
   13fcc:	0f b7 c0             	movzwl %ax,%eax
   13fcf:	52                   	push   %edx
   13fd0:	50                   	push   %eax
   13fd1:	e8 f3 fe ff ff       	call   13ec9 <outb>
   13fd6:	83 c4 08             	add    $0x8,%esp
    outb(DISK_LBA_MID(disk), (uint8_t)(start_sector >> 8));      // LBA参数的8-15位
   13fd9:	8b 45 0c             	mov    0xc(%ebp),%eax
   13fdc:	c1 e8 08             	shr    $0x8,%eax
   13fdf:	0f b6 d0             	movzbl %al,%edx
   13fe2:	8b 45 08             	mov    0x8(%ebp),%eax
   13fe5:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   13fe9:	83 c0 04             	add    $0x4,%eax
   13fec:	0f b7 c0             	movzwl %ax,%eax
   13fef:	52                   	push   %edx
   13ff0:	50                   	push   %eax
   13ff1:	e8 d3 fe ff ff       	call   13ec9 <outb>
   13ff6:	83 c4 08             	add    $0x8,%esp
    outb(DISK_LBA_HIGH(disk), (uint8_t)(start_sector >> 16));    // LBA参数的16-23位
   13ff9:	8b 45 0c             	mov    0xc(%ebp),%eax
   13ffc:	c1 e8 10             	shr    $0x10,%eax
   13fff:	0f b6 d0             	movzbl %al,%edx
   14002:	8b 45 08             	mov    0x8(%ebp),%eax
   14005:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   14009:	83 c0 05             	add    $0x5,%eax
   1400c:	0f b7 c0             	movzwl %ax,%eax
   1400f:	52                   	push   %edx
   14010:	50                   	push   %eax
   14011:	e8 b3 fe ff ff       	call   13ec9 <outb>
   14016:	83 c4 08             	add    $0x8,%esp

    // 选择对应的主-从磁盘
    outb(DISK_CMD(disk), (uint8_t)cmd);
   14019:	8b 45 14             	mov    0x14(%ebp),%eax
   1401c:	0f b6 d0             	movzbl %al,%edx
   1401f:	8b 45 08             	mov    0x8(%ebp),%eax
   14022:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   14026:	83 c0 07             	add    $0x7,%eax
   14029:	0f b7 c0             	movzwl %ax,%eax
   1402c:	52                   	push   %edx
   1402d:	50                   	push   %eax
   1402e:	e8 96 fe ff ff       	call   13ec9 <outb>
   14033:	83 c4 08             	add    $0x8,%esp
}
   14036:	90                   	nop
   14037:	c9                   	leave  
   14038:	c3                   	ret    

00014039 <disk_read_data>:

/**
 * @brief 读取数据
 */
static void disk_read_data(disk_t *disk, void *buff, int count)
{
   14039:	55                   	push   %ebp
   1403a:	89 e5                	mov    %esp,%ebp
   1403c:	53                   	push   %ebx
   1403d:	83 ec 10             	sub    $0x10,%esp
    uint16_t *c = (uint16_t *)buff;
   14040:	8b 45 0c             	mov    0xc(%ebp),%eax
   14043:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int i = 0; i < count / 2; i++)
   14046:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1404d:	eb 23                	jmp    14072 <disk_read_data+0x39>
    {
        *c++ = inw(DISK_DATA(disk));
   1404f:	8b 45 08             	mov    0x8(%ebp),%eax
   14052:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   14056:	0f b7 c0             	movzwl %ax,%eax
   14059:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   1405c:	8d 53 02             	lea    0x2(%ebx),%edx
   1405f:	89 55 f8             	mov    %edx,-0x8(%ebp)
   14062:	50                   	push   %eax
   14063:	e8 42 fe ff ff       	call   13eaa <inw>
   14068:	83 c4 04             	add    $0x4,%esp
   1406b:	66 89 03             	mov    %ax,(%ebx)
    for (int i = 0; i < count / 2; i++)
   1406e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14072:	8b 45 10             	mov    0x10(%ebp),%eax
   14075:	89 c2                	mov    %eax,%edx
   14077:	c1 ea 1f             	shr    $0x1f,%edx
   1407a:	01 d0                	add    %edx,%eax
   1407c:	d1 f8                	sar    %eax
   1407e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   14081:	7c cc                	jl     1404f <disk_read_data+0x16>
    }
}
   14083:	90                   	nop
   14084:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14087:	c9                   	leave  
   14088:	c3                   	ret    

00014089 <disk_write_data>:

/**
 * @brief 写入数据
 */
static void disk_write_data(disk_t *disk, void *buff, int count)
{
   14089:	55                   	push   %ebp
   1408a:	89 e5                	mov    %esp,%ebp
   1408c:	83 ec 10             	sub    $0x10,%esp
    uint16_t *c = (uint16_t *)buff;
   1408f:	8b 45 0c             	mov    0xc(%ebp),%eax
   14092:	89 45 fc             	mov    %eax,-0x4(%ebp)
    for (int i = 0; i < count / 2; i++)
   14095:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1409c:	eb 27                	jmp    140c5 <disk_write_data+0x3c>
    {
        outw(DISK_DATA(disk), *c++);
   1409e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   140a1:	8d 50 02             	lea    0x2(%eax),%edx
   140a4:	89 55 fc             	mov    %edx,-0x4(%ebp)
   140a7:	0f b7 00             	movzwl (%eax),%eax
   140aa:	0f b7 d0             	movzwl %ax,%edx
   140ad:	8b 45 08             	mov    0x8(%ebp),%eax
   140b0:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   140b4:	0f b7 c0             	movzwl %ax,%eax
   140b7:	52                   	push   %edx
   140b8:	50                   	push   %eax
   140b9:	e8 2a fe ff ff       	call   13ee8 <outw>
   140be:	83 c4 08             	add    $0x8,%esp
    for (int i = 0; i < count / 2; i++)
   140c1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   140c5:	8b 45 10             	mov    0x10(%ebp),%eax
   140c8:	89 c2                	mov    %eax,%edx
   140ca:	c1 ea 1f             	shr    $0x1f,%edx
   140cd:	01 d0                	add    %edx,%eax
   140cf:	d1 f8                	sar    %eax
   140d1:	39 45 f8             	cmp    %eax,-0x8(%ebp)
   140d4:	7c c8                	jl     1409e <disk_write_data+0x15>
    }
}
   140d6:	90                   	nop
   140d7:	c9                   	leave  
   140d8:	c3                   	ret    

000140d9 <disk_wait_data>:

/**
 * @brief 等待磁盘准备好数据
 */
static int disk_wait_data(disk_t *disk)
{
   140d9:	55                   	push   %ebp
   140da:	89 e5                	mov    %esp,%ebp
   140dc:	83 ec 10             	sub    $0x10,%esp
    uint8_t status;
    do
    {
        // 等待数据或者有错误
        status = inb(DISK_STATUS(disk));
   140df:	8b 45 08             	mov    0x8(%ebp),%eax
   140e2:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   140e6:	83 c0 07             	add    $0x7,%eax
   140e9:	0f b7 c0             	movzwl %ax,%eax
   140ec:	50                   	push   %eax
   140ed:	e8 9b fd ff ff       	call   13e8d <inb>
   140f2:	83 c4 04             	add    $0x4,%esp
   140f5:	88 45 ff             	mov    %al,-0x1(%ebp)
        if ((status & (DISK_STATUS_BUSY | DISK_STATUS_DRQ | DISK_STATUS_ERR)) != DISK_STATUS_BUSY)
   140f8:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
   140fc:	25 89 00 00 00       	and    $0x89,%eax
   14101:	3d 80 00 00 00       	cmp    $0x80,%eax
   14106:	75 02                	jne    1410a <disk_wait_data+0x31>
        status = inb(DISK_STATUS(disk));
   14108:	eb d5                	jmp    140df <disk_wait_data+0x6>
        {
            break;
   1410a:	90                   	nop
        }
    } while (1);

    // 检查是否有错误
    return (status & DISK_STATUS_ERR) ? -1 : 0;
   1410b:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
   1410f:	83 e0 01             	and    $0x1,%eax
   14112:	85 c0                	test   %eax,%eax
   14114:	74 07                	je     1411d <disk_wait_data+0x44>
   14116:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1411b:	eb 05                	jmp    14122 <disk_wait_data+0x49>
   1411d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14122:	c9                   	leave  
   14123:	c3                   	ret    

00014124 <print_info_disk>:

/**
 * @brief 打印磁盘信息
 */
static void print_info_disk(disk_t *disk)
{
   14124:	55                   	push   %ebp
   14125:	89 e5                	mov    %esp,%ebp
   14127:	53                   	push   %ebx
   14128:	83 ec 14             	sub    $0x14,%esp
    log_printf("%s:", disk->name);
   1412b:	8b 45 08             	mov    0x8(%ebp),%eax
   1412e:	83 ec 08             	sub    $0x8,%esp
   14131:	50                   	push   %eax
   14132:	68 a0 7b 01 00       	push   $0x17ba0
   14137:	e8 c3 2e 00 00       	call   16fff <log_printf>
   1413c:	83 c4 10             	add    $0x10,%esp
    log_printf("  port_base: %x", disk->port_base);
   1413f:	8b 45 08             	mov    0x8(%ebp),%eax
   14142:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   14146:	0f b7 c0             	movzwl %ax,%eax
   14149:	83 ec 08             	sub    $0x8,%esp
   1414c:	50                   	push   %eax
   1414d:	68 a4 7b 01 00       	push   $0x17ba4
   14152:	e8 a8 2e 00 00       	call   16fff <log_printf>
   14157:	83 c4 10             	add    $0x10,%esp
    log_printf("  total_size: %d m", disk->sector_count * disk->sector_size / 1024 / 1024);
   1415a:	8b 45 08             	mov    0x8(%ebp),%eax
   1415d:	8b 50 2a             	mov    0x2a(%eax),%edx
   14160:	8b 45 08             	mov    0x8(%ebp),%eax
   14163:	8b 40 26             	mov    0x26(%eax),%eax
   14166:	0f af c2             	imul   %edx,%eax
   14169:	8d 90 ff ff 0f 00    	lea    0xfffff(%eax),%edx
   1416f:	85 c0                	test   %eax,%eax
   14171:	0f 48 c2             	cmovs  %edx,%eax
   14174:	c1 f8 14             	sar    $0x14,%eax
   14177:	83 ec 08             	sub    $0x8,%esp
   1417a:	50                   	push   %eax
   1417b:	68 b4 7b 01 00       	push   $0x17bb4
   14180:	e8 7a 2e 00 00       	call   16fff <log_printf>
   14185:	83 c4 10             	add    $0x10,%esp
    log_printf("  drive: %s", disk->drive == DISK_MASTER ? "Master" : "Slave");
   14188:	8b 45 08             	mov    0x8(%ebp),%eax
   1418b:	8b 40 20             	mov    0x20(%eax),%eax
   1418e:	85 c0                	test   %eax,%eax
   14190:	75 07                	jne    14199 <print_info_disk+0x75>
   14192:	b8 c7 7b 01 00       	mov    $0x17bc7,%eax
   14197:	eb 05                	jmp    1419e <print_info_disk+0x7a>
   14199:	b8 ce 7b 01 00       	mov    $0x17bce,%eax
   1419e:	83 ec 08             	sub    $0x8,%esp
   141a1:	50                   	push   %eax
   141a2:	68 d4 7b 01 00       	push   $0x17bd4
   141a7:	e8 53 2e 00 00       	call   16fff <log_printf>
   141ac:	83 c4 10             	add    $0x10,%esp

    // 显示分区信息
    log_printf("  Part info:");
   141af:	83 ec 0c             	sub    $0xc,%esp
   141b2:	68 e0 7b 01 00       	push   $0x17be0
   141b7:	e8 43 2e 00 00       	call   16fff <log_printf>
   141bc:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < DISK_PRIMARY_PART_CNT; i++)
   141bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   141c6:	eb 4e                	jmp    14216 <print_info_disk+0xf2>
    {
        partinfo_t *part_info = disk->partinfo + i;
   141c8:	8b 45 08             	mov    0x8(%ebp),%eax
   141cb:	8d 48 2e             	lea    0x2e(%eax),%ecx
   141ce:	8b 55 f4             	mov    -0xc(%ebp),%edx
   141d1:	89 d0                	mov    %edx,%eax
   141d3:	01 c0                	add    %eax,%eax
   141d5:	01 d0                	add    %edx,%eax
   141d7:	c1 e0 04             	shl    $0x4,%eax
   141da:	01 c8                	add    %ecx,%eax
   141dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (part_info->type != FS_INVALID)
   141df:	8b 45 f0             	mov    -0x10(%ebp),%eax
   141e2:	8b 40 24             	mov    0x24(%eax),%eax
   141e5:	85 c0                	test   %eax,%eax
   141e7:	74 29                	je     14212 <print_info_disk+0xee>
        {
            log_printf("    %s: type: %x, start sector: %d, count %d",
   141e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   141ec:	8b 58 2c             	mov    0x2c(%eax),%ebx
   141ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
   141f2:	8b 48 28             	mov    0x28(%eax),%ecx
                       part_info->name, part_info->type,
   141f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   141f8:	8b 50 24             	mov    0x24(%eax),%edx
   141fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
            log_printf("    %s: type: %x, start sector: %d, count %d",
   141fe:	83 ec 0c             	sub    $0xc,%esp
   14201:	53                   	push   %ebx
   14202:	51                   	push   %ecx
   14203:	52                   	push   %edx
   14204:	50                   	push   %eax
   14205:	68 f0 7b 01 00       	push   $0x17bf0
   1420a:	e8 f0 2d 00 00       	call   16fff <log_printf>
   1420f:	83 c4 20             	add    $0x20,%esp
    for (int i = 0; i < DISK_PRIMARY_PART_CNT; i++)
   14212:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14216:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
   1421a:	7e ac                	jle    141c8 <print_info_disk+0xa4>
                       part_info->start_sector, part_info->total_sector);
        }
    }
}
   1421c:	90                   	nop
   1421d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14220:	c9                   	leave  
   14221:	c3                   	ret    

00014222 <detect_part_info>:
/**
 * @brief 识别分区信息
 * @param disk 磁盘
 */
static int detect_part_info(disk_t *disk)
{
   14222:	55                   	push   %ebp
   14223:	89 e5                	mov    %esp,%ebp
   14225:	81 ec 18 02 00 00    	sub    $0x218,%esp
    mbr_t mbr;
    disk_send_cmd(disk, 0, 1, DISK_CMD_READ);
   1422b:	6a 24                	push   $0x24
   1422d:	6a 01                	push   $0x1
   1422f:	6a 00                	push   $0x0
   14231:	ff 75 08             	pushl  0x8(%ebp)
   14234:	e8 d0 fc ff ff       	call   13f09 <disk_send_cmd>
   14239:	83 c4 10             	add    $0x10,%esp
    int err = disk_wait_data(disk);
   1423c:	ff 75 08             	pushl  0x8(%ebp)
   1423f:	e8 95 fe ff ff       	call   140d9 <disk_wait_data>
   14244:	83 c4 04             	add    $0x4,%esp
   14247:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (err < 0)
   1424a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1424e:	79 1e                	jns    1426e <detect_part_info+0x4c>
    {
        log_printf("disk[%s] wait data error", disk->name);
   14250:	8b 45 08             	mov    0x8(%ebp),%eax
   14253:	83 ec 08             	sub    $0x8,%esp
   14256:	50                   	push   %eax
   14257:	68 1d 7c 01 00       	push   $0x17c1d
   1425c:	e8 9e 2d 00 00       	call   16fff <log_printf>
   14261:	83 c4 10             	add    $0x10,%esp
        return -1;
   14264:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14269:	e9 d1 00 00 00       	jmp    1433f <detect_part_info+0x11d>
    }
    disk_read_data(disk, &mbr, sizeof(mbr));
   1426e:	83 ec 04             	sub    $0x4,%esp
   14271:	68 00 02 00 00       	push   $0x200
   14276:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
   1427c:	50                   	push   %eax
   1427d:	ff 75 08             	pushl  0x8(%ebp)
   14280:	e8 b4 fd ff ff       	call   14039 <disk_read_data>
   14285:	83 c4 10             	add    $0x10,%esp
    part_item_t *item = mbr.part_item;
   14288:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
   1428e:	05 be 01 00 00       	add    $0x1be,%eax
   14293:	89 45 f4             	mov    %eax,-0xc(%ebp)
    partinfo_t *part_info = disk->partinfo + 1;
   14296:	8b 45 08             	mov    0x8(%ebp),%eax
   14299:	83 c0 2e             	add    $0x2e,%eax
   1429c:	83 c0 30             	add    $0x30,%eax
   1429f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (int i = 0; i < MBR_PRIMARY_PART_NR; i++, item++, part_info++)
   142a2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   142a9:	e9 87 00 00 00       	jmp    14335 <detect_part_info+0x113>
    {
        part_info->type = item->system_id;
   142ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
   142b1:	0f b6 40 04          	movzbl 0x4(%eax),%eax
   142b5:	0f b6 d0             	movzbl %al,%edx
   142b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   142bb:	89 50 24             	mov    %edx,0x24(%eax)
        if (part_info->type == FS_INVALID)
   142be:	8b 45 f0             	mov    -0x10(%ebp),%eax
   142c1:	8b 40 24             	mov    0x24(%eax),%eax
   142c4:	85 c0                	test   %eax,%eax
   142c6:	75 20                	jne    142e8 <detect_part_info+0xc6>
        {
            part_info->total_sector = 0;
   142c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   142cb:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
            part_info->start_sector = 0;
   142d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   142d5:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
            part_info->disk = (disk_t *)0;
   142dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   142df:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
   142e6:	eb 41                	jmp    14329 <detect_part_info+0x107>
        }
        else
        {
            kernel_sprintf(part_info->name, "%s%d", disk->name, i + 1);
   142e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   142eb:	8d 48 01             	lea    0x1(%eax),%ecx
   142ee:	8b 55 08             	mov    0x8(%ebp),%edx
   142f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   142f4:	51                   	push   %ecx
   142f5:	52                   	push   %edx
   142f6:	68 36 7c 01 00       	push   $0x17c36
   142fb:	50                   	push   %eax
   142fc:	e8 c3 27 00 00       	call   16ac4 <kernel_sprintf>
   14301:	83 c4 10             	add    $0x10,%esp
            part_info->start_sector = item->relative_sectors;
   14304:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14307:	8b 40 08             	mov    0x8(%eax),%eax
   1430a:	89 c2                	mov    %eax,%edx
   1430c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1430f:	89 50 28             	mov    %edx,0x28(%eax)
            part_info->total_sector = item->total_sectors;
   14312:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14315:	8b 40 0c             	mov    0xc(%eax),%eax
   14318:	89 c2                	mov    %eax,%edx
   1431a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1431d:	89 50 2c             	mov    %edx,0x2c(%eax)
            part_info->disk = disk;
   14320:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14323:	8b 55 08             	mov    0x8(%ebp),%edx
   14326:	89 50 20             	mov    %edx,0x20(%eax)
    for (int i = 0; i < MBR_PRIMARY_PART_NR; i++, item++, part_info++)
   14329:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1432d:	83 45 f4 10          	addl   $0x10,-0xc(%ebp)
   14331:	83 45 f0 30          	addl   $0x30,-0x10(%ebp)
   14335:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
   14339:	0f 8e 6f ff ff ff    	jle    142ae <detect_part_info+0x8c>
        }
    }
}
   1433f:	c9                   	leave  
   14340:	c3                   	ret    

00014341 <identify_disk>:
/**
 * @brief 识别磁盘
 */
static int
identify_disk(disk_t *disk)
{
   14341:	55                   	push   %ebp
   14342:	89 e5                	mov    %esp,%ebp
   14344:	81 ec 18 02 00 00    	sub    $0x218,%esp
    // 发送识别磁盘命令
    disk_send_cmd(disk, 0, 0, DISK_CMD_IDENTIFY);
   1434a:	68 ec 00 00 00       	push   $0xec
   1434f:	6a 00                	push   $0x0
   14351:	6a 00                	push   $0x0
   14353:	ff 75 08             	pushl  0x8(%ebp)
   14356:	e8 ae fb ff ff       	call   13f09 <disk_send_cmd>
   1435b:	83 c4 10             	add    $0x10,%esp

    int err = inb(DISK_STATUS(disk));
   1435e:	8b 45 08             	mov    0x8(%ebp),%eax
   14361:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   14365:	83 c0 07             	add    $0x7,%eax
   14368:	0f b7 c0             	movzwl %ax,%eax
   1436b:	50                   	push   %eax
   1436c:	e8 1c fb ff ff       	call   13e8d <inb>
   14371:	83 c4 04             	add    $0x4,%esp
   14374:	0f b6 c0             	movzbl %al,%eax
   14377:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (err == 0)
   1437a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1437e:	75 1e                	jne    1439e <identify_disk+0x5d>
    {
        log_printf("%s disk not found", disk->name);
   14380:	8b 45 08             	mov    0x8(%ebp),%eax
   14383:	83 ec 08             	sub    $0x8,%esp
   14386:	50                   	push   %eax
   14387:	68 3b 7c 01 00       	push   $0x17c3b
   1438c:	e8 6e 2c 00 00       	call   16fff <log_printf>
   14391:	83 c4 10             	add    $0x10,%esp
        return -1;
   14394:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14399:	e9 c8 00 00 00       	jmp    14466 <identify_disk+0x125>
    }

    // 等待磁盘准备好数据
    err = disk_wait_data(disk);
   1439e:	83 ec 0c             	sub    $0xc,%esp
   143a1:	ff 75 08             	pushl  0x8(%ebp)
   143a4:	e8 30 fd ff ff       	call   140d9 <disk_wait_data>
   143a9:	83 c4 10             	add    $0x10,%esp
   143ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (err < 0)
   143af:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   143b3:	79 1c                	jns    143d1 <identify_disk+0x90>
    {
        log_printf("disk[%s] wait data error", disk->name);
   143b5:	8b 45 08             	mov    0x8(%ebp),%eax
   143b8:	83 ec 08             	sub    $0x8,%esp
   143bb:	50                   	push   %eax
   143bc:	68 1d 7c 01 00       	push   $0x17c1d
   143c1:	e8 39 2c 00 00       	call   16fff <log_printf>
   143c6:	83 c4 10             	add    $0x10,%esp
        return err;
   143c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143cc:	e9 95 00 00 00       	jmp    14466 <identify_disk+0x125>
    }

    uint16_t buf[256];
    // 读取数据
    disk_read_data(disk, buf, sizeof(buf));
   143d1:	83 ec 04             	sub    $0x4,%esp
   143d4:	68 00 02 00 00       	push   $0x200
   143d9:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
   143df:	50                   	push   %eax
   143e0:	ff 75 08             	pushl  0x8(%ebp)
   143e3:	e8 51 fc ff ff       	call   14039 <disk_read_data>
   143e8:	83 c4 10             	add    $0x10,%esp
    disk->sector_count = *((uint32_t *)(buf + 100));
   143eb:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
   143f1:	05 c8 00 00 00       	add    $0xc8,%eax
   143f6:	8b 00                	mov    (%eax),%eax
   143f8:	89 c2                	mov    %eax,%edx
   143fa:	8b 45 08             	mov    0x8(%ebp),%eax
   143fd:	89 50 2a             	mov    %edx,0x2a(%eax)
    disk->sector_size = SECTOR_SIZE;
   14400:	8b 45 08             	mov    0x8(%ebp),%eax
   14403:	c7 40 26 00 02 00 00 	movl   $0x200,0x26(%eax)

    partinfo_t *part_info = disk->partinfo + 0;
   1440a:	8b 45 08             	mov    0x8(%ebp),%eax
   1440d:	83 c0 2e             	add    $0x2e,%eax
   14410:	89 45 f0             	mov    %eax,-0x10(%ebp)
    part_info->disk = disk;
   14413:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14416:	8b 55 08             	mov    0x8(%ebp),%edx
   14419:	89 50 20             	mov    %edx,0x20(%eax)
    kernel_sprintf(part_info->name, "%s%d", disk->name, 0);
   1441c:	8b 55 08             	mov    0x8(%ebp),%edx
   1441f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14422:	6a 00                	push   $0x0
   14424:	52                   	push   %edx
   14425:	68 36 7c 01 00       	push   $0x17c36
   1442a:	50                   	push   %eax
   1442b:	e8 94 26 00 00       	call   16ac4 <kernel_sprintf>
   14430:	83 c4 10             	add    $0x10,%esp
    part_info->start_sector = 0;
   14433:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14436:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
    part_info->total_sector = disk->sector_count;
   1443d:	8b 45 08             	mov    0x8(%ebp),%eax
   14440:	8b 50 2a             	mov    0x2a(%eax),%edx
   14443:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14446:	89 50 2c             	mov    %edx,0x2c(%eax)
    part_info->type = FS_INVALID;
   14449:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1444c:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)

    detect_part_info(disk);
   14453:	83 ec 0c             	sub    $0xc,%esp
   14456:	ff 75 08             	pushl  0x8(%ebp)
   14459:	e8 c4 fd ff ff       	call   14222 <detect_part_info>
   1445e:	83 c4 10             	add    $0x10,%esp
    return 0;
   14461:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14466:	c9                   	leave  
   14467:	c3                   	ret    

00014468 <disk_init>:

void disk_init(void)
{
   14468:	55                   	push   %ebp
   14469:	89 e5                	mov    %esp,%ebp
   1446b:	83 ec 18             	sub    $0x18,%esp
    log_printf("disk check");
   1446e:	83 ec 0c             	sub    $0xc,%esp
   14471:	68 4d 7c 01 00       	push   $0x17c4d
   14476:	e8 84 2b 00 00       	call   16fff <log_printf>
   1447b:	83 c4 10             	add    $0x10,%esp

    kernel_memset((void *)disk_buff, 0, sizeof(disk_buff));
   1447e:	83 ec 04             	sub    $0x4,%esp
   14481:	68 4c 02 00 00       	push   $0x24c
   14486:	6a 00                	push   $0x0
   14488:	68 a0 63 03 00       	push   $0x363a0
   1448d:	e8 91 25 00 00       	call   16a23 <kernel_memset>
   14492:	83 c4 10             	add    $0x10,%esp
    mutex_init(&mutex);
   14495:	83 ec 0c             	sub    $0xc,%esp
   14498:	68 ec 65 03 00       	push   $0x365ec
   1449d:	e8 a3 1e 00 00       	call   16345 <mutex_init>
   144a2:	83 c4 10             	add    $0x10,%esp
    sem_init(&op_sem, 0);
   144a5:	83 ec 08             	sub    $0x8,%esp
   144a8:	6a 00                	push   $0x0
   144aa:	68 00 66 03 00       	push   $0x36600
   144af:	e8 35 20 00 00       	call   164e9 <sem_init>
   144b4:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < DISK_PER_CHANNEL; i++)
   144b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   144be:	e9 90 00 00 00       	jmp    14553 <disk_init+0xeb>
    {
        disk_t *disk = disk_buff + i;
   144c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144c6:	69 c0 26 01 00 00    	imul   $0x126,%eax,%eax
   144cc:	05 a0 63 03 00       	add    $0x363a0,%eax
   144d1:	89 45 f0             	mov    %eax,-0x10(%ebp)

        // sd开头
        kernel_sprintf(disk->name, "sd%c", i + 'a');
   144d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144d7:	8d 50 61             	lea    0x61(%eax),%edx
   144da:	8b 45 f0             	mov    -0x10(%ebp),%eax
   144dd:	83 ec 04             	sub    $0x4,%esp
   144e0:	52                   	push   %edx
   144e1:	68 58 7c 01 00       	push   $0x17c58
   144e6:	50                   	push   %eax
   144e7:	e8 d8 25 00 00       	call   16ac4 <kernel_sprintf>
   144ec:	83 c4 10             	add    $0x10,%esp

        disk->drive = (i == 0) ? DISK_MASTER : DISK_SLAVE;
   144ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   144f3:	75 07                	jne    144fc <disk_init+0x94>
   144f5:	ba 00 00 00 00       	mov    $0x0,%edx
   144fa:	eb 05                	jmp    14501 <disk_init+0x99>
   144fc:	ba 10 00 00 00       	mov    $0x10,%edx
   14501:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14504:	89 50 20             	mov    %edx,0x20(%eax)

        disk->mutex = &mutex;
   14507:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1450a:	c7 80 1e 01 00 00 ec 	movl   $0x365ec,0x11e(%eax)
   14511:	65 03 00 
        disk->op_sem = &op_sem;
   14514:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14517:	c7 80 22 01 00 00 00 	movl   $0x36600,0x122(%eax)
   1451e:	66 03 00 
        disk->port_base = IOBASE_PRIMARY;
   14521:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14524:	66 c7 40 24 f0 01    	movw   $0x1f0,0x24(%eax)
        int err = identify_disk(disk);
   1452a:	83 ec 0c             	sub    $0xc,%esp
   1452d:	ff 75 f0             	pushl  -0x10(%ebp)
   14530:	e8 0c fe ff ff       	call   14341 <identify_disk>
   14535:	83 c4 10             	add    $0x10,%esp
   14538:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (err == 0)
   1453b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1453f:	75 0e                	jne    1454f <disk_init+0xe7>
        {
            print_info_disk(disk);
   14541:	83 ec 0c             	sub    $0xc,%esp
   14544:	ff 75 f0             	pushl  -0x10(%ebp)
   14547:	e8 d8 fb ff ff       	call   14124 <print_info_disk>
   1454c:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < DISK_PER_CHANNEL; i++)
   1454f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14553:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
   14557:	0f 8e 66 ff ff ff    	jle    144c3 <disk_init+0x5b>
        }
    }
}
   1455d:	90                   	nop
   1455e:	c9                   	leave  
   1455f:	c3                   	ret    

00014560 <disk_open>:

/**
 * @brief 打开磁盘
 */
int disk_open(device_t *dev)
{
   14560:	55                   	push   %ebp
   14561:	89 e5                	mov    %esp,%ebp
   14563:	83 ec 18             	sub    $0x18,%esp
    // 0xa0 a-->磁盘编号 0 --> 分区号
    int disk_idx = (dev->minor >> 4) - 0xa;
   14566:	8b 45 08             	mov    0x8(%ebp),%eax
   14569:	8b 40 08             	mov    0x8(%eax),%eax
   1456c:	c1 f8 04             	sar    $0x4,%eax
   1456f:	83 e8 0a             	sub    $0xa,%eax
   14572:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int part_idx = dev->minor & 0xF;
   14575:	8b 45 08             	mov    0x8(%ebp),%eax
   14578:	8b 40 08             	mov    0x8(%eax),%eax
   1457b:	83 e0 0f             	and    $0xf,%eax
   1457e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if ((disk_idx >= DISK_CNT) || (part_idx >= DISK_PRIMARY_PART_CNT))
   14581:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
   14585:	7f 06                	jg     1458d <disk_open+0x2d>
   14587:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
   1458b:	7e 20                	jle    145ad <disk_open+0x4d>
    {
        log_printf("disk open error: disk_idx: %d, part_idx: %d", disk_idx, part_idx);
   1458d:	83 ec 04             	sub    $0x4,%esp
   14590:	ff 75 f0             	pushl  -0x10(%ebp)
   14593:	ff 75 f4             	pushl  -0xc(%ebp)
   14596:	68 60 7c 01 00       	push   $0x17c60
   1459b:	e8 5f 2a 00 00       	call   16fff <log_printf>
   145a0:	83 c4 10             	add    $0x10,%esp
        return -1;
   145a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   145a8:	e9 a2 00 00 00       	jmp    1464f <disk_open+0xef>
    }
    disk_t *disk = disk_buff + disk_idx;
   145ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   145b0:	69 c0 26 01 00 00    	imul   $0x126,%eax,%eax
   145b6:	05 a0 63 03 00       	add    $0x363a0,%eax
   145bb:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if (disk->sector_size == 0)
   145be:	8b 45 ec             	mov    -0x14(%ebp),%eax
   145c1:	8b 40 26             	mov    0x26(%eax),%eax
   145c4:	85 c0                	test   %eax,%eax
   145c6:	75 1b                	jne    145e3 <disk_open+0x83>
    {
        log_printf("disk[%s] not exist", disk->name);
   145c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   145cb:	83 ec 08             	sub    $0x8,%esp
   145ce:	50                   	push   %eax
   145cf:	68 8c 7c 01 00       	push   $0x17c8c
   145d4:	e8 26 2a 00 00       	call   16fff <log_printf>
   145d9:	83 c4 10             	add    $0x10,%esp
        return -1;
   145dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   145e1:	eb 6c                	jmp    1464f <disk_open+0xef>
    }

    partinfo_t *part_info = disk->partinfo + part_idx;
   145e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   145e6:	8d 48 2e             	lea    0x2e(%eax),%ecx
   145e9:	8b 55 f0             	mov    -0x10(%ebp),%edx
   145ec:	89 d0                	mov    %edx,%eax
   145ee:	01 c0                	add    %eax,%eax
   145f0:	01 d0                	add    %edx,%eax
   145f2:	c1 e0 04             	shl    $0x4,%eax
   145f5:	01 c8                	add    %ecx,%eax
   145f7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (part_info->total_sector == 0)
   145fa:	8b 45 e8             	mov    -0x18(%ebp),%eax
   145fd:	8b 40 2c             	mov    0x2c(%eax),%eax
   14600:	85 c0                	test   %eax,%eax
   14602:	75 1e                	jne    14622 <disk_open+0xc2>
    {
        log_printf("disk[%s] part[%d] not exist", disk->name, part_idx);
   14604:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14607:	83 ec 04             	sub    $0x4,%esp
   1460a:	ff 75 f0             	pushl  -0x10(%ebp)
   1460d:	50                   	push   %eax
   1460e:	68 9f 7c 01 00       	push   $0x17c9f
   14613:	e8 e7 29 00 00       	call   16fff <log_printf>
   14618:	83 c4 10             	add    $0x10,%esp
        return -1;
   1461b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14620:	eb 2d                	jmp    1464f <disk_open+0xef>
    }

    dev->data = part_info;
   14622:	8b 45 08             	mov    0x8(%ebp),%eax
   14625:	8b 55 e8             	mov    -0x18(%ebp),%edx
   14628:	89 50 0c             	mov    %edx,0xc(%eax)
    irq_install(IRQ14_HARDDISK_PRIMARY, exception_handler_ide_primary);
   1462b:	83 ec 08             	sub    $0x8,%esp
   1462e:	68 c7 02 01 00       	push   $0x102c7
   14633:	6a 2e                	push   $0x2e
   14635:	e8 b5 e7 ff ff       	call   12def <irq_install>
   1463a:	83 c4 10             	add    $0x10,%esp
    irq_enable(IRQ14_HARDDISK_PRIMARY);
   1463d:	83 ec 0c             	sub    $0xc,%esp
   14640:	6a 2e                	push   $0x2e
   14642:	e8 e2 e7 ff ff       	call   12e29 <irq_enable>
   14647:	83 c4 10             	add    $0x10,%esp
    return 0;
   1464a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1464f:	c9                   	leave  
   14650:	c3                   	ret    

00014651 <disk_read>:
/**
 * @brief 读取磁盘
 */
int disk_read(device_t *dev, int addr, char *buf, int size)
{
   14651:	55                   	push   %ebp
   14652:	89 e5                	mov    %esp,%ebp
   14654:	83 ec 18             	sub    $0x18,%esp
    partinfo_t *part_info = (partinfo_t *)dev->data;
   14657:	8b 45 08             	mov    0x8(%ebp),%eax
   1465a:	8b 40 0c             	mov    0xc(%eax),%eax
   1465d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (!part_info)
   14660:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14664:	75 21                	jne    14687 <disk_read+0x36>
    {
        log_printf("disk read error, part_info is null device: %d", dev->minor);
   14666:	8b 45 08             	mov    0x8(%ebp),%eax
   14669:	8b 40 08             	mov    0x8(%eax),%eax
   1466c:	83 ec 08             	sub    $0x8,%esp
   1466f:	50                   	push   %eax
   14670:	68 bc 7c 01 00       	push   $0x17cbc
   14675:	e8 85 29 00 00       	call   16fff <log_printf>
   1467a:	83 c4 10             	add    $0x10,%esp
        return -1;
   1467d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14682:	e9 ff 00 00 00       	jmp    14786 <disk_read+0x135>
    }
    disk_t *disk = part_info->disk;
   14687:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1468a:	8b 40 20             	mov    0x20(%eax),%eax
   1468d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (disk == (disk_t *)0)
   14690:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14694:	75 21                	jne    146b7 <disk_read+0x66>
    {
        log_printf("disk read error, disk is null device: %d", dev->minor);
   14696:	8b 45 08             	mov    0x8(%ebp),%eax
   14699:	8b 40 08             	mov    0x8(%eax),%eax
   1469c:	83 ec 08             	sub    $0x8,%esp
   1469f:	50                   	push   %eax
   146a0:	68 ec 7c 01 00       	push   $0x17cec
   146a5:	e8 55 29 00 00       	call   16fff <log_printf>
   146aa:	83 c4 10             	add    $0x10,%esp
        return -1;
   146ad:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   146b2:	e9 cf 00 00 00       	jmp    14786 <disk_read+0x135>
    }
    mutex_lock(disk->mutex);
   146b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   146ba:	8b 80 1e 01 00 00    	mov    0x11e(%eax),%eax
   146c0:	83 ec 0c             	sub    $0xc,%esp
   146c3:	50                   	push   %eax
   146c4:	e8 aa 1c 00 00       	call   16373 <mutex_lock>
   146c9:	83 c4 10             	add    $0x10,%esp
    task_on_op = 1;
   146cc:	c7 05 10 66 03 00 01 	movl   $0x1,0x36610
   146d3:	00 00 00 

    int cnt;
    disk_send_cmd(disk, part_info->start_sector + addr, size, DISK_CMD_READ);
   146d6:	8b 45 14             	mov    0x14(%ebp),%eax
   146d9:	8b 55 f0             	mov    -0x10(%ebp),%edx
   146dc:	8b 4a 28             	mov    0x28(%edx),%ecx
   146df:	8b 55 0c             	mov    0xc(%ebp),%edx
   146e2:	01 ca                	add    %ecx,%edx
   146e4:	6a 24                	push   $0x24
   146e6:	50                   	push   %eax
   146e7:	52                   	push   %edx
   146e8:	ff 75 ec             	pushl  -0x14(%ebp)
   146eb:	e8 19 f8 ff ff       	call   13f09 <disk_send_cmd>
   146f0:	83 c4 10             	add    $0x10,%esp
    for (cnt = 0; cnt < size; cnt ++,buf += disk->sector_size)
   146f3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   146fa:	eb 6a                	jmp    14766 <disk_read+0x115>
    {
        sem_wait(disk->op_sem);
   146fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   146ff:	8b 80 22 01 00 00    	mov    0x122(%eax),%eax
   14705:	83 ec 0c             	sub    $0xc,%esp
   14708:	50                   	push   %eax
   14709:	e8 fe 1d 00 00       	call   1650c <sem_wait>
   1470e:	83 c4 10             	add    $0x10,%esp
        int err = disk_wait_data(disk);
   14711:	83 ec 0c             	sub    $0xc,%esp
   14714:	ff 75 ec             	pushl  -0x14(%ebp)
   14717:	e8 bd f9 ff ff       	call   140d9 <disk_wait_data>
   1471c:	83 c4 10             	add    $0x10,%esp
   1471f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (err < 0)
   14722:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   14726:	79 19                	jns    14741 <disk_read+0xf0>
        {
            log_printf("disk[%s] wait data error,start sector:%d,count:%d", disk->name, addr, cnt);
   14728:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1472b:	ff 75 f4             	pushl  -0xc(%ebp)
   1472e:	ff 75 0c             	pushl  0xc(%ebp)
   14731:	50                   	push   %eax
   14732:	68 18 7d 01 00       	push   $0x17d18
   14737:	e8 c3 28 00 00       	call   16fff <log_printf>
   1473c:	83 c4 10             	add    $0x10,%esp
            break;
   1473f:	eb 2d                	jmp    1476e <disk_read+0x11d>
        }
        disk_read_data(disk, buf, disk->sector_size);
   14741:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14744:	8b 40 26             	mov    0x26(%eax),%eax
   14747:	83 ec 04             	sub    $0x4,%esp
   1474a:	50                   	push   %eax
   1474b:	ff 75 10             	pushl  0x10(%ebp)
   1474e:	ff 75 ec             	pushl  -0x14(%ebp)
   14751:	e8 e3 f8 ff ff       	call   14039 <disk_read_data>
   14756:	83 c4 10             	add    $0x10,%esp
    for (cnt = 0; cnt < size; cnt ++,buf += disk->sector_size)
   14759:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1475d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14760:	8b 40 26             	mov    0x26(%eax),%eax
   14763:	01 45 10             	add    %eax,0x10(%ebp)
   14766:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14769:	3b 45 14             	cmp    0x14(%ebp),%eax
   1476c:	7c 8e                	jl     146fc <disk_read+0xab>
    }
    mutex_unlock(disk->mutex);
   1476e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14771:	8b 80 1e 01 00 00    	mov    0x11e(%eax),%eax
   14777:	83 ec 0c             	sub    $0xc,%esp
   1477a:	50                   	push   %eax
   1477b:	e8 8a 1c 00 00       	call   1640a <mutex_unlock>
   14780:	83 c4 10             	add    $0x10,%esp
    return cnt;
   14783:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14786:	c9                   	leave  
   14787:	c3                   	ret    

00014788 <disk_write>:

/**
 * @brief 写入磁盘
 */
int disk_write(device_t *dev, int addr, char *buf, int size)
{
   14788:	55                   	push   %ebp
   14789:	89 e5                	mov    %esp,%ebp
   1478b:	83 ec 18             	sub    $0x18,%esp
    partinfo_t *part_info = (partinfo_t *)dev->data;
   1478e:	8b 45 08             	mov    0x8(%ebp),%eax
   14791:	8b 40 0c             	mov    0xc(%eax),%eax
   14794:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (!part_info)
   14797:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1479b:	75 21                	jne    147be <disk_write+0x36>
    {
        log_printf("disk read error, part_info is null device: %d", dev->minor);
   1479d:	8b 45 08             	mov    0x8(%ebp),%eax
   147a0:	8b 40 08             	mov    0x8(%eax),%eax
   147a3:	83 ec 08             	sub    $0x8,%esp
   147a6:	50                   	push   %eax
   147a7:	68 bc 7c 01 00       	push   $0x17cbc
   147ac:	e8 4e 28 00 00       	call   16fff <log_printf>
   147b1:	83 c4 10             	add    $0x10,%esp
        return -1;
   147b4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   147b9:	e9 fd 00 00 00       	jmp    148bb <disk_write+0x133>
    }
    disk_t *disk = part_info->disk;
   147be:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147c1:	8b 40 20             	mov    0x20(%eax),%eax
   147c4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (disk == (disk_t *)0)
   147c7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   147cb:	75 21                	jne    147ee <disk_write+0x66>
    {
        log_printf("disk read error, disk is null device: %d", dev->minor);
   147cd:	8b 45 08             	mov    0x8(%ebp),%eax
   147d0:	8b 40 08             	mov    0x8(%eax),%eax
   147d3:	83 ec 08             	sub    $0x8,%esp
   147d6:	50                   	push   %eax
   147d7:	68 ec 7c 01 00       	push   $0x17cec
   147dc:	e8 1e 28 00 00       	call   16fff <log_printf>
   147e1:	83 c4 10             	add    $0x10,%esp
        return -1;
   147e4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   147e9:	e9 cd 00 00 00       	jmp    148bb <disk_write+0x133>
    }
    mutex_lock(disk->mutex);
   147ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
   147f1:	8b 80 1e 01 00 00    	mov    0x11e(%eax),%eax
   147f7:	83 ec 0c             	sub    $0xc,%esp
   147fa:	50                   	push   %eax
   147fb:	e8 73 1b 00 00       	call   16373 <mutex_lock>
   14800:	83 c4 10             	add    $0x10,%esp
    task_on_op = 1;
   14803:	c7 05 10 66 03 00 01 	movl   $0x1,0x36610
   1480a:	00 00 00 
    disk_send_cmd(disk, part_info->start_sector + addr, size, DISK_CMD_WRITE);
   1480d:	8b 45 14             	mov    0x14(%ebp),%eax
   14810:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14813:	8b 4a 28             	mov    0x28(%edx),%ecx
   14816:	8b 55 0c             	mov    0xc(%ebp),%edx
   14819:	01 ca                	add    %ecx,%edx
   1481b:	6a 34                	push   $0x34
   1481d:	50                   	push   %eax
   1481e:	52                   	push   %edx
   1481f:	ff 75 ec             	pushl  -0x14(%ebp)
   14822:	e8 e2 f6 ff ff       	call   13f09 <disk_send_cmd>
   14827:	83 c4 10             	add    $0x10,%esp

    int cnt;
    for (cnt = 0; cnt < size; cnt++, buf += disk->sector_size)
   1482a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14831:	eb 68                	jmp    1489b <disk_write+0x113>
    {
        disk_write_data(disk, buf, SECTOR_SIZE);
   14833:	83 ec 04             	sub    $0x4,%esp
   14836:	68 00 02 00 00       	push   $0x200
   1483b:	ff 75 10             	pushl  0x10(%ebp)
   1483e:	ff 75 ec             	pushl  -0x14(%ebp)
   14841:	e8 43 f8 ff ff       	call   14089 <disk_write_data>
   14846:	83 c4 10             	add    $0x10,%esp
        sem_wait(disk->op_sem);
   14849:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1484c:	8b 80 22 01 00 00    	mov    0x122(%eax),%eax
   14852:	83 ec 0c             	sub    $0xc,%esp
   14855:	50                   	push   %eax
   14856:	e8 b1 1c 00 00       	call   1650c <sem_wait>
   1485b:	83 c4 10             	add    $0x10,%esp
        int err = disk_wait_data(disk);
   1485e:	83 ec 0c             	sub    $0xc,%esp
   14861:	ff 75 ec             	pushl  -0x14(%ebp)
   14864:	e8 70 f8 ff ff       	call   140d9 <disk_wait_data>
   14869:	83 c4 10             	add    $0x10,%esp
   1486c:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (err < 0)
   1486f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   14873:	79 19                	jns    1488e <disk_write+0x106>
        {
            log_printf("disk[%s] wait data error,start sector:%d,count:%d", disk->name, addr, cnt);
   14875:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14878:	ff 75 f4             	pushl  -0xc(%ebp)
   1487b:	ff 75 0c             	pushl  0xc(%ebp)
   1487e:	50                   	push   %eax
   1487f:	68 18 7d 01 00       	push   $0x17d18
   14884:	e8 76 27 00 00       	call   16fff <log_printf>
   14889:	83 c4 10             	add    $0x10,%esp
            break;
   1488c:	eb 15                	jmp    148a3 <disk_write+0x11b>
    for (cnt = 0; cnt < size; cnt++, buf += disk->sector_size)
   1488e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14892:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14895:	8b 40 26             	mov    0x26(%eax),%eax
   14898:	01 45 10             	add    %eax,0x10(%ebp)
   1489b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1489e:	3b 45 14             	cmp    0x14(%ebp),%eax
   148a1:	7c 90                	jl     14833 <disk_write+0xab>
        }
    }
    mutex_unlock(disk->mutex);
   148a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   148a6:	8b 80 1e 01 00 00    	mov    0x11e(%eax),%eax
   148ac:	83 ec 0c             	sub    $0xc,%esp
   148af:	50                   	push   %eax
   148b0:	e8 55 1b 00 00       	call   1640a <mutex_unlock>
   148b5:	83 c4 10             	add    $0x10,%esp
    return cnt;
   148b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   148bb:	c9                   	leave  
   148bc:	c3                   	ret    

000148bd <disk_control>:
/**
 * @brief 控制磁盘
 */

int disk_control(device_t *dev, int cmd, int arg0, int arg1)
{
   148bd:	55                   	push   %ebp
   148be:	89 e5                	mov    %esp,%ebp
    return -1;
   148c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   148c5:	5d                   	pop    %ebp
   148c6:	c3                   	ret    

000148c7 <disk_close>:

/**
 * @brief 关闭磁盘
 */
void disk_close(device_t *dev)
{
   148c7:	55                   	push   %ebp
   148c8:	89 e5                	mov    %esp,%ebp
    while (1)
   148ca:	eb fe                	jmp    148ca <disk_close+0x3>

000148cc <do_handler_ide_primary>:
        ;
}
void do_handler_ide_primary(exception_frame_t *frame)
{
   148cc:	55                   	push   %ebp
   148cd:	89 e5                	mov    %esp,%ebp
   148cf:	83 ec 08             	sub    $0x8,%esp
    pic_send_eoi(IRQ14_HARDDISK_PRIMARY);
   148d2:	83 ec 0c             	sub    $0xc,%esp
   148d5:	6a 2e                	push   $0x2e
   148d7:	e8 75 e6 ff ff       	call   12f51 <pic_send_eoi>
   148dc:	83 c4 10             	add    $0x10,%esp
    if (task_on_op)
   148df:	a1 10 66 03 00       	mov    0x36610,%eax
   148e4:	85 c0                	test   %eax,%eax
   148e6:	74 10                	je     148f8 <do_handler_ide_primary+0x2c>
    {
        sem_signal(&op_sem);
   148e8:	83 ec 0c             	sub    $0xc,%esp
   148eb:	68 00 66 03 00       	push   $0x36600
   148f0:	e8 85 1c 00 00       	call   1657a <sem_signal>
   148f5:	83 c4 10             	add    $0x10,%esp
    }
}
   148f8:	90                   	nop
   148f9:	c9                   	leave  
   148fa:	c3                   	ret    

000148fb <inb>:
{
   148fb:	55                   	push   %ebp
   148fc:	89 e5                	mov    %esp,%ebp
   148fe:	83 ec 14             	sub    $0x14,%esp
   14901:	8b 45 08             	mov    0x8(%ebp),%eax
   14904:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__("inb %[p], %[v]" : [v] "=a"(rv) : [p] "d"(port));
   14908:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   1490c:	89 c2                	mov    %eax,%edx
   1490e:	ec                   	in     (%dx),%al
   1490f:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   14912:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   14916:	c9                   	leave  
   14917:	c3                   	ret    

00014918 <list_node_prev>:
{
   14918:	55                   	push   %ebp
   14919:	89 e5                	mov    %esp,%ebp
    return node->prev;
   1491b:	8b 45 08             	mov    0x8(%ebp),%eax
   1491e:	8b 40 04             	mov    0x4(%eax),%eax
}
   14921:	5d                   	pop    %ebp
   14922:	c3                   	ret    

00014923 <list_node_next>:
{
   14923:	55                   	push   %ebp
   14924:	89 e5                	mov    %esp,%ebp
    return node->next;
   14926:	8b 45 08             	mov    0x8(%ebp),%eax
   14929:	8b 00                	mov    (%eax),%eax
}
   1492b:	5d                   	pop    %ebp
   1492c:	c3                   	ret    

0001492d <do_fx_key>:
    [0x35] = {'/', '?'},
    [0x39] = {' ', ' '},
};

static void do_fx_key(int key)
{
   1492d:	55                   	push   %ebp
   1492e:	89 e5                	mov    %esp,%ebp
   14930:	83 ec 18             	sub    $0x18,%esp
    int index = key - KEY_F1;
   14933:	8b 45 08             	mov    0x8(%ebp),%eax
   14936:	83 e8 3b             	sub    $0x3b,%eax
   14939:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(kbd_state.lctrl_press || kbd_state.rctrl_press)
   1493c:	0f b6 05 14 66 03 00 	movzbl 0x36614,%eax
   14943:	83 e0 20             	and    $0x20,%eax
   14946:	84 c0                	test   %al,%al
   14948:	75 0e                	jne    14958 <do_fx_key+0x2b>
   1494a:	0f b6 05 14 66 03 00 	movzbl 0x36614,%eax
   14951:	83 e0 40             	and    $0x40,%eax
   14954:	84 c0                	test   %al,%al
   14956:	74 0e                	je     14966 <do_fx_key+0x39>
    {
        tty_select(index);
   14958:	83 ec 0c             	sub    $0xc,%esp
   1495b:	ff 75 f4             	pushl  -0xc(%ebp)
   1495e:	e8 0a 0a 00 00       	call   1536d <tty_select>
   14963:	83 c4 10             	add    $0x10,%esp
    }
}
   14966:	90                   	nop
   14967:	c9                   	leave  
   14968:	c3                   	ret    

00014969 <kbd_init>:

void kbd_init(void)
{
   14969:	55                   	push   %ebp
   1496a:	89 e5                	mov    %esp,%ebp
   1496c:	83 ec 08             	sub    $0x8,%esp
    static int inited = 0;
    if (!inited)
   1496f:	a1 18 66 03 00       	mov    0x36618,%eax
   14974:	85 c0                	test   %eax,%eax
   14976:	75 3e                	jne    149b6 <kbd_init+0x4d>
    {
        kernel_memset((void *)&kbd_state, 0, sizeof(kbd_state_t));
   14978:	83 ec 04             	sub    $0x4,%esp
   1497b:	6a 04                	push   $0x4
   1497d:	6a 00                	push   $0x0
   1497f:	68 14 66 03 00       	push   $0x36614
   14984:	e8 9a 20 00 00       	call   16a23 <kernel_memset>
   14989:	83 c4 10             	add    $0x10,%esp
        irq_install(IRQ1_KEYBOARD, (irq_handler_t)exception_handler_kbd);
   1498c:	83 ec 08             	sub    $0x8,%esp
   1498f:	68 a8 02 01 00       	push   $0x102a8
   14994:	6a 21                	push   $0x21
   14996:	e8 54 e4 ff ff       	call   12def <irq_install>
   1499b:	83 c4 10             	add    $0x10,%esp
        irq_enable(IRQ1_KEYBOARD);
   1499e:	83 ec 0c             	sub    $0xc,%esp
   149a1:	6a 21                	push   $0x21
   149a3:	e8 81 e4 ff ff       	call   12e29 <irq_enable>
   149a8:	83 c4 10             	add    $0x10,%esp
        inited = 1;
   149ab:	c7 05 18 66 03 00 01 	movl   $0x1,0x36618
   149b2:	00 00 00 
    }
    return;
   149b5:	90                   	nop
   149b6:	90                   	nop
}
   149b7:	c9                   	leave  
   149b8:	c3                   	ret    

000149b9 <is_make_code>:

static inline int is_make_code(uint8_t raw_code)
{
   149b9:	55                   	push   %ebp
   149ba:	89 e5                	mov    %esp,%ebp
   149bc:	83 ec 04             	sub    $0x4,%esp
   149bf:	8b 45 08             	mov    0x8(%ebp),%eax
   149c2:	88 45 fc             	mov    %al,-0x4(%ebp)
    return !(raw_code & 0x80);
   149c5:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
   149c9:	f7 d0                	not    %eax
   149cb:	c0 e8 07             	shr    $0x7,%al
   149ce:	0f b6 c0             	movzbl %al,%eax
}
   149d1:	c9                   	leave  
   149d2:	c3                   	ret    

000149d3 <get_key>:

static inline char get_key(uint8_t key_code)
{
   149d3:	55                   	push   %ebp
   149d4:	89 e5                	mov    %esp,%ebp
   149d6:	83 ec 04             	sub    $0x4,%esp
   149d9:	8b 45 08             	mov    0x8(%ebp),%eax
   149dc:	88 45 fc             	mov    %al,-0x4(%ebp)
    return key_code & 0x7F;
   149df:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
   149e3:	83 e0 7f             	and    $0x7f,%eax
}
   149e6:	c9                   	leave  
   149e7:	c3                   	ret    

000149e8 <do_normal_key>:

static void do_normal_key(uint8_t raw_code)
{
   149e8:	55                   	push   %ebp
   149e9:	89 e5                	mov    %esp,%ebp
   149eb:	83 ec 28             	sub    $0x28,%esp
   149ee:	8b 45 08             	mov    0x8(%ebp),%eax
   149f1:	88 45 e4             	mov    %al,-0x1c(%ebp)
    char key = get_key(raw_code);         // 获取键值
   149f4:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   149f8:	50                   	push   %eax
   149f9:	e8 d5 ff ff ff       	call   149d3 <get_key>
   149fe:	83 c4 04             	add    $0x4,%esp
   14a01:	88 45 f7             	mov    %al,-0x9(%ebp)
    int is_make = is_make_code(raw_code); // 获取按键状态
   14a04:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   14a08:	50                   	push   %eax
   14a09:	e8 ab ff ff ff       	call   149b9 <is_make_code>
   14a0e:	83 c4 04             	add    $0x4,%esp
   14a11:	89 45 f0             	mov    %eax,-0x10(%ebp)

    switch (key)
   14a14:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   14a18:	83 e8 1d             	sub    $0x1d,%eax
   14a1b:	83 f8 3b             	cmp    $0x3b,%eax
   14a1e:	0f 87 fc 00 00 00    	ja     14b20 <do_normal_key+0x138>
   14a24:	8b 04 85 74 7f 01 00 	mov    0x17f74(,%eax,4),%eax
   14a2b:	ff e0                	jmp    *%eax
    {
    case KEY_LSHIFT:
        kbd_state.lshift_press = is_make ? 1 : 0;
   14a2d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14a31:	0f 95 c0             	setne  %al
   14a34:	c1 e0 07             	shl    $0x7,%eax
   14a37:	c0 f8 07             	sar    $0x7,%al
   14a3a:	83 e0 01             	and    $0x1,%eax
   14a3d:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14a40:	0f b6 05 14 66 03 00 	movzbl 0x36614,%eax
   14a47:	83 e0 fd             	and    $0xfffffffd,%eax
   14a4a:	09 d0                	or     %edx,%eax
   14a4c:	a2 14 66 03 00       	mov    %al,0x36614
        break;
   14a51:	e9 7a 01 00 00       	jmp    14bd0 <do_normal_key+0x1e8>
    case KEY_RSHIFT:
        kbd_state.rshift_press = is_make ? 1 : 0;
   14a56:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14a5a:	0f 95 c0             	setne  %al
   14a5d:	c1 e0 07             	shl    $0x7,%eax
   14a60:	c0 f8 07             	sar    $0x7,%al
   14a63:	83 e0 01             	and    $0x1,%eax
   14a66:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   14a6d:	0f b6 05 14 66 03 00 	movzbl 0x36614,%eax
   14a74:	83 e0 fb             	and    $0xfffffffb,%eax
   14a77:	09 d0                	or     %edx,%eax
   14a79:	a2 14 66 03 00       	mov    %al,0x36614
        break;
   14a7e:	e9 4d 01 00 00       	jmp    14bd0 <do_normal_key+0x1e8>
    case KEY_CAPS:
        if (is_make)
   14a83:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14a87:	0f 84 3f 01 00 00    	je     14bcc <do_normal_key+0x1e4>
            kbd_state.caps_lock = ~kbd_state.caps_lock;
   14a8d:	0f b6 05 14 66 03 00 	movzbl 0x36614,%eax
   14a94:	c1 e0 07             	shl    $0x7,%eax
   14a97:	c0 f8 07             	sar    $0x7,%al
   14a9a:	f7 d0                	not    %eax
   14a9c:	c1 e0 07             	shl    $0x7,%eax
   14a9f:	c0 f8 07             	sar    $0x7,%al
   14aa2:	83 e0 01             	and    $0x1,%eax
   14aa5:	89 c2                	mov    %eax,%edx
   14aa7:	0f b6 05 14 66 03 00 	movzbl 0x36614,%eax
   14aae:	83 e0 fe             	and    $0xfffffffe,%eax
   14ab1:	09 d0                	or     %edx,%eax
   14ab3:	a2 14 66 03 00       	mov    %al,0x36614
        break;
   14ab8:	e9 0f 01 00 00       	jmp    14bcc <do_normal_key+0x1e4>
    case KEY_ALT:
        kbd_state.lalt_press = is_make;
   14abd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ac0:	c1 e0 07             	shl    $0x7,%eax
   14ac3:	c0 f8 07             	sar    $0x7,%al
   14ac6:	83 e0 01             	and    $0x1,%eax
   14ac9:	c1 e0 04             	shl    $0x4,%eax
   14acc:	89 c2                	mov    %eax,%edx
   14ace:	0f b6 05 14 66 03 00 	movzbl 0x36614,%eax
   14ad5:	83 e0 ef             	and    $0xffffffef,%eax
   14ad8:	09 d0                	or     %edx,%eax
   14ada:	a2 14 66 03 00       	mov    %al,0x36614
        break;
   14adf:	e9 ec 00 00 00       	jmp    14bd0 <do_normal_key+0x1e8>
    case KEY_CTRL:
        kbd_state.lctrl_press = is_make;
   14ae4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ae7:	c1 e0 07             	shl    $0x7,%eax
   14aea:	c0 f8 07             	sar    $0x7,%al
   14aed:	83 e0 01             	and    $0x1,%eax
   14af0:	c1 e0 05             	shl    $0x5,%eax
   14af3:	89 c2                	mov    %eax,%edx
   14af5:	0f b6 05 14 66 03 00 	movzbl 0x36614,%eax
   14afc:	83 e0 df             	and    $0xffffffdf,%eax
   14aff:	09 d0                	or     %edx,%eax
   14b01:	a2 14 66 03 00       	mov    %al,0x36614
        break;
   14b06:	e9 c5 00 00 00       	jmp    14bd0 <do_normal_key+0x1e8>
    case KEY_F5:
    case KEY_F6:
    case KEY_F7:
    case KEY_F8:
    case KEY_F9:
        do_fx_key(key);
   14b0b:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   14b0f:	83 ec 0c             	sub    $0xc,%esp
   14b12:	50                   	push   %eax
   14b13:	e8 15 fe ff ff       	call   1492d <do_fx_key>
   14b18:	83 c4 10             	add    $0x10,%esp
        break;
   14b1b:	e9 b0 00 00 00       	jmp    14bd0 <do_normal_key+0x1e8>
    case KEY_F11:
    case KEY_F12:
        break;
        break;
    default:
        if (is_make)
   14b20:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14b24:	0f 84 a5 00 00 00    	je     14bcf <do_normal_key+0x1e7>
        {
            if (kbd_state.lshift_press || kbd_state.rshift_press)
   14b2a:	0f b6 05 14 66 03 00 	movzbl 0x36614,%eax
   14b31:	83 e0 02             	and    $0x2,%eax
   14b34:	84 c0                	test   %al,%al
   14b36:	75 0e                	jne    14b46 <do_normal_key+0x15e>
   14b38:	0f b6 05 14 66 03 00 	movzbl 0x36614,%eax
   14b3f:	83 e0 04             	and    $0x4,%eax
   14b42:	84 c0                	test   %al,%al
   14b44:	74 26                	je     14b6c <do_normal_key+0x184>
            {
                key = map_table[key].func; // 获取附加功能键值
   14b46:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   14b4a:	0f b6 84 00 61 7d 01 	movzbl 0x17d61(%eax,%eax,1),%eax
   14b51:	00 
   14b52:	88 45 f7             	mov    %al,-0x9(%ebp)
                log_printf("kbd raw code: %c\n", key);
   14b55:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   14b59:	83 ec 08             	sub    $0x8,%esp
   14b5c:	50                   	push   %eax
   14b5d:	68 60 7f 01 00       	push   $0x17f60
   14b62:	e8 98 24 00 00       	call   16fff <log_printf>
   14b67:	83 c4 10             	add    $0x10,%esp
   14b6a:	eb 0f                	jmp    14b7b <do_normal_key+0x193>
            }
            else
            {
                key = map_table[key].normal;
   14b6c:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   14b70:	0f b6 84 00 60 7d 01 	movzbl 0x17d60(%eax,%eax,1),%eax
   14b77:	00 
   14b78:	88 45 f7             	mov    %al,-0x9(%ebp)
            }
            if (kbd_state.caps_lock)
   14b7b:	0f b6 05 14 66 03 00 	movzbl 0x36614,%eax
   14b82:	83 e0 01             	and    $0x1,%eax
   14b85:	84 c0                	test   %al,%al
   14b87:	74 2e                	je     14bb7 <do_normal_key+0x1cf>
            {
                if (key >= 'a' && key <= 'z')
   14b89:	80 7d f7 60          	cmpb   $0x60,-0x9(%ebp)
   14b8d:	7e 12                	jle    14ba1 <do_normal_key+0x1b9>
   14b8f:	80 7d f7 7a          	cmpb   $0x7a,-0x9(%ebp)
   14b93:	7f 0c                	jg     14ba1 <do_normal_key+0x1b9>
                {
                    key = key - 'a' + 'A';
   14b95:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   14b99:	83 e8 20             	sub    $0x20,%eax
   14b9c:	88 45 f7             	mov    %al,-0x9(%ebp)
   14b9f:	eb 16                	jmp    14bb7 <do_normal_key+0x1cf>
                }
                else if (key >= 'A' && key <= 'Z')
   14ba1:	80 7d f7 40          	cmpb   $0x40,-0x9(%ebp)
   14ba5:	7e 10                	jle    14bb7 <do_normal_key+0x1cf>
   14ba7:	80 7d f7 5a          	cmpb   $0x5a,-0x9(%ebp)
   14bab:	7f 0a                	jg     14bb7 <do_normal_key+0x1cf>
                {
                    key = key - 'A' + 'a';
   14bad:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   14bb1:	83 c0 20             	add    $0x20,%eax
   14bb4:	88 45 f7             	mov    %al,-0x9(%ebp)
                }
            }
            // log_printf("kbd raw code: %c\n", key);
            tty_in(key);
   14bb7:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   14bbb:	83 ec 0c             	sub    $0xc,%esp
   14bbe:	50                   	push   %eax
   14bbf:	e8 3c 07 00 00       	call   15300 <tty_in>
   14bc4:	83 c4 10             	add    $0x10,%esp
        }
        break;
   14bc7:	eb 06                	jmp    14bcf <do_normal_key+0x1e7>
        break;
   14bc9:	90                   	nop
   14bca:	eb 04                	jmp    14bd0 <do_normal_key+0x1e8>
        break;
   14bcc:	90                   	nop
   14bcd:	eb 01                	jmp    14bd0 <do_normal_key+0x1e8>
        break;
   14bcf:	90                   	nop
    }
}
   14bd0:	90                   	nop
   14bd1:	c9                   	leave  
   14bd2:	c3                   	ret    

00014bd3 <do_e0_key>:

static void do_e0_key(int raw_code)
{
   14bd3:	55                   	push   %ebp
   14bd4:	89 e5                	mov    %esp,%ebp
   14bd6:	83 ec 10             	sub    $0x10,%esp
    char key = get_key(raw_code);         // 获取键值
   14bd9:	8b 45 08             	mov    0x8(%ebp),%eax
   14bdc:	0f b6 c0             	movzbl %al,%eax
   14bdf:	50                   	push   %eax
   14be0:	e8 ee fd ff ff       	call   149d3 <get_key>
   14be5:	83 c4 04             	add    $0x4,%esp
   14be8:	88 45 ff             	mov    %al,-0x1(%ebp)
    int is_make = is_make_code(raw_code); // 获取按键状态
   14beb:	8b 45 08             	mov    0x8(%ebp),%eax
   14bee:	0f b6 c0             	movzbl %al,%eax
   14bf1:	50                   	push   %eax
   14bf2:	e8 c2 fd ff ff       	call   149b9 <is_make_code>
   14bf7:	83 c4 04             	add    $0x4,%esp
   14bfa:	89 45 f8             	mov    %eax,-0x8(%ebp)

    switch (key)
   14bfd:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
   14c01:	83 f8 1d             	cmp    $0x1d,%eax
   14c04:	74 07                	je     14c0d <do_e0_key+0x3a>
   14c06:	83 f8 38             	cmp    $0x38,%eax
   14c09:	74 26                	je     14c31 <do_e0_key+0x5e>
        break;
    case KEY_ALT:
        kbd_state.ralt_press = is_make;
        break;
    }
}
   14c0b:	eb 49                	jmp    14c56 <do_e0_key+0x83>
        kbd_state.rctrl_press = is_make;
   14c0d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14c10:	c1 e0 07             	shl    $0x7,%eax
   14c13:	c0 f8 07             	sar    $0x7,%al
   14c16:	83 e0 01             	and    $0x1,%eax
   14c19:	c1 e0 06             	shl    $0x6,%eax
   14c1c:	89 c2                	mov    %eax,%edx
   14c1e:	0f b6 05 14 66 03 00 	movzbl 0x36614,%eax
   14c25:	83 e0 bf             	and    $0xffffffbf,%eax
   14c28:	09 d0                	or     %edx,%eax
   14c2a:	a2 14 66 03 00       	mov    %al,0x36614
        break;
   14c2f:	eb 25                	jmp    14c56 <do_e0_key+0x83>
        kbd_state.ralt_press = is_make;
   14c31:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14c34:	c1 e0 07             	shl    $0x7,%eax
   14c37:	c0 f8 07             	sar    $0x7,%al
   14c3a:	83 e0 01             	and    $0x1,%eax
   14c3d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   14c44:	0f b6 05 14 66 03 00 	movzbl 0x36614,%eax
   14c4b:	83 e0 f7             	and    $0xfffffff7,%eax
   14c4e:	09 d0                	or     %edx,%eax
   14c50:	a2 14 66 03 00       	mov    %al,0x36614
        break;
   14c55:	90                   	nop
}
   14c56:	90                   	nop
   14c57:	c9                   	leave  
   14c58:	c3                   	ret    

00014c59 <do_handler_kbd>:

void do_handler_kbd(exception_frame_t *frame)
{
   14c59:	55                   	push   %ebp
   14c5a:	89 e5                	mov    %esp,%ebp
   14c5c:	83 ec 18             	sub    $0x18,%esp
        NORMAL,
        BEGIN_E0,
        BEGIN_E1,
    } recv_state = NORMAL;
    // 检查是否有数据，无数据则退出
    uint8_t status = inb(KBD_PORT_STAT);
   14c5f:	6a 64                	push   $0x64
   14c61:	e8 95 fc ff ff       	call   148fb <inb>
   14c66:	83 c4 04             	add    $0x4,%esp
   14c69:	88 45 f7             	mov    %al,-0x9(%ebp)
    if (!(status & KBD_STAT_RECV_READY))
   14c6c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   14c70:	83 e0 01             	and    $0x1,%eax
   14c73:	85 c0                	test   %eax,%eax
   14c75:	75 12                	jne    14c89 <do_handler_kbd+0x30>
    {
        pic_send_eoi(IRQ1_KEYBOARD);
   14c77:	83 ec 0c             	sub    $0xc,%esp
   14c7a:	6a 21                	push   $0x21
   14c7c:	e8 d0 e2 ff ff       	call   12f51 <pic_send_eoi>
   14c81:	83 c4 10             	add    $0x10,%esp
        return;
   14c84:	e9 90 00 00 00       	jmp    14d19 <do_handler_kbd+0xc0>
    }
    uint8_t raw_code = inb(KBD_PORT_DATA);
   14c89:	83 ec 0c             	sub    $0xc,%esp
   14c8c:	6a 60                	push   $0x60
   14c8e:	e8 68 fc ff ff       	call   148fb <inb>
   14c93:	83 c4 10             	add    $0x10,%esp
   14c96:	88 45 f6             	mov    %al,-0xa(%ebp)
    pic_send_eoi(IRQ1_KEYBOARD);
   14c99:	83 ec 0c             	sub    $0xc,%esp
   14c9c:	6a 21                	push   $0x21
   14c9e:	e8 ae e2 ff ff       	call   12f51 <pic_send_eoi>
   14ca3:	83 c4 10             	add    $0x10,%esp

    if (raw_code == KEY_E0)
   14ca6:	80 7d f6 e0          	cmpb   $0xe0,-0xa(%ebp)
   14caa:	75 0c                	jne    14cb8 <do_handler_kbd+0x5f>
    {
        recv_state = BEGIN_E0;
   14cac:	c7 05 1c 66 03 00 01 	movl   $0x1,0x3661c
   14cb3:	00 00 00 
   14cb6:	eb 61                	jmp    14d19 <do_handler_kbd+0xc0>
    }
    else if (raw_code == KEY_E1)
   14cb8:	80 7d f6 e1          	cmpb   $0xe1,-0xa(%ebp)
   14cbc:	75 0c                	jne    14cca <do_handler_kbd+0x71>
    {
        recv_state = BEGIN_E1;
   14cbe:	c7 05 1c 66 03 00 02 	movl   $0x2,0x3661c
   14cc5:	00 00 00 
   14cc8:	eb 4f                	jmp    14d19 <do_handler_kbd+0xc0>
    }
    else
    {
        switch (recv_state)
   14cca:	a1 1c 66 03 00       	mov    0x3661c,%eax
   14ccf:	83 f8 01             	cmp    $0x1,%eax
   14cd2:	74 1e                	je     14cf2 <do_handler_kbd+0x99>
   14cd4:	83 f8 01             	cmp    $0x1,%eax
   14cd7:	72 07                	jb     14ce0 <do_handler_kbd+0x87>
   14cd9:	83 f8 02             	cmp    $0x2,%eax
   14cdc:	74 30                	je     14d0e <do_handler_kbd+0xb5>
   14cde:	eb 39                	jmp    14d19 <do_handler_kbd+0xc0>
        {
        case NORMAL:
            do_normal_key(raw_code);
   14ce0:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
   14ce4:	83 ec 0c             	sub    $0xc,%esp
   14ce7:	50                   	push   %eax
   14ce8:	e8 fb fc ff ff       	call   149e8 <do_normal_key>
   14ced:	83 c4 10             	add    $0x10,%esp
            break;
   14cf0:	eb 27                	jmp    14d19 <do_handler_kbd+0xc0>
        case BEGIN_E0:
            do_e0_key(raw_code);
   14cf2:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
   14cf6:	83 ec 0c             	sub    $0xc,%esp
   14cf9:	50                   	push   %eax
   14cfa:	e8 d4 fe ff ff       	call   14bd3 <do_e0_key>
   14cff:	83 c4 10             	add    $0x10,%esp
            recv_state = NORMAL;
   14d02:	c7 05 1c 66 03 00 00 	movl   $0x0,0x3661c
   14d09:	00 00 00 
            break;
   14d0c:	eb 0b                	jmp    14d19 <do_handler_kbd+0xc0>
        case BEGIN_E1:
            recv_state = NORMAL;
   14d0e:	c7 05 1c 66 03 00 00 	movl   $0x0,0x3661c
   14d15:	00 00 00 
            break;
   14d18:	90                   	nop
        }
    }
   14d19:	c9                   	leave  
   14d1a:	c3                   	ret    

00014d1b <outb>:
{
   14d1b:	55                   	push   %ebp
   14d1c:	89 e5                	mov    %esp,%ebp
   14d1e:	83 ec 08             	sub    $0x8,%esp
   14d21:	8b 55 08             	mov    0x8(%ebp),%edx
   14d24:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d27:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   14d2b:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile__("outb %[v], %[p]" : : [p] "d"(port), [v] "a"(data));
   14d2e:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   14d32:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   14d36:	ee                   	out    %al,(%dx)
}
   14d37:	90                   	nop
   14d38:	c9                   	leave  
   14d39:	c3                   	ret    

00014d3a <list_node_prev>:
{
   14d3a:	55                   	push   %ebp
   14d3b:	89 e5                	mov    %esp,%ebp
    return node->prev;
   14d3d:	8b 45 08             	mov    0x8(%ebp),%eax
   14d40:	8b 40 04             	mov    0x4(%eax),%eax
}
   14d43:	5d                   	pop    %ebp
   14d44:	c3                   	ret    

00014d45 <list_node_next>:
{
   14d45:	55                   	push   %ebp
   14d46:	89 e5                	mov    %esp,%ebp
    return node->next;
   14d48:	8b 45 08             	mov    0x8(%ebp),%eax
   14d4b:	8b 00                	mov    (%eax),%eax
}
   14d4d:	5d                   	pop    %ebp
   14d4e:	c3                   	ret    

00014d4f <do_handler_time>:
#include "core/task.h"

static uint32_t sys_tick;

void do_handler_time(exception_frame_t *frame)
{
   14d4f:	55                   	push   %ebp
   14d50:	89 e5                	mov    %esp,%ebp
   14d52:	83 ec 08             	sub    $0x8,%esp
    sys_tick++;
   14d55:	a1 20 66 03 00       	mov    0x36620,%eax
   14d5a:	83 c0 01             	add    $0x1,%eax
   14d5d:	a3 20 66 03 00       	mov    %eax,0x36620
    pic_send_eoi(IRQ0_TIMER);
   14d62:	83 ec 0c             	sub    $0xc,%esp
   14d65:	6a 20                	push   $0x20
   14d67:	e8 e5 e1 ff ff       	call   12f51 <pic_send_eoi>
   14d6c:	83 c4 10             	add    $0x10,%esp
    task_time_tick();
   14d6f:	e8 48 ca ff ff       	call   117bc <task_time_tick>
}
   14d74:	90                   	nop
   14d75:	c9                   	leave  
   14d76:	c3                   	ret    

00014d77 <init_pit>:

/**
 * 初始化硬件定时器
 */
static void init_pit(void)
{
   14d77:	55                   	push   %ebp
   14d78:	89 e5                	mov    %esp,%ebp
   14d7a:	83 ec 18             	sub    $0x18,%esp
    uint32_t reload_count = PIT_OSC_FREQ / (1000.0 / OS_TICK_MS);
   14d7d:	c7 45 f4 9b 2e 00 00 	movl   $0x2e9b,-0xc(%ebp)

    // outb(PIT_COMMAND_MODE_PORT, PIT_CHANNLE0 | PIT_LOAD_LOHI | PIT_MODE0);
    outb(PIT_COMMAND_MODE_PORT, PIT_CHANNLE0 | PIT_LOAD_LOHI | PIT_MODE3);
   14d84:	6a 36                	push   $0x36
   14d86:	6a 43                	push   $0x43
   14d88:	e8 8e ff ff ff       	call   14d1b <outb>
   14d8d:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, reload_count & 0xFF);        // 加载低8位
   14d90:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14d93:	0f b6 c0             	movzbl %al,%eax
   14d96:	50                   	push   %eax
   14d97:	6a 40                	push   $0x40
   14d99:	e8 7d ff ff ff       	call   14d1b <outb>
   14d9e:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, (reload_count >> 8) & 0xFF); // 再加载高8位
   14da1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14da4:	c1 e8 08             	shr    $0x8,%eax
   14da7:	0f b6 c0             	movzbl %al,%eax
   14daa:	50                   	push   %eax
   14dab:	6a 40                	push   $0x40
   14dad:	e8 69 ff ff ff       	call   14d1b <outb>
   14db2:	83 c4 08             	add    $0x8,%esp

    irq_install(IRQ0_TIMER, (irq_handler_t)exception_handler_time);
   14db5:	83 ec 08             	sub    $0x8,%esp
   14db8:	68 89 02 01 00       	push   $0x10289
   14dbd:	6a 20                	push   $0x20
   14dbf:	e8 2b e0 ff ff       	call   12def <irq_install>
   14dc4:	83 c4 10             	add    $0x10,%esp
    irq_enable(IRQ0_TIMER);
   14dc7:	83 ec 0c             	sub    $0xc,%esp
   14dca:	6a 20                	push   $0x20
   14dcc:	e8 58 e0 ff ff       	call   12e29 <irq_enable>
   14dd1:	83 c4 10             	add    $0x10,%esp
}
   14dd4:	90                   	nop
   14dd5:	c9                   	leave  
   14dd6:	c3                   	ret    

00014dd7 <time_init>:

void time_init(void)
{
   14dd7:	55                   	push   %ebp
   14dd8:	89 e5                	mov    %esp,%ebp
   14dda:	83 ec 08             	sub    $0x8,%esp
    sys_tick = 0;
   14ddd:	c7 05 20 66 03 00 00 	movl   $0x0,0x36620
   14de4:	00 00 00 

    init_pit();
   14de7:	e8 8b ff ff ff       	call   14d77 <init_pit>
   14dec:	90                   	nop
   14ded:	c9                   	leave  
   14dee:	c3                   	ret    

00014def <list_node_prev>:
{
   14def:	55                   	push   %ebp
   14df0:	89 e5                	mov    %esp,%ebp
    return node->prev;
   14df2:	8b 45 08             	mov    0x8(%ebp),%eax
   14df5:	8b 40 04             	mov    0x4(%eax),%eax
}
   14df8:	5d                   	pop    %ebp
   14df9:	c3                   	ret    

00014dfa <list_node_next>:
{
   14dfa:	55                   	push   %ebp
   14dfb:	89 e5                	mov    %esp,%ebp
    return node->next;
   14dfd:	8b 45 08             	mov    0x8(%ebp),%eax
   14e00:	8b 00                	mov    (%eax),%eax
}
   14e02:	5d                   	pop    %ebp
   14e03:	c3                   	ret    

00014e04 <get_tty>:

/**
 * @brief 判断tty是否有效
 */
static inline tty_t *get_tty(device_t *dev)
{
   14e04:	55                   	push   %ebp
   14e05:	89 e5                	mov    %esp,%ebp
   14e07:	83 ec 18             	sub    $0x18,%esp
    int tty = dev->minor;
   14e0a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e0d:	8b 40 08             	mov    0x8(%eax),%eax
   14e10:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if ((tty < 0) || (tty >= TTY_NR) || (!dev->open_count))
   14e13:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14e17:	78 10                	js     14e29 <get_tty+0x25>
   14e19:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14e1d:	7f 0a                	jg     14e29 <get_tty+0x25>
   14e1f:	8b 45 08             	mov    0x8(%ebp),%eax
   14e22:	8b 40 10             	mov    0x10(%eax),%eax
   14e25:	85 c0                	test   %eax,%eax
   14e27:	75 1a                	jne    14e43 <get_tty+0x3f>
    {
        log_printf("tty is not opened. tty = %d", tty);
   14e29:	83 ec 08             	sub    $0x8,%esp
   14e2c:	ff 75 f4             	pushl  -0xc(%ebp)
   14e2f:	68 64 80 01 00       	push   $0x18064
   14e34:	e8 c6 21 00 00       	call   16fff <log_printf>
   14e39:	83 c4 10             	add    $0x10,%esp
        return (tty_t *)0;
   14e3c:	b8 00 00 00 00       	mov    $0x0,%eax
   14e41:	eb 0e                	jmp    14e51 <get_tty+0x4d>
    }

    return tty_devs + tty;
   14e43:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14e46:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   14e4c:	05 40 66 03 00       	add    $0x36640,%eax
}
   14e51:	c9                   	leave  
   14e52:	c3                   	ret    

00014e53 <tty_write>:
int tty_write(device_t *dev, int addr, char *buf, int size)
{
   14e53:	55                   	push   %ebp
   14e54:	89 e5                	mov    %esp,%ebp
   14e56:	83 ec 28             	sub    $0x28,%esp
    if (size < 0)
   14e59:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   14e5d:	79 1d                	jns    14e7c <tty_write+0x29>
    {
        log_printf("tty_write: invalid size %d\n", size);
   14e5f:	83 ec 08             	sub    $0x8,%esp
   14e62:	ff 75 14             	pushl  0x14(%ebp)
   14e65:	68 80 80 01 00       	push   $0x18080
   14e6a:	e8 90 21 00 00       	call   16fff <log_printf>
   14e6f:	83 c4 10             	add    $0x10,%esp
        return -1;
   14e72:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14e77:	e9 e5 00 00 00       	jmp    14f61 <tty_write+0x10e>
    }
    tty_t *tty = get_tty(dev);
   14e7c:	83 ec 0c             	sub    $0xc,%esp
   14e7f:	ff 75 08             	pushl  0x8(%ebp)
   14e82:	e8 7d ff ff ff       	call   14e04 <get_tty>
   14e87:	83 c4 10             	add    $0x10,%esp
   14e8a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (!tty)
   14e8d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14e91:	75 0a                	jne    14e9d <tty_write+0x4a>
    {
        return -1;
   14e93:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14e98:	e9 c4 00 00 00       	jmp    14f61 <tty_write+0x10e>
    }
    int len = 0;
   14e9d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while (size)
   14ea4:	e9 a5 00 00 00       	jmp    14f4e <tty_write+0xfb>
    {
        char c = *buf++;
   14ea9:	8b 45 10             	mov    0x10(%ebp),%eax
   14eac:	8d 50 01             	lea    0x1(%eax),%edx
   14eaf:	89 55 10             	mov    %edx,0x10(%ebp)
   14eb2:	0f b6 00             	movzbl (%eax),%eax
   14eb5:	88 45 ef             	mov    %al,-0x11(%ebp)
        if ((c == '\n') && (tty->oflags & TTY_OCRLF))
   14eb8:	80 7d ef 0a          	cmpb   $0xa,-0x11(%ebp)
   14ebc:	75 43                	jne    14f01 <tty_write+0xae>
   14ebe:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ec1:	8b 80 48 04 00 00    	mov    0x448(%eax),%eax
   14ec7:	83 e0 01             	and    $0x1,%eax
   14eca:	85 c0                	test   %eax,%eax
   14ecc:	74 33                	je     14f01 <tty_write+0xae>
        {
            sem_wait(&tty->osem);
   14ece:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ed1:	05 14 02 00 00       	add    $0x214,%eax
   14ed6:	83 ec 0c             	sub    $0xc,%esp
   14ed9:	50                   	push   %eax
   14eda:	e8 2d 16 00 00       	call   1650c <sem_wait>
   14edf:	83 c4 10             	add    $0x10,%esp
            int err = tty_fifo_put(&tty->ofifo, '\r');
   14ee2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ee5:	05 00 02 00 00       	add    $0x200,%eax
   14eea:	83 ec 08             	sub    $0x8,%esp
   14eed:	6a 0d                	push   $0xd
   14eef:	50                   	push   %eax
   14ef0:	e8 d2 02 00 00       	call   151c7 <tty_fifo_put>
   14ef5:	83 c4 10             	add    $0x10,%esp
   14ef8:	89 45 e8             	mov    %eax,-0x18(%ebp)
            if (err < 0)
   14efb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   14eff:	78 59                	js     14f5a <tty_write+0x107>
            {
                break;
            }
        }
        sem_wait(&tty->osem);
   14f01:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f04:	05 14 02 00 00       	add    $0x214,%eax
   14f09:	83 ec 0c             	sub    $0xc,%esp
   14f0c:	50                   	push   %eax
   14f0d:	e8 fa 15 00 00       	call   1650c <sem_wait>
   14f12:	83 c4 10             	add    $0x10,%esp
        int err = tty_fifo_put(&tty->ofifo, c);
   14f15:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
   14f19:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14f1c:	81 c2 00 02 00 00    	add    $0x200,%edx
   14f22:	83 ec 08             	sub    $0x8,%esp
   14f25:	50                   	push   %eax
   14f26:	52                   	push   %edx
   14f27:	e8 9b 02 00 00       	call   151c7 <tty_fifo_put>
   14f2c:	83 c4 10             	add    $0x10,%esp
   14f2f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (err < 0)
   14f32:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   14f36:	78 25                	js     14f5d <tty_write+0x10a>
        {
            break;
        }
        len++;
   14f38:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        size--;
   14f3c:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
        // 显示器正在忙，空闲则发送
        console_write(tty);
   14f40:	83 ec 0c             	sub    $0xc,%esp
   14f43:	ff 75 f0             	pushl  -0x10(%ebp)
   14f46:	e8 71 ea ff ff       	call   139bc <console_write>
   14f4b:	83 c4 10             	add    $0x10,%esp
    while (size)
   14f4e:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   14f52:	0f 85 51 ff ff ff    	jne    14ea9 <tty_write+0x56>
   14f58:	eb 04                	jmp    14f5e <tty_write+0x10b>
                break;
   14f5a:	90                   	nop
   14f5b:	eb 01                	jmp    14f5e <tty_write+0x10b>
            break;
   14f5d:	90                   	nop
    }
    return len;
   14f5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14f61:	c9                   	leave  
   14f62:	c3                   	ret    

00014f63 <tty_fifo_init>:

void tty_fifo_init(tty_fifo_t *fifo, char *buf, int size)
{
   14f63:	55                   	push   %ebp
   14f64:	89 e5                	mov    %esp,%ebp
    fifo->buf = buf;
   14f66:	8b 45 08             	mov    0x8(%ebp),%eax
   14f69:	8b 55 0c             	mov    0xc(%ebp),%edx
   14f6c:	89 10                	mov    %edx,(%eax)
    fifo->size = size;
   14f6e:	8b 45 08             	mov    0x8(%ebp),%eax
   14f71:	8b 55 10             	mov    0x10(%ebp),%edx
   14f74:	89 50 04             	mov    %edx,0x4(%eax)
    fifo->read = fifo->write = 0;
   14f77:	8b 45 08             	mov    0x8(%ebp),%eax
   14f7a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   14f81:	8b 45 08             	mov    0x8(%ebp),%eax
   14f84:	8b 50 0c             	mov    0xc(%eax),%edx
   14f87:	8b 45 08             	mov    0x8(%ebp),%eax
   14f8a:	89 50 08             	mov    %edx,0x8(%eax)
    fifo->count = 0;
   14f8d:	8b 45 08             	mov    0x8(%ebp),%eax
   14f90:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
}
   14f97:	90                   	nop
   14f98:	5d                   	pop    %ebp
   14f99:	c3                   	ret    

00014f9a <tty_open>:
int tty_open(device_t *dev)
{
   14f9a:	55                   	push   %ebp
   14f9b:	89 e5                	mov    %esp,%ebp
   14f9d:	83 ec 18             	sub    $0x18,%esp
    int idx = dev->minor;
   14fa0:	8b 45 08             	mov    0x8(%ebp),%eax
   14fa3:	8b 40 08             	mov    0x8(%eax),%eax
   14fa6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (idx < 0 || idx >= TTY_NR)
   14fa9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14fad:	78 06                	js     14fb5 <tty_open+0x1b>
   14faf:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14fb3:	7e 1d                	jle    14fd2 <tty_open+0x38>
    {
        log_printf("tty_open: invalid minor number %d\n", idx);
   14fb5:	83 ec 08             	sub    $0x8,%esp
   14fb8:	ff 75 f4             	pushl  -0xc(%ebp)
   14fbb:	68 9c 80 01 00       	push   $0x1809c
   14fc0:	e8 3a 20 00 00       	call   16fff <log_printf>
   14fc5:	83 c4 10             	add    $0x10,%esp
        return -1;
   14fc8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14fcd:	e9 bf 00 00 00       	jmp    15091 <tty_open+0xf7>
    }
    tty_t *tty = &tty_devs[idx];
   14fd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14fd5:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   14fdb:	05 40 66 03 00       	add    $0x36640,%eax
   14fe0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    tty_fifo_init(&tty->ofifo, tty->obuf, TTY_OBUF_SIZE);
   14fe3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14fe6:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14fe9:	81 c2 00 02 00 00    	add    $0x200,%edx
   14fef:	83 ec 04             	sub    $0x4,%esp
   14ff2:	68 00 02 00 00       	push   $0x200
   14ff7:	50                   	push   %eax
   14ff8:	52                   	push   %edx
   14ff9:	e8 65 ff ff ff       	call   14f63 <tty_fifo_init>
   14ffe:	83 c4 10             	add    $0x10,%esp
    sem_init(&tty->osem, TTY_OBUF_SIZE);
   15001:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15004:	05 14 02 00 00       	add    $0x214,%eax
   15009:	83 ec 08             	sub    $0x8,%esp
   1500c:	68 00 02 00 00       	push   $0x200
   15011:	50                   	push   %eax
   15012:	e8 d2 14 00 00       	call   164e9 <sem_init>
   15017:	83 c4 10             	add    $0x10,%esp
    tty_fifo_init(&tty->ififo, tty->ibuf, TTY_IFIFO_SIZE);
   1501a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1501d:	8d 90 24 02 00 00    	lea    0x224(%eax),%edx
   15023:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15026:	05 24 04 00 00       	add    $0x424,%eax
   1502b:	83 ec 04             	sub    $0x4,%esp
   1502e:	68 00 02 00 00       	push   $0x200
   15033:	52                   	push   %edx
   15034:	50                   	push   %eax
   15035:	e8 29 ff ff ff       	call   14f63 <tty_fifo_init>
   1503a:	83 c4 10             	add    $0x10,%esp
    sem_init(&tty->isem, 0);
   1503d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15040:	05 38 04 00 00       	add    $0x438,%eax
   15045:	83 ec 08             	sub    $0x8,%esp
   15048:	6a 00                	push   $0x0
   1504a:	50                   	push   %eax
   1504b:	e8 99 14 00 00       	call   164e9 <sem_init>
   15050:	83 c4 10             	add    $0x10,%esp
    tty->console_idx = idx;
   15053:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15056:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15059:	89 90 50 04 00 00    	mov    %edx,0x450(%eax)
    tty->oflags = TTY_OCRLF;
   1505f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15062:	c7 80 48 04 00 00 01 	movl   $0x1,0x448(%eax)
   15069:	00 00 00 
    tty->iflags = TTY_INLCR | TTY_IECHO;
   1506c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1506f:	c7 80 4c 04 00 00 05 	movl   $0x5,0x44c(%eax)
   15076:	00 00 00 

    kbd_init();
   15079:	e8 eb f8 ff ff       	call   14969 <kbd_init>
    console_init(idx);
   1507e:	83 ec 0c             	sub    $0xc,%esp
   15081:	ff 75 f4             	pushl  -0xc(%ebp)
   15084:	e8 53 e3 ff ff       	call   133dc <console_init>
   15089:	83 c4 10             	add    $0x10,%esp
    return 0;
   1508c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15091:	c9                   	leave  
   15092:	c3                   	ret    

00015093 <tty_read>:
int tty_read(device_t *dev, int addr, char *buf, int size)
{
   15093:	55                   	push   %ebp
   15094:	89 e5                	mov    %esp,%ebp
   15096:	83 ec 18             	sub    $0x18,%esp
    if (size < 0)
   15099:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   1509d:	79 1d                	jns    150bc <tty_read+0x29>
    {
        log_printf("tty_read: invalid size %d\n", size);
   1509f:	83 ec 08             	sub    $0x8,%esp
   150a2:	ff 75 14             	pushl  0x14(%ebp)
   150a5:	68 bf 80 01 00       	push   $0x180bf
   150aa:	e8 50 1f 00 00       	call   16fff <log_printf>
   150af:	83 c4 10             	add    $0x10,%esp
        return -1;
   150b2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   150b7:	e9 09 01 00 00       	jmp    151c5 <tty_read+0x132>
    }
    tty_t *tty = get_tty(dev);
   150bc:	83 ec 0c             	sub    $0xc,%esp
   150bf:	ff 75 08             	pushl  0x8(%ebp)
   150c2:	e8 3d fd ff ff       	call   14e04 <get_tty>
   150c7:	83 c4 10             	add    $0x10,%esp
   150ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char *pbuf = buf;
   150cd:	8b 45 10             	mov    0x10(%ebp),%eax
   150d0:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int len = 0;
   150d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while (len < size)
   150da:	e9 d7 00 00 00       	jmp    151b6 <tty_read+0x123>
    {
        sem_wait(&tty->isem);
   150df:	8b 45 ec             	mov    -0x14(%ebp),%eax
   150e2:	05 38 04 00 00       	add    $0x438,%eax
   150e7:	83 ec 0c             	sub    $0xc,%esp
   150ea:	50                   	push   %eax
   150eb:	e8 1c 14 00 00       	call   1650c <sem_wait>
   150f0:	83 c4 10             	add    $0x10,%esp
        char c;
        tty_fifo_get(&tty->ififo, &c);
   150f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   150f6:	8d 90 24 04 00 00    	lea    0x424(%eax),%edx
   150fc:	83 ec 08             	sub    $0x8,%esp
   150ff:	8d 45 eb             	lea    -0x15(%ebp),%eax
   15102:	50                   	push   %eax
   15103:	52                   	push   %edx
   15104:	e8 58 01 00 00       	call   15261 <tty_fifo_get>
   15109:	83 c4 10             	add    $0x10,%esp

        switch (c)
   1510c:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   15110:	0f be c0             	movsbl %al,%eax
   15113:	83 f8 0a             	cmp    $0xa,%eax
   15116:	74 1a                	je     15132 <tty_read+0x9f>
   15118:	83 f8 7f             	cmp    $0x7f,%eax
   1511b:	75 52                	jne    1516f <tty_read+0xdc>
        {
        case 0x7F:
            if (len == 0)
   1511d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   15121:	75 05                	jne    15128 <tty_read+0x95>
   15123:	e9 8e 00 00 00       	jmp    151b6 <tty_read+0x123>
            {
                continue;
            }
            len--;
   15128:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
            pbuf--;
   1512c:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
            break;
   15130:	eb 51                	jmp    15183 <tty_read+0xf0>
        case '\n':
            if (tty->iflags & TTY_INLCR && len < size - 1)
   15132:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15135:	8b 80 4c 04 00 00    	mov    0x44c(%eax),%eax
   1513b:	83 e0 01             	and    $0x1,%eax
   1513e:	85 c0                	test   %eax,%eax
   15140:	74 1b                	je     1515d <tty_read+0xca>
   15142:	8b 45 14             	mov    0x14(%ebp),%eax
   15145:	83 e8 01             	sub    $0x1,%eax
   15148:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1514b:	7d 10                	jge    1515d <tty_read+0xca>
            {
                *pbuf++ = '\r';
   1514d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15150:	8d 50 01             	lea    0x1(%eax),%edx
   15153:	89 55 f4             	mov    %edx,-0xc(%ebp)
   15156:	c6 00 0d             	movb   $0xd,(%eax)
                len++;
   15159:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            }
            *pbuf++ = '\n';
   1515d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15160:	8d 50 01             	lea    0x1(%eax),%edx
   15163:	89 55 f4             	mov    %edx,-0xc(%ebp)
   15166:	c6 00 0a             	movb   $0xa,(%eax)
            len++;
   15169:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            break;
   1516d:	eb 14                	jmp    15183 <tty_read+0xf0>
        default:
            *pbuf++ = c;
   1516f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15172:	8d 50 01             	lea    0x1(%eax),%edx
   15175:	89 55 f4             	mov    %edx,-0xc(%ebp)
   15178:	0f b6 55 eb          	movzbl -0x15(%ebp),%edx
   1517c:	88 10                	mov    %dl,(%eax)
            len++;
   1517e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            break;
   15182:	90                   	nop
        }
        if (tty->iflags & TTY_IECHO)
   15183:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15186:	8b 80 4c 04 00 00    	mov    0x44c(%eax),%eax
   1518c:	83 e0 04             	and    $0x4,%eax
   1518f:	85 c0                	test   %eax,%eax
   15191:	74 13                	je     151a6 <tty_read+0x113>
        {
            tty_write(dev, 0, &c, 1);
   15193:	6a 01                	push   $0x1
   15195:	8d 45 eb             	lea    -0x15(%ebp),%eax
   15198:	50                   	push   %eax
   15199:	6a 00                	push   $0x0
   1519b:	ff 75 08             	pushl  0x8(%ebp)
   1519e:	e8 b0 fc ff ff       	call   14e53 <tty_write>
   151a3:	83 c4 10             	add    $0x10,%esp
        }
        if ((c == '\n') || (c == '\r'))
   151a6:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   151aa:	3c 0a                	cmp    $0xa,%al
   151ac:	74 14                	je     151c2 <tty_read+0x12f>
   151ae:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   151b2:	3c 0d                	cmp    $0xd,%al
   151b4:	74 0c                	je     151c2 <tty_read+0x12f>
    while (len < size)
   151b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151b9:	3b 45 14             	cmp    0x14(%ebp),%eax
   151bc:	0f 8c 1d ff ff ff    	jl     150df <tty_read+0x4c>
        {
            break;
        }
    }
    return len;
   151c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   151c5:	c9                   	leave  
   151c6:	c3                   	ret    

000151c7 <tty_fifo_put>:

/**
 * @brief 写一字节数据
 */
int tty_fifo_put(tty_fifo_t *fifo, char c)
{
   151c7:	55                   	push   %ebp
   151c8:	89 e5                	mov    %esp,%ebp
   151ca:	53                   	push   %ebx
   151cb:	83 ec 24             	sub    $0x24,%esp
   151ce:	8b 45 0c             	mov    0xc(%ebp),%eax
   151d1:	88 45 e4             	mov    %al,-0x1c(%ebp)
    int state = irq_enter_protection();
   151d4:	e8 a3 dd ff ff       	call   12f7c <irq_enter_protection>
   151d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (fifo->count >= fifo->size)
   151dc:	8b 45 08             	mov    0x8(%ebp),%eax
   151df:	8b 50 10             	mov    0x10(%eax),%edx
   151e2:	8b 45 08             	mov    0x8(%ebp),%eax
   151e5:	8b 40 04             	mov    0x4(%eax),%eax
   151e8:	39 c2                	cmp    %eax,%edx
   151ea:	7c 16                	jl     15202 <tty_fifo_put+0x3b>
    {
        irq_leave_protection(state);
   151ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151ef:	83 ec 0c             	sub    $0xc,%esp
   151f2:	50                   	push   %eax
   151f3:	e8 9c dd ff ff       	call   12f94 <irq_leave_protection>
   151f8:	83 c4 10             	add    $0x10,%esp
        return -1;
   151fb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15200:	eb 5a                	jmp    1525c <tty_fifo_put+0x95>
    }

    fifo->buf[fifo->write++] = c;
   15202:	8b 45 08             	mov    0x8(%ebp),%eax
   15205:	8b 18                	mov    (%eax),%ebx
   15207:	8b 45 08             	mov    0x8(%ebp),%eax
   1520a:	8b 40 0c             	mov    0xc(%eax),%eax
   1520d:	8d 48 01             	lea    0x1(%eax),%ecx
   15210:	8b 55 08             	mov    0x8(%ebp),%edx
   15213:	89 4a 0c             	mov    %ecx,0xc(%edx)
   15216:	8d 14 03             	lea    (%ebx,%eax,1),%edx
   15219:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   1521d:	88 02                	mov    %al,(%edx)
    if (fifo->write >= fifo->size)
   1521f:	8b 45 08             	mov    0x8(%ebp),%eax
   15222:	8b 50 0c             	mov    0xc(%eax),%edx
   15225:	8b 45 08             	mov    0x8(%ebp),%eax
   15228:	8b 40 04             	mov    0x4(%eax),%eax
   1522b:	39 c2                	cmp    %eax,%edx
   1522d:	7c 0a                	jl     15239 <tty_fifo_put+0x72>
    {
        fifo->write = 0;
   1522f:	8b 45 08             	mov    0x8(%ebp),%eax
   15232:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    }
    fifo->count++;
   15239:	8b 45 08             	mov    0x8(%ebp),%eax
   1523c:	8b 40 10             	mov    0x10(%eax),%eax
   1523f:	8d 50 01             	lea    0x1(%eax),%edx
   15242:	8b 45 08             	mov    0x8(%ebp),%eax
   15245:	89 50 10             	mov    %edx,0x10(%eax)
    irq_leave_protection(state);
   15248:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1524b:	83 ec 0c             	sub    $0xc,%esp
   1524e:	50                   	push   %eax
   1524f:	e8 40 dd ff ff       	call   12f94 <irq_leave_protection>
   15254:	83 c4 10             	add    $0x10,%esp
    return 0;
   15257:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1525c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1525f:	c9                   	leave  
   15260:	c3                   	ret    

00015261 <tty_fifo_get>:
/**
 * @brief 取一字节数据
 */
int tty_fifo_get(tty_fifo_t *fifo, char *c)
{
   15261:	55                   	push   %ebp
   15262:	89 e5                	mov    %esp,%ebp
   15264:	53                   	push   %ebx
   15265:	83 ec 14             	sub    $0x14,%esp
    int state = irq_enter_protection();
   15268:	e8 0f dd ff ff       	call   12f7c <irq_enter_protection>
   1526d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (fifo->count <= 0)
   15270:	8b 45 08             	mov    0x8(%ebp),%eax
   15273:	8b 40 10             	mov    0x10(%eax),%eax
   15276:	85 c0                	test   %eax,%eax
   15278:	7f 16                	jg     15290 <tty_fifo_get+0x2f>
    {
        irq_leave_protection(state);
   1527a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1527d:	83 ec 0c             	sub    $0xc,%esp
   15280:	50                   	push   %eax
   15281:	e8 0e dd ff ff       	call   12f94 <irq_leave_protection>
   15286:	83 c4 10             	add    $0x10,%esp
        return -1;
   15289:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1528e:	eb 5b                	jmp    152eb <tty_fifo_get+0x8a>
    }

    *c = fifo->buf[fifo->read++];
   15290:	8b 45 08             	mov    0x8(%ebp),%eax
   15293:	8b 18                	mov    (%eax),%ebx
   15295:	8b 45 08             	mov    0x8(%ebp),%eax
   15298:	8b 40 08             	mov    0x8(%eax),%eax
   1529b:	8d 48 01             	lea    0x1(%eax),%ecx
   1529e:	8b 55 08             	mov    0x8(%ebp),%edx
   152a1:	89 4a 08             	mov    %ecx,0x8(%edx)
   152a4:	01 d8                	add    %ebx,%eax
   152a6:	0f b6 10             	movzbl (%eax),%edx
   152a9:	8b 45 0c             	mov    0xc(%ebp),%eax
   152ac:	88 10                	mov    %dl,(%eax)
    if (fifo->read >= fifo->size)
   152ae:	8b 45 08             	mov    0x8(%ebp),%eax
   152b1:	8b 50 08             	mov    0x8(%eax),%edx
   152b4:	8b 45 08             	mov    0x8(%ebp),%eax
   152b7:	8b 40 04             	mov    0x4(%eax),%eax
   152ba:	39 c2                	cmp    %eax,%edx
   152bc:	7c 0a                	jl     152c8 <tty_fifo_get+0x67>
    {
        fifo->read = 0;
   152be:	8b 45 08             	mov    0x8(%ebp),%eax
   152c1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    }
    fifo->count--;
   152c8:	8b 45 08             	mov    0x8(%ebp),%eax
   152cb:	8b 40 10             	mov    0x10(%eax),%eax
   152ce:	8d 50 ff             	lea    -0x1(%eax),%edx
   152d1:	8b 45 08             	mov    0x8(%ebp),%eax
   152d4:	89 50 10             	mov    %edx,0x10(%eax)
    irq_leave_protection(state);
   152d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   152da:	83 ec 0c             	sub    $0xc,%esp
   152dd:	50                   	push   %eax
   152de:	e8 b1 dc ff ff       	call   12f94 <irq_leave_protection>
   152e3:	83 c4 10             	add    $0x10,%esp
    return 0;
   152e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   152eb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   152ee:	c9                   	leave  
   152ef:	c3                   	ret    

000152f0 <tty_control>:

int tty_control(device_t *dev, int cmd, int arg0, int arg1)
{
   152f0:	55                   	push   %ebp
   152f1:	89 e5                	mov    %esp,%ebp
    return 0;
   152f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
   152f8:	5d                   	pop    %ebp
   152f9:	c3                   	ret    

000152fa <tty_close>:
void tty_close(device_t *dev)
{
   152fa:	55                   	push   %ebp
   152fb:	89 e5                	mov    %esp,%ebp
    return;
   152fd:	90                   	nop
}
   152fe:	5d                   	pop    %ebp
   152ff:	c3                   	ret    

00015300 <tty_in>:

void tty_in(char key)
{
   15300:	55                   	push   %ebp
   15301:	89 e5                	mov    %esp,%ebp
   15303:	83 ec 28             	sub    $0x28,%esp
   15306:	8b 45 08             	mov    0x8(%ebp),%eax
   15309:	88 45 e4             	mov    %al,-0x1c(%ebp)
    tty_t *tty = tty_devs + curr_tty;
   1530c:	a1 e0 88 03 00       	mov    0x388e0,%eax
   15311:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   15317:	05 40 66 03 00       	add    $0x36640,%eax
   1531c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (sem_count(&tty->isem) >= TTY_IFIFO_SIZE)
   1531f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15322:	05 38 04 00 00       	add    $0x438,%eax
   15327:	83 ec 0c             	sub    $0xc,%esp
   1532a:	50                   	push   %eax
   1532b:	e8 ce 12 00 00       	call   165fe <sem_count>
   15330:	83 c4 10             	add    $0x10,%esp
   15333:	3d ff 01 00 00       	cmp    $0x1ff,%eax
   15338:	7f 30                	jg     1536a <tty_in+0x6a>
    {
        return;
    }
    tty_fifo_put(&tty->ififo, key);
   1533a:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
   1533e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15341:	81 c2 24 04 00 00    	add    $0x424,%edx
   15347:	83 ec 08             	sub    $0x8,%esp
   1534a:	50                   	push   %eax
   1534b:	52                   	push   %edx
   1534c:	e8 76 fe ff ff       	call   151c7 <tty_fifo_put>
   15351:	83 c4 10             	add    $0x10,%esp
    sem_signal(&tty->isem);
   15354:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15357:	05 38 04 00 00       	add    $0x438,%eax
   1535c:	83 ec 0c             	sub    $0xc,%esp
   1535f:	50                   	push   %eax
   15360:	e8 15 12 00 00       	call   1657a <sem_signal>
   15365:	83 c4 10             	add    $0x10,%esp
   15368:	eb 01                	jmp    1536b <tty_in+0x6b>
        return;
   1536a:	90                   	nop
}
   1536b:	c9                   	leave  
   1536c:	c3                   	ret    

0001536d <tty_select>:

/**
 * @brief 选择tty
 */
void tty_select(int index)
{
   1536d:	55                   	push   %ebp
   1536e:	89 e5                	mov    %esp,%ebp
   15370:	83 ec 08             	sub    $0x8,%esp
    if (index != curr_tty)
   15373:	a1 e0 88 03 00       	mov    0x388e0,%eax
   15378:	39 45 08             	cmp    %eax,0x8(%ebp)
   1537b:	74 16                	je     15393 <tty_select+0x26>
    {
        console_select(index);
   1537d:	83 ec 0c             	sub    $0xc,%esp
   15380:	ff 75 08             	pushl  0x8(%ebp)
   15383:	e8 45 e7 ff ff       	call   13acd <console_select>
   15388:	83 c4 10             	add    $0x10,%esp
        curr_tty = index;
   1538b:	8b 45 08             	mov    0x8(%ebp),%eax
   1538e:	a3 e0 88 03 00       	mov    %eax,0x388e0
    }
}
   15393:	90                   	nop
   15394:	c9                   	leave  
   15395:	c3                   	ret    

00015396 <list_node_prev>:
{
   15396:	55                   	push   %ebp
   15397:	89 e5                	mov    %esp,%ebp
    return node->prev;
   15399:	8b 45 08             	mov    0x8(%ebp),%eax
   1539c:	8b 40 04             	mov    0x4(%eax),%eax
}
   1539f:	5d                   	pop    %ebp
   153a0:	c3                   	ret    

000153a1 <list_node_next>:
{
   153a1:	55                   	push   %ebp
   153a2:	89 e5                	mov    %esp,%ebp
    return node->next;
   153a4:	8b 45 08             	mov    0x8(%ebp),%eax
   153a7:	8b 00                	mov    (%eax),%eax
}
   153a9:	5d                   	pop    %ebp
   153aa:	c3                   	ret    

000153ab <devfs_mount>:
        .name = "tty",
        .dev_type = DEV_TTY,
        .file_type = FILE_TTY,
    }};
int devfs_mount(fs_t *fs, int major, int minor)
{
   153ab:	55                   	push   %ebp
   153ac:	89 e5                	mov    %esp,%ebp
    fs->type = FS_DEVFS;
   153ae:	8b 45 08             	mov    0x8(%ebp),%eax
   153b1:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%eax)
   153b8:	00 00 00 
}
   153bb:	90                   	nop
   153bc:	5d                   	pop    %ebp
   153bd:	c3                   	ret    

000153be <devfs_unmount>:
/**
 * @brief 卸载指定的设备
 * @param fs 
 */
int devfs_unmount (fs_t * fs) {
   153be:	55                   	push   %ebp
   153bf:	89 e5                	mov    %esp,%ebp
    return 0;
   153c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
   153c6:	5d                   	pop    %ebp
   153c7:	c3                   	ret    

000153c8 <devfs_open>:

/**
 * @brief 打开指定的设备以进行读写
 */
int devfs_open(fs_t *fs, const char *path, file_t *file)
{
   153c8:	55                   	push   %ebp
   153c9:	89 e5                	mov    %esp,%ebp
   153cb:	83 ec 28             	sub    $0x28,%esp
    // 遍历所有支持的设备类型列表，根据path中的路径，找到相应的设备类型
    for (int i = 0; i < sizeof(devfs_type_list) / sizeof(devfs_type_list[0]); i++) {
   153ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   153d5:	e9 04 01 00 00       	jmp    154de <devfs_open+0x116>
        devfs_type_t * type = devfs_type_list + i;
   153da:	8b 55 f4             	mov    -0xc(%ebp),%edx
   153dd:	89 d0                	mov    %edx,%eax
   153df:	01 c0                	add    %eax,%eax
   153e1:	01 d0                	add    %edx,%eax
   153e3:	c1 e0 02             	shl    $0x2,%eax
   153e6:	05 e0 90 01 00       	add    $0x190e0,%eax
   153eb:	89 45 f0             	mov    %eax,-0x10(%ebp)

        // 查找相同的名称，然后从中提取后续部分，转换成字符串
        int type_name_len = kernel_strlen(type->name);
   153ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
   153f1:	8b 00                	mov    (%eax),%eax
   153f3:	83 ec 0c             	sub    $0xc,%esp
   153f6:	50                   	push   %eax
   153f7:	e8 a3 15 00 00       	call   1699f <kernel_strlen>
   153fc:	83 c4 10             	add    $0x10,%esp
   153ff:	89 45 ec             	mov    %eax,-0x14(%ebp)

        // 如果存在挂载点路径，则跳过该路径，取下级子目录
        if (kernel_strncmp(path, type->name, type_name_len) == 0) {
   15402:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15405:	8b 00                	mov    (%eax),%eax
   15407:	83 ec 04             	sub    $0x4,%esp
   1540a:	ff 75 ec             	pushl  -0x14(%ebp)
   1540d:	50                   	push   %eax
   1540e:	ff 75 0c             	pushl  0xc(%ebp)
   15411:	e8 0b 15 00 00       	call   16921 <kernel_strncmp>
   15416:	83 c4 10             	add    $0x10,%esp
   15419:	85 c0                	test   %eax,%eax
   1541b:	0f 85 b9 00 00 00    	jne    154da <devfs_open+0x112>
            int minor;

            // 转换得到设备子序号
            if ((kernel_strlen(path) > type_name_len) && (path_to_num((char *)(path + type_name_len), &minor)) < 0) {
   15421:	83 ec 0c             	sub    $0xc,%esp
   15424:	ff 75 0c             	pushl  0xc(%ebp)
   15427:	e8 73 15 00 00       	call   1699f <kernel_strlen>
   1542c:	83 c4 10             	add    $0x10,%esp
   1542f:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   15432:	7d 34                	jge    15468 <devfs_open+0xa0>
   15434:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15437:	8b 45 0c             	mov    0xc(%ebp),%eax
   1543a:	01 c2                	add    %eax,%edx
   1543c:	83 ec 08             	sub    $0x8,%esp
   1543f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   15442:	50                   	push   %eax
   15443:	52                   	push   %edx
   15444:	e8 9f 02 00 00       	call   156e8 <path_to_num>
   15449:	83 c4 10             	add    $0x10,%esp
   1544c:	85 c0                	test   %eax,%eax
   1544e:	79 18                	jns    15468 <devfs_open+0xa0>
                log_printf("Get device num failed. %s", path);
   15450:	83 ec 08             	sub    $0x8,%esp
   15453:	ff 75 0c             	pushl  0xc(%ebp)
   15456:	68 de 80 01 00       	push   $0x180de
   1545b:	e8 9f 1b 00 00       	call   16fff <log_printf>
   15460:	83 c4 10             	add    $0x10,%esp
                break;
   15463:	e9 80 00 00 00       	jmp    154e8 <devfs_open+0x120>
            }

            // 打开设备
            int dev_id = dev_open(type->dev_type, minor, (void *)0);
   15468:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1546b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1546e:	8b 40 04             	mov    0x4(%eax),%eax
   15471:	83 ec 04             	sub    $0x4,%esp
   15474:	6a 00                	push   $0x0
   15476:	52                   	push   %edx
   15477:	50                   	push   %eax
   15478:	e8 08 e7 ff ff       	call   13b85 <dev_open>
   1547d:	83 c4 10             	add    $0x10,%esp
   15480:	89 45 e8             	mov    %eax,-0x18(%ebp)
            if (dev_id < 0) {
   15483:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15487:	79 16                	jns    1549f <devfs_open+0xd7>
                log_printf("Open device failed:%s", path);
   15489:	83 ec 08             	sub    $0x8,%esp
   1548c:	ff 75 0c             	pushl  0xc(%ebp)
   1548f:	68 f8 80 01 00       	push   $0x180f8
   15494:	e8 66 1b 00 00       	call   16fff <log_printf>
   15499:	83 c4 10             	add    $0x10,%esp
                break;
   1549c:	90                   	nop
   1549d:	eb 49                	jmp    154e8 <devfs_open+0x120>
            }

            // 纪录所在的设备号
            file->dev_id = dev_id;
   1549f:	8b 45 10             	mov    0x10(%ebp),%eax
   154a2:	8b 55 e8             	mov    -0x18(%ebp),%edx
   154a5:	89 50 2c             	mov    %edx,0x2c(%eax)
            file->fs = fs;
   154a8:	8b 45 10             	mov    0x10(%ebp),%eax
   154ab:	8b 55 08             	mov    0x8(%ebp),%edx
   154ae:	89 50 38             	mov    %edx,0x38(%eax)
            file->pos = 0;
   154b1:	8b 45 10             	mov    0x10(%ebp),%eax
   154b4:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
            file->size = 0;
   154bb:	8b 45 10             	mov    0x10(%ebp),%eax
   154be:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
            file->type = type->file_type;
   154c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   154c8:	8b 40 08             	mov    0x8(%eax),%eax
   154cb:	89 c2                	mov    %eax,%edx
   154cd:	8b 45 10             	mov    0x10(%ebp),%eax
   154d0:	89 50 20             	mov    %edx,0x20(%eax)
            return 0;
   154d3:	b8 00 00 00 00       	mov    $0x0,%eax
   154d8:	eb 13                	jmp    154ed <devfs_open+0x125>
    for (int i = 0; i < sizeof(devfs_type_list) / sizeof(devfs_type_list[0]); i++) {
   154da:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   154de:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   154e2:	0f 84 f2 fe ff ff    	je     153da <devfs_open+0x12>
        }
    }

    return -1;
   154e8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   154ed:	c9                   	leave  
   154ee:	c3                   	ret    

000154ef <devfs_write>:

int devfs_write(char *buf, int size, file_t *file)
{
   154ef:	55                   	push   %ebp
   154f0:	89 e5                	mov    %esp,%ebp
   154f2:	83 ec 08             	sub    $0x8,%esp
    return dev_write(file->dev_id, file->pos, buf, size);
   154f5:	8b 45 10             	mov    0x10(%ebp),%eax
   154f8:	8b 50 30             	mov    0x30(%eax),%edx
   154fb:	8b 45 10             	mov    0x10(%ebp),%eax
   154fe:	8b 40 2c             	mov    0x2c(%eax),%eax
   15501:	ff 75 0c             	pushl  0xc(%ebp)
   15504:	ff 75 08             	pushl  0x8(%ebp)
   15507:	52                   	push   %edx
   15508:	50                   	push   %eax
   15509:	e8 4e e8 ff ff       	call   13d5c <dev_write>
   1550e:	83 c4 10             	add    $0x10,%esp
}
   15511:	c9                   	leave  
   15512:	c3                   	ret    

00015513 <devfs_read>:

int devfs_read(char *buf, int size, file_t *file)
{
   15513:	55                   	push   %ebp
   15514:	89 e5                	mov    %esp,%ebp
   15516:	83 ec 08             	sub    $0x8,%esp
    return dev_read(file->dev_id, file->pos, buf, size);
   15519:	8b 45 10             	mov    0x10(%ebp),%eax
   1551c:	8b 50 30             	mov    0x30(%eax),%edx
   1551f:	8b 45 10             	mov    0x10(%ebp),%eax
   15522:	8b 40 2c             	mov    0x2c(%eax),%eax
   15525:	ff 75 0c             	pushl  0xc(%ebp)
   15528:	ff 75 08             	pushl  0x8(%ebp)
   1552b:	52                   	push   %edx
   1552c:	50                   	push   %eax
   1552d:	e8 de e7 ff ff       	call   13d10 <dev_read>
   15532:	83 c4 10             	add    $0x10,%esp
    // fs->type = FS_DEVFS;
}
   15535:	c9                   	leave  
   15536:	c3                   	ret    

00015537 <devfs_close>:

void devfs_close(file_t *file)
{
   15537:	55                   	push   %ebp
   15538:	89 e5                	mov    %esp,%ebp
   1553a:	83 ec 08             	sub    $0x8,%esp
    return dev_close(file->dev_id);
   1553d:	8b 45 08             	mov    0x8(%ebp),%eax
   15540:	8b 40 2c             	mov    0x2c(%eax),%eax
   15543:	83 ec 0c             	sub    $0xc,%esp
   15546:	50                   	push   %eax
   15547:	e8 a8 e8 ff ff       	call   13df4 <dev_close>
   1554c:	83 c4 10             	add    $0x10,%esp
}
   1554f:	c9                   	leave  
   15550:	c3                   	ret    

00015551 <devfs_seek>:

int devfs_seek(file_t *file, uint32_t offset, int dir)
{
   15551:	55                   	push   %ebp
   15552:	89 e5                	mov    %esp,%ebp
    // fs->type = FS_DEVFS
    return -1;
   15554:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   15559:	5d                   	pop    %ebp
   1555a:	c3                   	ret    

0001555b <devfs_stat>:

int devfs_stat(file_t *file, struct stat *st)
{
   1555b:	55                   	push   %ebp
   1555c:	89 e5                	mov    %esp,%ebp
    // fs->type = FS_DEVFS;
    return -1;
   1555e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   15563:	5d                   	pop    %ebp
   15564:	c3                   	ret    

00015565 <list_node_prev>:
{
   15565:	55                   	push   %ebp
   15566:	89 e5                	mov    %esp,%ebp
    return node->prev;
   15568:	8b 45 08             	mov    0x8(%ebp),%eax
   1556b:	8b 40 04             	mov    0x4(%eax),%eax
}
   1556e:	5d                   	pop    %ebp
   1556f:	c3                   	ret    

00015570 <list_node_next>:
{
   15570:	55                   	push   %ebp
   15571:	89 e5                	mov    %esp,%ebp
    return node->next;
   15573:	8b 45 08             	mov    0x8(%ebp),%eax
   15576:	8b 00                	mov    (%eax),%eax
}
   15578:	5d                   	pop    %ebp
   15579:	c3                   	ret    

0001557a <file_alloc>:

/**
 * @brief 分配一个文件描述符
 */
file_t *file_alloc(void)
{
   1557a:	55                   	push   %ebp
   1557b:	89 e5                	mov    %esp,%ebp
   1557d:	83 ec 18             	sub    $0x18,%esp
    file_t *file = (file_t *)0;
   15580:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    mutex_lock(&file_alloc_mutex);
   15587:	83 ec 0c             	sub    $0xc,%esp
   1558a:	68 00 69 05 00       	push   $0x56900
   1558f:	e8 df 0d 00 00       	call   16373 <mutex_lock>
   15594:	83 c4 10             	add    $0x10,%esp

    for (int i = 0; i < FILE_TABLE_SIZE; i++)
   15597:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1559e:	eb 40                	jmp    155e0 <file_alloc+0x66>
    {
        file_t *p_file = file_table + i;
   155a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   155a3:	6b c0 3c             	imul   $0x3c,%eax,%eax
   155a6:	05 00 89 03 00       	add    $0x38900,%eax
   155ab:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (p_file->ref == 0)
   155ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
   155b1:	8b 40 28             	mov    0x28(%eax),%eax
   155b4:	85 c0                	test   %eax,%eax
   155b6:	75 24                	jne    155dc <file_alloc+0x62>
        {
            kernel_memset((void *)p_file, 0, sizeof(file_t));
   155b8:	83 ec 04             	sub    $0x4,%esp
   155bb:	6a 3c                	push   $0x3c
   155bd:	6a 00                	push   $0x0
   155bf:	ff 75 ec             	pushl  -0x14(%ebp)
   155c2:	e8 5c 14 00 00       	call   16a23 <kernel_memset>
   155c7:	83 c4 10             	add    $0x10,%esp
            p_file->ref = 1;
   155ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
   155cd:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
            file = p_file;
   155d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   155d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
   155da:	eb 0d                	jmp    155e9 <file_alloc+0x6f>
    for (int i = 0; i < FILE_TABLE_SIZE; i++)
   155dc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   155e0:	81 7d f0 ff 07 00 00 	cmpl   $0x7ff,-0x10(%ebp)
   155e7:	7e b7                	jle    155a0 <file_alloc+0x26>
        }
    }

    mutex_unlock(&file_alloc_mutex);
   155e9:	83 ec 0c             	sub    $0xc,%esp
   155ec:	68 00 69 05 00       	push   $0x56900
   155f1:	e8 14 0e 00 00       	call   1640a <mutex_unlock>
   155f6:	83 c4 10             	add    $0x10,%esp
    return file;
   155f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   155fc:	c9                   	leave  
   155fd:	c3                   	ret    

000155fe <file_free>:

void file_free(file_t *file)
{
   155fe:	55                   	push   %ebp
   155ff:	89 e5                	mov    %esp,%ebp
   15601:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&file_alloc_mutex);
   15604:	83 ec 0c             	sub    $0xc,%esp
   15607:	68 00 69 05 00       	push   $0x56900
   1560c:	e8 62 0d 00 00       	call   16373 <mutex_lock>
   15611:	83 c4 10             	add    $0x10,%esp
    if (file->ref > 0)
   15614:	8b 45 08             	mov    0x8(%ebp),%eax
   15617:	8b 40 28             	mov    0x28(%eax),%eax
   1561a:	85 c0                	test   %eax,%eax
   1561c:	7e 0f                	jle    1562d <file_free+0x2f>
    {
        file->ref--;
   1561e:	8b 45 08             	mov    0x8(%ebp),%eax
   15621:	8b 40 28             	mov    0x28(%eax),%eax
   15624:	8d 50 ff             	lea    -0x1(%eax),%edx
   15627:	8b 45 08             	mov    0x8(%ebp),%eax
   1562a:	89 50 28             	mov    %edx,0x28(%eax)
    }
    mutex_unlock(&file_alloc_mutex);
   1562d:	83 ec 0c             	sub    $0xc,%esp
   15630:	68 00 69 05 00       	push   $0x56900
   15635:	e8 d0 0d 00 00       	call   1640a <mutex_unlock>
   1563a:	83 c4 10             	add    $0x10,%esp
}
   1563d:	90                   	nop
   1563e:	c9                   	leave  
   1563f:	c3                   	ret    

00015640 <file_table_init>:

void file_table_init(void)
{
   15640:	55                   	push   %ebp
   15641:	89 e5                	mov    %esp,%ebp
   15643:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&file_alloc_mutex);
   15646:	83 ec 0c             	sub    $0xc,%esp
   15649:	68 00 69 05 00       	push   $0x56900
   1564e:	e8 f2 0c 00 00       	call   16345 <mutex_init>
   15653:	83 c4 10             	add    $0x10,%esp
    kernel_memset((void *)&file_table, 0, sizeof(file_table));
   15656:	83 ec 04             	sub    $0x4,%esp
   15659:	68 00 e0 01 00       	push   $0x1e000
   1565e:	6a 00                	push   $0x0
   15660:	68 00 89 03 00       	push   $0x38900
   15665:	e8 b9 13 00 00       	call   16a23 <kernel_memset>
   1566a:	83 c4 10             	add    $0x10,%esp
}
   1566d:	90                   	nop
   1566e:	c9                   	leave  
   1566f:	c3                   	ret    

00015670 <file_inc_ref>:

void file_inc_ref(file_t *file)
{
   15670:	55                   	push   %ebp
   15671:	89 e5                	mov    %esp,%ebp
   15673:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&file_alloc_mutex);
   15676:	83 ec 0c             	sub    $0xc,%esp
   15679:	68 00 69 05 00       	push   $0x56900
   1567e:	e8 f0 0c 00 00       	call   16373 <mutex_lock>
   15683:	83 c4 10             	add    $0x10,%esp
    file->ref++;
   15686:	8b 45 08             	mov    0x8(%ebp),%eax
   15689:	8b 40 28             	mov    0x28(%eax),%eax
   1568c:	8d 50 01             	lea    0x1(%eax),%edx
   1568f:	8b 45 08             	mov    0x8(%ebp),%eax
   15692:	89 50 28             	mov    %edx,0x28(%eax)
    mutex_unlock(&file_alloc_mutex);
   15695:	83 ec 0c             	sub    $0xc,%esp
   15698:	68 00 69 05 00       	push   $0x56900
   1569d:	e8 68 0d 00 00       	call   1640a <mutex_unlock>
   156a2:	83 c4 10             	add    $0x10,%esp
   156a5:	90                   	nop
   156a6:	c9                   	leave  
   156a7:	c3                   	ret    

000156a8 <list_node_prev>:
{
   156a8:	55                   	push   %ebp
   156a9:	89 e5                	mov    %esp,%ebp
    return node->prev;
   156ab:	8b 45 08             	mov    0x8(%ebp),%eax
   156ae:	8b 40 04             	mov    0x4(%eax),%eax
}
   156b1:	5d                   	pop    %ebp
   156b2:	c3                   	ret    

000156b3 <list_node_next>:
{
   156b3:	55                   	push   %ebp
   156b4:	89 e5                	mov    %esp,%ebp
    return node->next;
   156b6:	8b 45 08             	mov    0x8(%ebp),%eax
   156b9:	8b 00                	mov    (%eax),%eax
}
   156bb:	5d                   	pop    %ebp
   156bc:	c3                   	ret    

000156bd <list_first>:
{
   156bd:	55                   	push   %ebp
   156be:	89 e5                	mov    %esp,%ebp
    return list->first;
   156c0:	8b 45 08             	mov    0x8(%ebp),%eax
   156c3:	8b 00                	mov    (%eax),%eax
}
   156c5:	5d                   	pop    %ebp
   156c6:	c3                   	ret    

000156c7 <is_path_valid>:

/**
 * @brief 检查路径是否正常
 */
static int is_path_valid(const char *path)
{
   156c7:	55                   	push   %ebp
   156c8:	89 e5                	mov    %esp,%ebp
    if ((path == (const char *)0) || (path[0] == '\0'))
   156ca:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   156ce:	74 0a                	je     156da <is_path_valid+0x13>
   156d0:	8b 45 08             	mov    0x8(%ebp),%eax
   156d3:	0f b6 00             	movzbl (%eax),%eax
   156d6:	84 c0                	test   %al,%al
   156d8:	75 07                	jne    156e1 <is_path_valid+0x1a>
    {
        return 0;
   156da:	b8 00 00 00 00       	mov    $0x0,%eax
   156df:	eb 05                	jmp    156e6 <is_path_valid+0x1f>
    }

    return 1;
   156e1:	b8 01 00 00 00       	mov    $0x1,%eax
}
   156e6:	5d                   	pop    %ebp
   156e7:	c3                   	ret    

000156e8 <path_to_num>:

int path_to_num(char *path, int *num)
{
   156e8:	55                   	push   %ebp
   156e9:	89 e5                	mov    %esp,%ebp
   156eb:	83 ec 10             	sub    $0x10,%esp
    int n = 0;
   156ee:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    const char *c = path;
   156f5:	8b 45 08             	mov    0x8(%ebp),%eax
   156f8:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while (*c)
   156fb:	eb 23                	jmp    15720 <path_to_num+0x38>
    {
        n = n * 10 + (*c - '0');
   156fd:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15700:	89 d0                	mov    %edx,%eax
   15702:	c1 e0 02             	shl    $0x2,%eax
   15705:	01 d0                	add    %edx,%eax
   15707:	01 c0                	add    %eax,%eax
   15709:	89 c2                	mov    %eax,%edx
   1570b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1570e:	0f b6 00             	movzbl (%eax),%eax
   15711:	0f be c0             	movsbl %al,%eax
   15714:	83 e8 30             	sub    $0x30,%eax
   15717:	01 d0                	add    %edx,%eax
   15719:	89 45 fc             	mov    %eax,-0x4(%ebp)
        c++;
   1571c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while (*c)
   15720:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15723:	0f b6 00             	movzbl (%eax),%eax
   15726:	84 c0                	test   %al,%al
   15728:	75 d3                	jne    156fd <path_to_num+0x15>
    }
    *num = n;
   1572a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1572d:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15730:	89 10                	mov    %edx,(%eax)
    return 0;
   15732:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15737:	c9                   	leave  
   15738:	c3                   	ret    

00015739 <path_next_child>:

const char *path_next_child(const char *path)
{
   15739:	55                   	push   %ebp
   1573a:	89 e5                	mov    %esp,%ebp
   1573c:	83 ec 10             	sub    $0x10,%esp
    const char *c = path;
   1573f:	8b 45 08             	mov    0x8(%ebp),%eax
   15742:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (*c++ == '/')
   15745:	90                   	nop
   15746:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15749:	8d 50 01             	lea    0x1(%eax),%edx
   1574c:	89 55 fc             	mov    %edx,-0x4(%ebp)
   1574f:	0f b6 00             	movzbl (%eax),%eax
   15752:	3c 2f                	cmp    $0x2f,%al
   15754:	74 f0                	je     15746 <path_next_child+0xd>
    {
        ;
    }

    while (*c++ != '/')
   15756:	90                   	nop
   15757:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1575a:	8d 50 01             	lea    0x1(%eax),%edx
   1575d:	89 55 fc             	mov    %edx,-0x4(%ebp)
   15760:	0f b6 00             	movzbl (%eax),%eax
   15763:	3c 2f                	cmp    $0x2f,%al
   15765:	75 f0                	jne    15757 <path_next_child+0x1e>
    {
        ;
    }
    return *c ? c : (const char *)0;
   15767:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1576a:	0f b6 00             	movzbl (%eax),%eax
   1576d:	84 c0                	test   %al,%al
   1576f:	74 05                	je     15776 <path_next_child+0x3d>
   15771:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15774:	eb 05                	jmp    1577b <path_next_child+0x42>
   15776:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1577b:	c9                   	leave  
   1577c:	c3                   	ret    

0001577d <path_begin_with>:
 * @brief 比较路径是否相同
 * @param path 路径
 * @param str 字符串
 */
int path_begin_with(const char *path, const char *str)
{
   1577d:	55                   	push   %ebp
   1577e:	89 e5                	mov    %esp,%ebp
   15780:	83 ec 10             	sub    $0x10,%esp
    const char *s1 = path, *s2 = str;
   15783:	8b 45 08             	mov    0x8(%ebp),%eax
   15786:	89 45 fc             	mov    %eax,-0x4(%ebp)
   15789:	8b 45 0c             	mov    0xc(%ebp),%eax
   1578c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while (*s1 && *s2 && *s1 == *s2)
   1578f:	eb 08                	jmp    15799 <path_begin_with+0x1c>
    {
        s1++;
   15791:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        s2++;
   15795:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while (*s1 && *s2 && *s1 == *s2)
   15799:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1579c:	0f b6 00             	movzbl (%eax),%eax
   1579f:	84 c0                	test   %al,%al
   157a1:	74 1a                	je     157bd <path_begin_with+0x40>
   157a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   157a6:	0f b6 00             	movzbl (%eax),%eax
   157a9:	84 c0                	test   %al,%al
   157ab:	74 10                	je     157bd <path_begin_with+0x40>
   157ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
   157b0:	0f b6 10             	movzbl (%eax),%edx
   157b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   157b6:	0f b6 00             	movzbl (%eax),%eax
   157b9:	38 c2                	cmp    %al,%dl
   157bb:	74 d4                	je     15791 <path_begin_with+0x14>
    }

    return *s2 == '\0';
   157bd:	8b 45 f8             	mov    -0x8(%ebp),%eax
   157c0:	0f b6 00             	movzbl (%eax),%eax
   157c3:	84 c0                	test   %al,%al
   157c5:	0f 94 c0             	sete   %al
   157c8:	0f b6 c0             	movzbl %al,%eax
}
   157cb:	c9                   	leave  
   157cc:	c3                   	ret    

000157cd <fs_protect>:

// 互斥锁
static void fs_protect(fs_t *fs)
{
   157cd:	55                   	push   %ebp
   157ce:	89 e5                	mov    %esp,%ebp
   157d0:	83 ec 08             	sub    $0x8,%esp
    if (fs->mutex)
   157d3:	8b 45 08             	mov    0x8(%ebp),%eax
   157d6:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
   157dc:	85 c0                	test   %eax,%eax
   157de:	74 15                	je     157f5 <fs_protect+0x28>
    {
        mutex_lock(fs->mutex);
   157e0:	8b 45 08             	mov    0x8(%ebp),%eax
   157e3:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
   157e9:	83 ec 0c             	sub    $0xc,%esp
   157ec:	50                   	push   %eax
   157ed:	e8 81 0b 00 00       	call   16373 <mutex_lock>
   157f2:	83 c4 10             	add    $0x10,%esp
    }
}
   157f5:	90                   	nop
   157f6:	c9                   	leave  
   157f7:	c3                   	ret    

000157f8 <fs_unprotect>:
static void fs_unprotect(fs_t *fs)
{
   157f8:	55                   	push   %ebp
   157f9:	89 e5                	mov    %esp,%ebp
   157fb:	83 ec 08             	sub    $0x8,%esp
    if (fs->mutex)
   157fe:	8b 45 08             	mov    0x8(%ebp),%eax
   15801:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
   15807:	85 c0                	test   %eax,%eax
   15809:	74 15                	je     15820 <fs_unprotect+0x28>
    {
        mutex_unlock(fs->mutex);
   1580b:	8b 45 08             	mov    0x8(%ebp),%eax
   1580e:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
   15814:	83 ec 0c             	sub    $0xc,%esp
   15817:	50                   	push   %eax
   15818:	e8 ed 0b 00 00       	call   1640a <mutex_unlock>
   1581d:	83 c4 10             	add    $0x10,%esp
    }
}
   15820:	90                   	nop
   15821:	c9                   	leave  
   15822:	c3                   	ret    

00015823 <is_fd_bad>:

static int is_fd_bad(int fd)
{
   15823:	55                   	push   %ebp
   15824:	89 e5                	mov    %esp,%ebp
    if ((fd < 0) && (fd >= TASK_OFILE_NR))
   15826:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1582a:	79 0d                	jns    15839 <is_fd_bad+0x16>
   1582c:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   15830:	7e 07                	jle    15839 <is_fd_bad+0x16>
    {
        return 1;
   15832:	b8 01 00 00 00       	mov    $0x1,%eax
   15837:	eb 05                	jmp    1583e <is_fd_bad+0x1b>
    }
    return 0;
   15839:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1583e:	5d                   	pop    %ebp
   1583f:	c3                   	ret    

00015840 <sys_open>:
 * @param name 文件名
 * @param flags 文件标志
 *
 */
int sys_open(const char *name, int flags, ...)
{
   15840:	55                   	push   %ebp
   15841:	89 e5                	mov    %esp,%ebp
   15843:	83 ec 28             	sub    $0x28,%esp

    if (kernel_strncmp(name, "/shell.elf", 4) == 0)
   15846:	83 ec 04             	sub    $0x4,%esp
   15849:	6a 04                	push   $0x4
   1584b:	68 10 81 01 00       	push   $0x18110
   15850:	ff 75 08             	pushl  0x8(%ebp)
   15853:	e8 c9 10 00 00       	call   16921 <kernel_strncmp>
   15858:	83 c4 10             	add    $0x10,%esp
   1585b:	85 c0                	test   %eax,%eax
   1585d:	75 42                	jne    158a1 <sys_open+0x61>
    {
        int dev_id = dev_open(DEV_DISK,0xa0,(void *)0);
   1585f:	83 ec 04             	sub    $0x4,%esp
   15862:	6a 00                	push   $0x0
   15864:	68 a0 00 00 00       	push   $0xa0
   15869:	6a 02                	push   $0x2
   1586b:	e8 15 e3 ff ff       	call   13b85 <dev_open>
   15870:	83 c4 10             	add    $0x10,%esp
   15873:	89 45 dc             	mov    %eax,-0x24(%ebp)
        dev_read(dev_id,5000,(uint8_t *)TEMP_ADDR,80);
   15876:	6a 50                	push   $0x50
   15878:	68 00 00 80 00       	push   $0x800000
   1587d:	68 88 13 00 00       	push   $0x1388
   15882:	ff 75 dc             	pushl  -0x24(%ebp)
   15885:	e8 86 e4 ff ff       	call   13d10 <dev_read>
   1588a:	83 c4 10             	add    $0x10,%esp
        // read_disk(5000, 80, (uint8_t *)TEMP_ADDR);
        temp_pos = (uint8_t *)TEMP_ADDR;
   1588d:	c7 05 64 7e 05 00 00 	movl   $0x800000,0x57e64
   15894:	00 80 00 
        return TEMP_FILE_ID;
   15897:	b8 64 00 00 00       	mov    $0x64,%eax
   1589c:	e9 90 01 00 00       	jmp    15a31 <sys_open+0x1f1>
    }

    file_t *file = file_alloc();
   158a1:	e8 d4 fc ff ff       	call   1557a <file_alloc>
   158a6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (!file)
   158a9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   158ad:	75 15                	jne    158c4 <sys_open+0x84>
    {
        log_printf("No free file\n");
   158af:	83 ec 0c             	sub    $0xc,%esp
   158b2:	68 1b 81 01 00       	push   $0x1811b
   158b7:	e8 43 17 00 00       	call   16fff <log_printf>
   158bc:	83 c4 10             	add    $0x10,%esp
        goto sys_open_err;
   158bf:	e9 40 01 00 00       	jmp    15a04 <sys_open+0x1c4>
    }
    int fd = -1;
   158c4:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)

    fd = task_alloc_fd(file);
   158cb:	83 ec 0c             	sub    $0xc,%esp
   158ce:	ff 75 e8             	pushl  -0x18(%ebp)
   158d1:	e8 4c b7 ff ff       	call   11022 <task_alloc_fd>
   158d6:	83 c4 10             	add    $0x10,%esp
   158d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (fd < 0)
   158dc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   158e0:	79 15                	jns    158f7 <sys_open+0xb7>
    {
        log_printf("No free fd\n");
   158e2:	83 ec 0c             	sub    $0xc,%esp
   158e5:	68 29 81 01 00       	push   $0x18129
   158ea:	e8 10 17 00 00       	call   16fff <log_printf>
   158ef:	83 c4 10             	add    $0x10,%esp
        goto sys_open_err;
   158f2:	e9 0d 01 00 00       	jmp    15a04 <sys_open+0x1c4>
    }

    fs_t *fs = (fs_t *)0;
   158f7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    list_node_t *node = list_first(&mounted_list);
   158fe:	83 ec 0c             	sub    $0xc,%esp
   15901:	68 20 69 05 00       	push   $0x56920
   15906:	e8 b2 fd ff ff       	call   156bd <list_first>
   1590b:	83 c4 10             	add    $0x10,%esp
   1590e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while (node)
   15911:	eb 47                	jmp    1595a <sys_open+0x11a>
    {
        fs_t *curr = list_node_parent(node, fs_t, node);
   15913:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   15917:	74 0a                	je     15923 <sys_open+0xe3>
   15919:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1591c:	2d 10 02 00 00       	sub    $0x210,%eax
   15921:	eb 05                	jmp    15928 <sys_open+0xe8>
   15923:	b8 00 00 00 00       	mov    $0x0,%eax
   15928:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (path_begin_with(name, curr->mount_point))
   1592b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1592e:	83 ec 08             	sub    $0x8,%esp
   15931:	50                   	push   %eax
   15932:	ff 75 08             	pushl  0x8(%ebp)
   15935:	e8 43 fe ff ff       	call   1577d <path_begin_with>
   1593a:	83 c4 10             	add    $0x10,%esp
   1593d:	85 c0                	test   %eax,%eax
   1593f:	74 08                	je     15949 <sys_open+0x109>
        {
            fs = curr;
   15941:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15944:	89 45 f0             	mov    %eax,-0x10(%ebp)
            break;
   15947:	eb 17                	jmp    15960 <sys_open+0x120>
        }
        node = list_node_next(node);
   15949:	83 ec 0c             	sub    $0xc,%esp
   1594c:	ff 75 ec             	pushl  -0x14(%ebp)
   1594f:	e8 5f fd ff ff       	call   156b3 <list_node_next>
   15954:	83 c4 10             	add    $0x10,%esp
   15957:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while (node)
   1595a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1595e:	75 b3                	jne    15913 <sys_open+0xd3>
    }

    if (fs)
   15960:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   15964:	74 11                	je     15977 <sys_open+0x137>
    {
        name = path_next_child(name);
   15966:	83 ec 0c             	sub    $0xc,%esp
   15969:	ff 75 08             	pushl  0x8(%ebp)
   1596c:	e8 c8 fd ff ff       	call   15739 <path_next_child>
   15971:	83 c4 10             	add    $0x10,%esp
   15974:	89 45 08             	mov    %eax,0x8(%ebp)
    }
    else
    {
    }
    file->mode = flags;
   15977:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1597a:	8b 55 0c             	mov    0xc(%ebp),%edx
   1597d:	89 50 34             	mov    %edx,0x34(%eax)
    file->fs = fs;
   15980:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15983:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15986:	89 50 38             	mov    %edx,0x38(%eax)
    kernel_strncpy(file->file_name, name, FILE_NAME_SIZE);
   15989:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1598c:	83 ec 04             	sub    $0x4,%esp
   1598f:	6a 20                	push   $0x20
   15991:	ff 75 08             	pushl  0x8(%ebp)
   15994:	50                   	push   %eax
   15995:	e8 17 0f 00 00       	call   168b1 <kernel_strncpy>
   1599a:	83 c4 10             	add    $0x10,%esp
    fs_protect(fs);
   1599d:	83 ec 0c             	sub    $0xc,%esp
   159a0:	ff 75 f0             	pushl  -0x10(%ebp)
   159a3:	e8 25 fe ff ff       	call   157cd <fs_protect>
   159a8:	83 c4 10             	add    $0x10,%esp
    int err = fs->op->open(fs, name, file);
   159ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
   159ae:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   159b4:	8b 40 08             	mov    0x8(%eax),%eax
   159b7:	83 ec 04             	sub    $0x4,%esp
   159ba:	ff 75 e8             	pushl  -0x18(%ebp)
   159bd:	ff 75 08             	pushl  0x8(%ebp)
   159c0:	ff 75 f0             	pushl  -0x10(%ebp)
   159c3:	ff d0                	call   *%eax
   159c5:	83 c4 10             	add    $0x10,%esp
   159c8:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (err < 0)
   159cb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   159cf:	79 20                	jns    159f1 <sys_open+0x1b1>
    {
        fs_unprotect(fs);
   159d1:	83 ec 0c             	sub    $0xc,%esp
   159d4:	ff 75 f0             	pushl  -0x10(%ebp)
   159d7:	e8 1c fe ff ff       	call   157f8 <fs_unprotect>
   159dc:	83 c4 10             	add    $0x10,%esp
        log_printf("open failed");
   159df:	83 ec 0c             	sub    $0xc,%esp
   159e2:	68 35 81 01 00       	push   $0x18135
   159e7:	e8 13 16 00 00       	call   16fff <log_printf>
   159ec:	83 c4 10             	add    $0x10,%esp
        goto sys_open_err;
   159ef:	eb 13                	jmp    15a04 <sys_open+0x1c4>
    }
    fs_unprotect(fs);
   159f1:	83 ec 0c             	sub    $0xc,%esp
   159f4:	ff 75 f0             	pushl  -0x10(%ebp)
   159f7:	e8 fc fd ff ff       	call   157f8 <fs_unprotect>
   159fc:	83 c4 10             	add    $0x10,%esp
    return fd;
   159ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a02:	eb 2d                	jmp    15a31 <sys_open+0x1f1>
sys_open_err:
    if (file)
   15a04:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15a08:	74 0e                	je     15a18 <sys_open+0x1d8>
    {
        file_free(file);
   15a0a:	83 ec 0c             	sub    $0xc,%esp
   15a0d:	ff 75 e8             	pushl  -0x18(%ebp)
   15a10:	e8 e9 fb ff ff       	call   155fe <file_free>
   15a15:	83 c4 10             	add    $0x10,%esp
    }
    if (fd >= 0)
   15a18:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15a1c:	78 0e                	js     15a2c <sys_open+0x1ec>
    {
        task_remove_fd(fd);
   15a1e:	83 ec 0c             	sub    $0xc,%esp
   15a21:	ff 75 f4             	pushl  -0xc(%ebp)
   15a24:	e8 4c b6 ff ff       	call   11075 <task_remove_fd>
   15a29:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   15a2c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   15a31:	c9                   	leave  
   15a32:	c3                   	ret    

00015a33 <sys_read>:
 * @param file 文件id
 * @param ptr 缓冲区
 * @param len 长度
 */
int sys_read(int file, char *ptr, int len)
{
   15a33:	55                   	push   %ebp
   15a34:	89 e5                	mov    %esp,%ebp
   15a36:	83 ec 18             	sub    $0x18,%esp
    if (file == TEMP_FILE_ID)
   15a39:	83 7d 08 64          	cmpl   $0x64,0x8(%ebp)
   15a3d:	75 2f                	jne    15a6e <sys_read+0x3b>
    {
        kernel_memcpy(ptr, temp_pos, len);
   15a3f:	a1 64 7e 05 00       	mov    0x57e64,%eax
   15a44:	83 ec 04             	sub    $0x4,%esp
   15a47:	ff 75 10             	pushl  0x10(%ebp)
   15a4a:	50                   	push   %eax
   15a4b:	ff 75 0c             	pushl  0xc(%ebp)
   15a4e:	e8 81 0f 00 00       	call   169d4 <kernel_memcpy>
   15a53:	83 c4 10             	add    $0x10,%esp
        temp_pos += len;
   15a56:	8b 15 64 7e 05 00    	mov    0x57e64,%edx
   15a5c:	8b 45 10             	mov    0x10(%ebp),%eax
   15a5f:	01 d0                	add    %edx,%eax
   15a61:	a3 64 7e 05 00       	mov    %eax,0x57e64
        return len;
   15a66:	8b 45 10             	mov    0x10(%ebp),%eax
   15a69:	e9 c0 00 00 00       	jmp    15b2e <sys_read+0xfb>
    }
    if (is_fd_bad(file) || !ptr || !len)
   15a6e:	83 ec 0c             	sub    $0xc,%esp
   15a71:	ff 75 08             	pushl  0x8(%ebp)
   15a74:	e8 aa fd ff ff       	call   15823 <is_fd_bad>
   15a79:	83 c4 10             	add    $0x10,%esp
   15a7c:	85 c0                	test   %eax,%eax
   15a7e:	75 0c                	jne    15a8c <sys_read+0x59>
   15a80:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   15a84:	74 06                	je     15a8c <sys_read+0x59>
   15a86:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   15a8a:	75 0a                	jne    15a96 <sys_read+0x63>
    {
        return 0;
   15a8c:	b8 00 00 00 00       	mov    $0x0,%eax
   15a91:	e9 98 00 00 00       	jmp    15b2e <sys_read+0xfb>
    }
    file_t *p_file = task_file(file);
   15a96:	83 ec 0c             	sub    $0xc,%esp
   15a99:	ff 75 08             	pushl  0x8(%ebp)
   15a9c:	e8 02 b6 ff ff       	call   110a3 <task_file>
   15aa1:	83 c4 10             	add    $0x10,%esp
   15aa4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!p_file)
   15aa7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15aab:	75 17                	jne    15ac4 <sys_read+0x91>
    {
        log_printf("No file");
   15aad:	83 ec 0c             	sub    $0xc,%esp
   15ab0:	68 41 81 01 00       	push   $0x18141
   15ab5:	e8 45 15 00 00       	call   16fff <log_printf>
   15aba:	83 c4 10             	add    $0x10,%esp
        return -1;
   15abd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15ac2:	eb 6a                	jmp    15b2e <sys_read+0xfb>
    }
    if (p_file->mode == O_WRONLY)
   15ac4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ac7:	8b 40 34             	mov    0x34(%eax),%eax
   15aca:	83 f8 01             	cmp    $0x1,%eax
   15acd:	75 17                	jne    15ae6 <sys_read+0xb3>
    {
        log_printf("file is write only");
   15acf:	83 ec 0c             	sub    $0xc,%esp
   15ad2:	68 49 81 01 00       	push   $0x18149
   15ad7:	e8 23 15 00 00       	call   16fff <log_printf>
   15adc:	83 c4 10             	add    $0x10,%esp
        return -1;
   15adf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15ae4:	eb 48                	jmp    15b2e <sys_read+0xfb>
    }
    fs_t *fs = p_file->fs;
   15ae6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ae9:	8b 40 38             	mov    0x38(%eax),%eax
   15aec:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fs_protect(fs);
   15aef:	83 ec 0c             	sub    $0xc,%esp
   15af2:	ff 75 f0             	pushl  -0x10(%ebp)
   15af5:	e8 d3 fc ff ff       	call   157cd <fs_protect>
   15afa:	83 c4 10             	add    $0x10,%esp
    int err = fs->op->read(ptr, len, p_file);
   15afd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b00:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   15b06:	8b 40 10             	mov    0x10(%eax),%eax
   15b09:	83 ec 04             	sub    $0x4,%esp
   15b0c:	ff 75 f4             	pushl  -0xc(%ebp)
   15b0f:	ff 75 10             	pushl  0x10(%ebp)
   15b12:	ff 75 0c             	pushl  0xc(%ebp)
   15b15:	ff d0                	call   *%eax
   15b17:	83 c4 10             	add    $0x10,%esp
   15b1a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    fs_unprotect(fs);
   15b1d:	83 ec 0c             	sub    $0xc,%esp
   15b20:	ff 75 f0             	pushl  -0x10(%ebp)
   15b23:	e8 d0 fc ff ff       	call   157f8 <fs_unprotect>
   15b28:	83 c4 10             	add    $0x10,%esp
    return err;
   15b2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
   15b2e:	c9                   	leave  
   15b2f:	c3                   	ret    

00015b30 <sys_write>:
 * @param file 文件id
 * @param ptr 缓冲区
 * @param len 长度
 */
int sys_write(int file, char *ptr, int len)
{
   15b30:	55                   	push   %ebp
   15b31:	89 e5                	mov    %esp,%ebp
   15b33:	83 ec 18             	sub    $0x18,%esp
    if (is_fd_bad(file) || !ptr || !len)
   15b36:	ff 75 08             	pushl  0x8(%ebp)
   15b39:	e8 e5 fc ff ff       	call   15823 <is_fd_bad>
   15b3e:	83 c4 04             	add    $0x4,%esp
   15b41:	85 c0                	test   %eax,%eax
   15b43:	75 0c                	jne    15b51 <sys_write+0x21>
   15b45:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   15b49:	74 06                	je     15b51 <sys_write+0x21>
   15b4b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   15b4f:	75 0a                	jne    15b5b <sys_write+0x2b>
    {
        return 0;
   15b51:	b8 00 00 00 00       	mov    $0x0,%eax
   15b56:	e9 97 00 00 00       	jmp    15bf2 <sys_write+0xc2>
    }
    file_t *p_file = task_file(file);
   15b5b:	83 ec 0c             	sub    $0xc,%esp
   15b5e:	ff 75 08             	pushl  0x8(%ebp)
   15b61:	e8 3d b5 ff ff       	call   110a3 <task_file>
   15b66:	83 c4 10             	add    $0x10,%esp
   15b69:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!p_file)
   15b6c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15b70:	75 17                	jne    15b89 <sys_write+0x59>
    {
        log_printf("No file");
   15b72:	83 ec 0c             	sub    $0xc,%esp
   15b75:	68 41 81 01 00       	push   $0x18141
   15b7a:	e8 80 14 00 00       	call   16fff <log_printf>
   15b7f:	83 c4 10             	add    $0x10,%esp
        return -1;
   15b82:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15b87:	eb 69                	jmp    15bf2 <sys_write+0xc2>
    }
    if (p_file->mode == O_RDONLY)
   15b89:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b8c:	8b 40 34             	mov    0x34(%eax),%eax
   15b8f:	85 c0                	test   %eax,%eax
   15b91:	75 17                	jne    15baa <sys_write+0x7a>
    {
        log_printf("file is read only");
   15b93:	83 ec 0c             	sub    $0xc,%esp
   15b96:	68 5c 81 01 00       	push   $0x1815c
   15b9b:	e8 5f 14 00 00       	call   16fff <log_printf>
   15ba0:	83 c4 10             	add    $0x10,%esp
        return -1;
   15ba3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15ba8:	eb 48                	jmp    15bf2 <sys_write+0xc2>
    }
    fs_t *fs = p_file->fs;
   15baa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bad:	8b 40 38             	mov    0x38(%eax),%eax
   15bb0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fs_protect(fs);
   15bb3:	83 ec 0c             	sub    $0xc,%esp
   15bb6:	ff 75 f0             	pushl  -0x10(%ebp)
   15bb9:	e8 0f fc ff ff       	call   157cd <fs_protect>
   15bbe:	83 c4 10             	add    $0x10,%esp
    int err = fs->op->write(ptr, len, p_file);
   15bc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15bc4:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   15bca:	8b 40 0c             	mov    0xc(%eax),%eax
   15bcd:	83 ec 04             	sub    $0x4,%esp
   15bd0:	ff 75 f4             	pushl  -0xc(%ebp)
   15bd3:	ff 75 10             	pushl  0x10(%ebp)
   15bd6:	ff 75 0c             	pushl  0xc(%ebp)
   15bd9:	ff d0                	call   *%eax
   15bdb:	83 c4 10             	add    $0x10,%esp
   15bde:	89 45 ec             	mov    %eax,-0x14(%ebp)
    fs_unprotect(fs);
   15be1:	83 ec 0c             	sub    $0xc,%esp
   15be4:	ff 75 f0             	pushl  -0x10(%ebp)
   15be7:	e8 0c fc ff ff       	call   157f8 <fs_unprotect>
   15bec:	83 c4 10             	add    $0x10,%esp
    return err;
   15bef:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
   15bf2:	c9                   	leave  
   15bf3:	c3                   	ret    

00015bf4 <sys_lseek>:
 * @param file 文件id
 * @param ptr 指针
 * @param dir
 */
int sys_lseek(int file, int ptr, int dir)
{
   15bf4:	55                   	push   %ebp
   15bf5:	89 e5                	mov    %esp,%ebp
   15bf7:	83 ec 18             	sub    $0x18,%esp
    if (file == TEMP_FILE_ID)
   15bfa:	83 7d 08 64          	cmpl   $0x64,0x8(%ebp)
   15bfe:	75 17                	jne    15c17 <sys_lseek+0x23>
    {
        temp_pos = (uint8_t *)(TEMP_ADDR + ptr);
   15c00:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c03:	05 00 00 80 00       	add    $0x800000,%eax
   15c08:	a3 64 7e 05 00       	mov    %eax,0x57e64
        return 0;
   15c0d:	b8 00 00 00 00       	mov    $0x0,%eax
   15c12:	e9 8d 00 00 00       	jmp    15ca4 <sys_lseek+0xb0>
    }
    if (is_fd_bad(file))
   15c17:	ff 75 08             	pushl  0x8(%ebp)
   15c1a:	e8 04 fc ff ff       	call   15823 <is_fd_bad>
   15c1f:	83 c4 04             	add    $0x4,%esp
   15c22:	85 c0                	test   %eax,%eax
   15c24:	74 07                	je     15c2d <sys_lseek+0x39>
    {
        return 0;
   15c26:	b8 00 00 00 00       	mov    $0x0,%eax
   15c2b:	eb 77                	jmp    15ca4 <sys_lseek+0xb0>
    }
    file_t *p_file = task_file(file);
   15c2d:	83 ec 0c             	sub    $0xc,%esp
   15c30:	ff 75 08             	pushl  0x8(%ebp)
   15c33:	e8 6b b4 ff ff       	call   110a3 <task_file>
   15c38:	83 c4 10             	add    $0x10,%esp
   15c3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!p_file)
   15c3e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15c42:	75 17                	jne    15c5b <sys_lseek+0x67>
    {
        log_printf("No file");
   15c44:	83 ec 0c             	sub    $0xc,%esp
   15c47:	68 41 81 01 00       	push   $0x18141
   15c4c:	e8 ae 13 00 00       	call   16fff <log_printf>
   15c51:	83 c4 10             	add    $0x10,%esp
        return -1;
   15c54:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15c59:	eb 49                	jmp    15ca4 <sys_lseek+0xb0>
    }

    fs_t *fs = p_file->fs;
   15c5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c5e:	8b 40 38             	mov    0x38(%eax),%eax
   15c61:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fs_protect(fs);
   15c64:	83 ec 0c             	sub    $0xc,%esp
   15c67:	ff 75 f0             	pushl  -0x10(%ebp)
   15c6a:	e8 5e fb ff ff       	call   157cd <fs_protect>
   15c6f:	83 c4 10             	add    $0x10,%esp
    int err = fs->op->seek(p_file, ptr, dir);
   15c72:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c75:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   15c7b:	8b 40 18             	mov    0x18(%eax),%eax
   15c7e:	8b 55 0c             	mov    0xc(%ebp),%edx
   15c81:	83 ec 04             	sub    $0x4,%esp
   15c84:	ff 75 10             	pushl  0x10(%ebp)
   15c87:	52                   	push   %edx
   15c88:	ff 75 f4             	pushl  -0xc(%ebp)
   15c8b:	ff d0                	call   *%eax
   15c8d:	83 c4 10             	add    $0x10,%esp
   15c90:	89 45 ec             	mov    %eax,-0x14(%ebp)
    fs_unprotect(fs);
   15c93:	83 ec 0c             	sub    $0xc,%esp
   15c96:	ff 75 f0             	pushl  -0x10(%ebp)
   15c99:	e8 5a fb ff ff       	call   157f8 <fs_unprotect>
   15c9e:	83 c4 10             	add    $0x10,%esp
    return err;
   15ca1:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
   15ca4:	c9                   	leave  
   15ca5:	c3                   	ret    

00015ca6 <sys_close>:
/**
 * @brief 关闭文件
 * @param file 文件id
 */
int sys_close(int file)
{
   15ca6:	55                   	push   %ebp
   15ca7:	89 e5                	mov    %esp,%ebp
   15ca9:	83 ec 18             	sub    $0x18,%esp
    if (file == TEMP_FILE_ID)
   15cac:	83 7d 08 64          	cmpl   $0x64,0x8(%ebp)
   15cb0:	75 0a                	jne    15cbc <sys_close+0x16>
    {
        return 0;
   15cb2:	b8 00 00 00 00       	mov    $0x0,%eax
   15cb7:	e9 f4 00 00 00       	jmp    15db0 <sys_close+0x10a>
    }
    if (is_fd_bad(file))
   15cbc:	ff 75 08             	pushl  0x8(%ebp)
   15cbf:	e8 5f fb ff ff       	call   15823 <is_fd_bad>
   15cc4:	83 c4 04             	add    $0x4,%esp
   15cc7:	85 c0                	test   %eax,%eax
   15cc9:	74 1d                	je     15ce8 <sys_close+0x42>
    {
        log_printf("invalid file %d", file);
   15ccb:	83 ec 08             	sub    $0x8,%esp
   15cce:	ff 75 08             	pushl  0x8(%ebp)
   15cd1:	68 6e 81 01 00       	push   $0x1816e
   15cd6:	e8 24 13 00 00       	call   16fff <log_printf>
   15cdb:	83 c4 10             	add    $0x10,%esp
        return 0;
   15cde:	b8 00 00 00 00       	mov    $0x0,%eax
   15ce3:	e9 c8 00 00 00       	jmp    15db0 <sys_close+0x10a>
    }
    file_t *p_file = task_file(file);
   15ce8:	83 ec 0c             	sub    $0xc,%esp
   15ceb:	ff 75 08             	pushl  0x8(%ebp)
   15cee:	e8 b0 b3 ff ff       	call   110a3 <task_file>
   15cf3:	83 c4 10             	add    $0x10,%esp
   15cf6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!p_file)
   15cf9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15cfd:	75 1a                	jne    15d19 <sys_close+0x73>
    {
        log_printf("No file");
   15cff:	83 ec 0c             	sub    $0xc,%esp
   15d02:	68 41 81 01 00       	push   $0x18141
   15d07:	e8 f3 12 00 00       	call   16fff <log_printf>
   15d0c:	83 c4 10             	add    $0x10,%esp
        return -1;
   15d0f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15d14:	e9 97 00 00 00       	jmp    15db0 <sys_close+0x10a>
    }
    ASSERT(p_file->ref > 0);
   15d19:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d1c:	8b 40 28             	mov    0x28(%eax),%eax
   15d1f:	85 c0                	test   %eax,%eax
   15d21:	7f 1c                	jg     15d3f <sys_close+0x99>
   15d23:	68 7e 81 01 00       	push   $0x1817e
   15d28:	68 64 82 01 00       	push   $0x18264
   15d2d:	68 59 01 00 00       	push   $0x159
   15d32:	68 90 81 01 00       	push   $0x18190
   15d37:	e8 ca 0f 00 00       	call   16d06 <pannic>
   15d3c:	83 c4 10             	add    $0x10,%esp

    if (p_file->ref-- == 1)
   15d3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d42:	8b 40 28             	mov    0x28(%eax),%eax
   15d45:	8d 48 ff             	lea    -0x1(%eax),%ecx
   15d48:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15d4b:	89 4a 28             	mov    %ecx,0x28(%edx)
   15d4e:	83 f8 01             	cmp    $0x1,%eax
   15d51:	75 4a                	jne    15d9d <sys_close+0xf7>
    {
        fs_t *fs = p_file->fs;
   15d53:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d56:	8b 40 38             	mov    0x38(%eax),%eax
   15d59:	89 45 f0             	mov    %eax,-0x10(%ebp)
        fs_protect(fs);
   15d5c:	83 ec 0c             	sub    $0xc,%esp
   15d5f:	ff 75 f0             	pushl  -0x10(%ebp)
   15d62:	e8 66 fa ff ff       	call   157cd <fs_protect>
   15d67:	83 c4 10             	add    $0x10,%esp
        fs->op->close(p_file);
   15d6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d6d:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   15d73:	8b 40 14             	mov    0x14(%eax),%eax
   15d76:	83 ec 0c             	sub    $0xc,%esp
   15d79:	ff 75 f4             	pushl  -0xc(%ebp)
   15d7c:	ff d0                	call   *%eax
   15d7e:	83 c4 10             	add    $0x10,%esp
        fs_unprotect(fs);
   15d81:	83 ec 0c             	sub    $0xc,%esp
   15d84:	ff 75 f0             	pushl  -0x10(%ebp)
   15d87:	e8 6c fa ff ff       	call   157f8 <fs_unprotect>
   15d8c:	83 c4 10             	add    $0x10,%esp
        file_free(p_file);
   15d8f:	83 ec 0c             	sub    $0xc,%esp
   15d92:	ff 75 f4             	pushl  -0xc(%ebp)
   15d95:	e8 64 f8 ff ff       	call   155fe <file_free>
   15d9a:	83 c4 10             	add    $0x10,%esp
    }
    task_remove_fd(file);
   15d9d:	83 ec 0c             	sub    $0xc,%esp
   15da0:	ff 75 08             	pushl  0x8(%ebp)
   15da3:	e8 cd b2 ff ff       	call   11075 <task_remove_fd>
   15da8:	83 c4 10             	add    $0x10,%esp
    return 0;
   15dab:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15db0:	c9                   	leave  
   15db1:	c3                   	ret    

00015db2 <sys_isatty>:

int sys_isatty(int file)
{
   15db2:	55                   	push   %ebp
   15db3:	89 e5                	mov    %esp,%ebp
   15db5:	83 ec 18             	sub    $0x18,%esp
    if (is_fd_bad(file))
   15db8:	ff 75 08             	pushl  0x8(%ebp)
   15dbb:	e8 63 fa ff ff       	call   15823 <is_fd_bad>
   15dc0:	83 c4 04             	add    $0x4,%esp
   15dc3:	85 c0                	test   %eax,%eax
   15dc5:	74 07                	je     15dce <sys_isatty+0x1c>
    {
        return 0;
   15dc7:	b8 00 00 00 00       	mov    $0x0,%eax
   15dcc:	eb 3d                	jmp    15e0b <sys_isatty+0x59>
    }
    file_t *p_file = task_file(file);
   15dce:	83 ec 0c             	sub    $0xc,%esp
   15dd1:	ff 75 08             	pushl  0x8(%ebp)
   15dd4:	e8 ca b2 ff ff       	call   110a3 <task_file>
   15dd9:	83 c4 10             	add    $0x10,%esp
   15ddc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!p_file)
   15ddf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15de3:	75 17                	jne    15dfc <sys_isatty+0x4a>
    {
        log_printf("No file");
   15de5:	83 ec 0c             	sub    $0xc,%esp
   15de8:	68 41 81 01 00       	push   $0x18141
   15ded:	e8 0d 12 00 00       	call   16fff <log_printf>
   15df2:	83 c4 10             	add    $0x10,%esp
        return -1;
   15df5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15dfa:	eb 0f                	jmp    15e0b <sys_isatty+0x59>
    }
    return p_file->type == FILE_TTY;
   15dfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15dff:	8b 40 20             	mov    0x20(%eax),%eax
   15e02:	83 f8 01             	cmp    $0x1,%eax
   15e05:	0f 94 c0             	sete   %al
   15e08:	0f b6 c0             	movzbl %al,%eax
}
   15e0b:	c9                   	leave  
   15e0c:	c3                   	ret    

00015e0d <sys_fstat>:

int sys_fstat(int file, struct stat *st)
{
   15e0d:	55                   	push   %ebp
   15e0e:	89 e5                	mov    %esp,%ebp
   15e10:	83 ec 18             	sub    $0x18,%esp
    if (is_fd_bad(file))
   15e13:	ff 75 08             	pushl  0x8(%ebp)
   15e16:	e8 08 fa ff ff       	call   15823 <is_fd_bad>
   15e1b:	83 c4 04             	add    $0x4,%esp
   15e1e:	85 c0                	test   %eax,%eax
   15e20:	74 0a                	je     15e2c <sys_fstat+0x1f>
    {
        return 0;
   15e22:	b8 00 00 00 00       	mov    $0x0,%eax
   15e27:	e9 85 00 00 00       	jmp    15eb1 <sys_fstat+0xa4>
    }
    file_t *p_file = task_file(file);
   15e2c:	83 ec 0c             	sub    $0xc,%esp
   15e2f:	ff 75 08             	pushl  0x8(%ebp)
   15e32:	e8 6c b2 ff ff       	call   110a3 <task_file>
   15e37:	83 c4 10             	add    $0x10,%esp
   15e3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!p_file)
   15e3d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15e41:	75 17                	jne    15e5a <sys_fstat+0x4d>
    {
        log_printf("No file");
   15e43:	83 ec 0c             	sub    $0xc,%esp
   15e46:	68 41 81 01 00       	push   $0x18141
   15e4b:	e8 af 11 00 00       	call   16fff <log_printf>
   15e50:	83 c4 10             	add    $0x10,%esp
        return -1;
   15e53:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15e58:	eb 57                	jmp    15eb1 <sys_fstat+0xa4>
    }
    fs_t *fs = p_file->fs;
   15e5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e5d:	8b 40 38             	mov    0x38(%eax),%eax
   15e60:	89 45 f0             	mov    %eax,-0x10(%ebp)
    kernel_memset((void *)st, 0, sizeof(struct stat));
   15e63:	83 ec 04             	sub    $0x4,%esp
   15e66:	6a 48                	push   $0x48
   15e68:	6a 00                	push   $0x0
   15e6a:	ff 75 0c             	pushl  0xc(%ebp)
   15e6d:	e8 b1 0b 00 00       	call   16a23 <kernel_memset>
   15e72:	83 c4 10             	add    $0x10,%esp
    fs_protect(fs);
   15e75:	83 ec 0c             	sub    $0xc,%esp
   15e78:	ff 75 f0             	pushl  -0x10(%ebp)
   15e7b:	e8 4d f9 ff ff       	call   157cd <fs_protect>
   15e80:	83 c4 10             	add    $0x10,%esp
    int err = fs->op->stat(p_file, st);
   15e83:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e86:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   15e8c:	8b 40 1c             	mov    0x1c(%eax),%eax
   15e8f:	83 ec 08             	sub    $0x8,%esp
   15e92:	ff 75 0c             	pushl  0xc(%ebp)
   15e95:	ff 75 f4             	pushl  -0xc(%ebp)
   15e98:	ff d0                	call   *%eax
   15e9a:	83 c4 10             	add    $0x10,%esp
   15e9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    fs_unprotect(fs);
   15ea0:	83 ec 0c             	sub    $0xc,%esp
   15ea3:	ff 75 f0             	pushl  -0x10(%ebp)
   15ea6:	e8 4d f9 ff ff       	call   157f8 <fs_unprotect>
   15eab:	83 c4 10             	add    $0x10,%esp
    return err;
   15eae:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
   15eb1:	c9                   	leave  
   15eb2:	c3                   	ret    

00015eb3 <sys_dup>:

int sys_dup(int file)
{
   15eb3:	55                   	push   %ebp
   15eb4:	89 e5                	mov    %esp,%ebp
   15eb6:	83 ec 18             	sub    $0x18,%esp
    if (is_fd_bad(file))
   15eb9:	ff 75 08             	pushl  0x8(%ebp)
   15ebc:	e8 62 f9 ff ff       	call   15823 <is_fd_bad>
   15ec1:	83 c4 04             	add    $0x4,%esp
   15ec4:	85 c0                	test   %eax,%eax
   15ec6:	74 1a                	je     15ee2 <sys_dup+0x2f>
    {
        log_printf("invalid file %d\n", file);
   15ec8:	83 ec 08             	sub    $0x8,%esp
   15ecb:	ff 75 08             	pushl  0x8(%ebp)
   15ece:	68 c1 81 01 00       	push   $0x181c1
   15ed3:	e8 27 11 00 00       	call   16fff <log_printf>
   15ed8:	83 c4 10             	add    $0x10,%esp
        return -1;
   15edb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15ee0:	eb 6d                	jmp    15f4f <sys_dup+0x9c>
    }
    file_t *p_file = task_file(file);
   15ee2:	83 ec 0c             	sub    $0xc,%esp
   15ee5:	ff 75 08             	pushl  0x8(%ebp)
   15ee8:	e8 b6 b1 ff ff       	call   110a3 <task_file>
   15eed:	83 c4 10             	add    $0x10,%esp
   15ef0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!p_file)
   15ef3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15ef7:	75 17                	jne    15f10 <sys_dup+0x5d>
    {
        log_printf("No file\n");
   15ef9:	83 ec 0c             	sub    $0xc,%esp
   15efc:	68 d2 81 01 00       	push   $0x181d2
   15f01:	e8 f9 10 00 00       	call   16fff <log_printf>
   15f06:	83 c4 10             	add    $0x10,%esp
        return -1;
   15f09:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15f0e:	eb 3f                	jmp    15f4f <sys_dup+0x9c>
    }

    int fd = task_alloc_fd(p_file);
   15f10:	83 ec 0c             	sub    $0xc,%esp
   15f13:	ff 75 f4             	pushl  -0xc(%ebp)
   15f16:	e8 07 b1 ff ff       	call   11022 <task_alloc_fd>
   15f1b:	83 c4 10             	add    $0x10,%esp
   15f1e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (fd < 0)
   15f21:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   15f25:	79 17                	jns    15f3e <sys_dup+0x8b>
    {
        log_printf("No free fd\n");
   15f27:	83 ec 0c             	sub    $0xc,%esp
   15f2a:	68 29 81 01 00       	push   $0x18129
   15f2f:	e8 cb 10 00 00       	call   16fff <log_printf>
   15f34:	83 c4 10             	add    $0x10,%esp
        return -1;
   15f37:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15f3c:	eb 11                	jmp    15f4f <sys_dup+0x9c>
    }
    else
    {
        file_inc_ref(p_file);
   15f3e:	83 ec 0c             	sub    $0xc,%esp
   15f41:	ff 75 f4             	pushl  -0xc(%ebp)
   15f44:	e8 27 f7 ff ff       	call   15670 <file_inc_ref>
   15f49:	83 c4 10             	add    $0x10,%esp
        return fd;
   15f4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    }
}
   15f4f:	c9                   	leave  
   15f50:	c3                   	ret    

00015f51 <mount_list_init>:

static void mount_list_init()
{
   15f51:	55                   	push   %ebp
   15f52:	89 e5                	mov    %esp,%ebp
   15f54:	83 ec 18             	sub    $0x18,%esp
    list_init(&free_list);
   15f57:	83 ec 0c             	sub    $0xc,%esp
   15f5a:	68 58 7e 05 00       	push   $0x57e58
   15f5f:	e8 73 0e 00 00       	call   16dd7 <list_init>
   15f64:	83 c4 10             	add    $0x10,%esp

    for (int i = 0; i < FS_TABLE_SIZE; i++)
   15f67:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15f6e:	eb 28                	jmp    15f98 <mount_list_init+0x47>
    {
        list_insert_first(&free_list, &fs_table[i].node);
   15f70:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f73:	69 c0 1c 02 00 00    	imul   $0x21c,%eax,%eax
   15f79:	05 10 02 00 00       	add    $0x210,%eax
   15f7e:	05 40 69 05 00       	add    $0x56940,%eax
   15f83:	83 ec 08             	sub    $0x8,%esp
   15f86:	50                   	push   %eax
   15f87:	68 58 7e 05 00       	push   $0x57e58
   15f8c:	e8 6b 0e 00 00       	call   16dfc <list_insert_first>
   15f91:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < FS_TABLE_SIZE; i++)
   15f94:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15f98:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
   15f9c:	7e d2                	jle    15f70 <mount_list_init+0x1f>
    }
    list_init(&mounted_list);
   15f9e:	83 ec 0c             	sub    $0xc,%esp
   15fa1:	68 20 69 05 00       	push   $0x56920
   15fa6:	e8 2c 0e 00 00       	call   16dd7 <list_init>
   15fab:	83 c4 10             	add    $0x10,%esp
}
   15fae:	90                   	nop
   15faf:	c9                   	leave  
   15fb0:	c3                   	ret    

00015fb1 <get_fs_op>:
static fs_op_t *get_fs_op(fs_type_t type, int major)
{
   15fb1:	55                   	push   %ebp
   15fb2:	89 e5                	mov    %esp,%ebp
    switch (type)
   15fb4:	8b 45 08             	mov    0x8(%ebp),%eax
   15fb7:	85 c0                	test   %eax,%eax
   15fb9:	75 07                	jne    15fc2 <get_fs_op+0x11>
    {
    case FS_DEVFS:
        return &(devfs_op);
   15fbb:	b8 00 91 01 00       	mov    $0x19100,%eax
   15fc0:	eb 05                	jmp    15fc7 <get_fs_op+0x16>
    default:
        return (fs_op_t *)0;
   15fc2:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
   15fc7:	5d                   	pop    %ebp
   15fc8:	c3                   	ret    

00015fc9 <mount>:
static fs_t *mount(fs_type_t type, char *mount_point, int dev_major, int dev_minor)
{
   15fc9:	55                   	push   %ebp
   15fca:	89 e5                	mov    %esp,%ebp
   15fcc:	83 ec 28             	sub    $0x28,%esp
    fs_t *fs = (fs_t *)0;
   15fcf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    log_printf("mount file system, name:%s ,dev : %x", mount_point, dev_major);
   15fd6:	83 ec 04             	sub    $0x4,%esp
   15fd9:	ff 75 10             	pushl  0x10(%ebp)
   15fdc:	ff 75 0c             	pushl  0xc(%ebp)
   15fdf:	68 dc 81 01 00       	push   $0x181dc
   15fe4:	e8 16 10 00 00       	call   16fff <log_printf>
   15fe9:	83 c4 10             	add    $0x10,%esp
    list_node_t *curr = list_first(&mounted_list);
   15fec:	83 ec 0c             	sub    $0xc,%esp
   15fef:	68 20 69 05 00       	push   $0x56920
   15ff4:	e8 c4 f6 ff ff       	call   156bd <list_first>
   15ff9:	83 c4 10             	add    $0x10,%esp
   15ffc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while (curr)
   15fff:	eb 59                	jmp    1605a <mount+0x91>
    {
        fs_t *fs = list_node_parent(curr, fs_t, node);
   16001:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   16005:	74 0a                	je     16011 <mount+0x48>
   16007:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1600a:	2d 10 02 00 00       	sub    $0x210,%eax
   1600f:	eb 05                	jmp    16016 <mount+0x4d>
   16011:	b8 00 00 00 00       	mov    $0x0,%eax
   16016:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (kernel_strncmp(fs->mount_point, mount_point, FS_MOUNTP_SIZE) == 0)
   16019:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1601c:	83 ec 04             	sub    $0x4,%esp
   1601f:	68 00 02 00 00       	push   $0x200
   16024:	ff 75 0c             	pushl  0xc(%ebp)
   16027:	50                   	push   %eax
   16028:	e8 f4 08 00 00       	call   16921 <kernel_strncmp>
   1602d:	83 c4 10             	add    $0x10,%esp
   16030:	85 c0                	test   %eax,%eax
   16032:	75 15                	jne    16049 <mount+0x80>
        {
            log_printf("file system already mounted");
   16034:	83 ec 0c             	sub    $0xc,%esp
   16037:	68 01 82 01 00       	push   $0x18201
   1603c:	e8 be 0f 00 00       	call   16fff <log_printf>
   16041:	83 c4 10             	add    $0x10,%esp
            goto mount_failed;
   16044:	e9 11 01 00 00       	jmp    1615a <mount+0x191>
        }
        curr = list_node_next(curr);
   16049:	83 ec 0c             	sub    $0xc,%esp
   1604c:	ff 75 f0             	pushl  -0x10(%ebp)
   1604f:	e8 5f f6 ff ff       	call   156b3 <list_node_next>
   16054:	83 c4 10             	add    $0x10,%esp
   16057:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while (curr)
   1605a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1605e:	75 a1                	jne    16001 <mount+0x38>
    }

    list_node_t *free_node = list_remove_first(&free_list);
   16060:	83 ec 0c             	sub    $0xc,%esp
   16063:	68 58 7e 05 00       	push   $0x57e58
   16068:	e8 52 0e 00 00       	call   16ebf <list_remove_first>
   1606d:	83 c4 10             	add    $0x10,%esp
   16070:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if (!free_node)
   16073:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   16077:	75 15                	jne    1608e <mount+0xc5>
    {
        log_printf("no free fs");
   16079:	83 ec 0c             	sub    $0xc,%esp
   1607c:	68 1d 82 01 00       	push   $0x1821d
   16081:	e8 79 0f 00 00       	call   16fff <log_printf>
   16086:	83 c4 10             	add    $0x10,%esp
        goto mount_failed;
   16089:	e9 cc 00 00 00       	jmp    1615a <mount+0x191>
    }

    fs = list_node_parent(free_node, fs_t, node);
   1608e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   16092:	74 0a                	je     1609e <mount+0xd5>
   16094:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16097:	2d 10 02 00 00       	sub    $0x210,%eax
   1609c:	eb 05                	jmp    160a3 <mount+0xda>
   1609e:	b8 00 00 00 00       	mov    $0x0,%eax
   160a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fs_op_t *op = get_fs_op(type, dev_major);
   160a6:	83 ec 08             	sub    $0x8,%esp
   160a9:	ff 75 10             	pushl  0x10(%ebp)
   160ac:	ff 75 08             	pushl  0x8(%ebp)
   160af:	e8 fd fe ff ff       	call   15fb1 <get_fs_op>
   160b4:	83 c4 10             	add    $0x10,%esp
   160b7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (!op)
   160ba:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   160be:	75 15                	jne    160d5 <mount+0x10c>
    {
        log_printf("no fs op");
   160c0:	83 ec 0c             	sub    $0xc,%esp
   160c3:	68 28 82 01 00       	push   $0x18228
   160c8:	e8 32 0f 00 00       	call   16fff <log_printf>
   160cd:	83 c4 10             	add    $0x10,%esp
        goto mount_failed;
   160d0:	e9 85 00 00 00       	jmp    1615a <mount+0x191>
    }
    kernel_memset((void *)fs, 0, sizeof(fs_t));
   160d5:	83 ec 04             	sub    $0x4,%esp
   160d8:	68 1c 02 00 00       	push   $0x21c
   160dd:	6a 00                	push   $0x0
   160df:	ff 75 f4             	pushl  -0xc(%ebp)
   160e2:	e8 3c 09 00 00       	call   16a23 <kernel_memset>
   160e7:	83 c4 10             	add    $0x10,%esp
    kernel_strncpy(fs->mount_point, mount_point, FS_MOUNTP_SIZE);
   160ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
   160ed:	83 ec 04             	sub    $0x4,%esp
   160f0:	68 00 02 00 00       	push   $0x200
   160f5:	ff 75 0c             	pushl  0xc(%ebp)
   160f8:	50                   	push   %eax
   160f9:	e8 b3 07 00 00       	call   168b1 <kernel_strncpy>
   160fe:	83 c4 10             	add    $0x10,%esp
    fs->op = op;
   16101:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16104:	8b 55 e8             	mov    -0x18(%ebp),%edx
   16107:	89 90 04 02 00 00    	mov    %edx,0x204(%eax)
    if (op->mount(fs, dev_major, dev_minor) < 0)
   1610d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16110:	8b 00                	mov    (%eax),%eax
   16112:	83 ec 04             	sub    $0x4,%esp
   16115:	ff 75 14             	pushl  0x14(%ebp)
   16118:	ff 75 10             	pushl  0x10(%ebp)
   1611b:	ff 75 f4             	pushl  -0xc(%ebp)
   1611e:	ff d0                	call   *%eax
   16120:	83 c4 10             	add    $0x10,%esp
   16123:	85 c0                	test   %eax,%eax
   16125:	79 15                	jns    1613c <mount+0x173>
    {
        log_printf("mount failed %s", mount_point);
   16127:	83 ec 08             	sub    $0x8,%esp
   1612a:	ff 75 0c             	pushl  0xc(%ebp)
   1612d:	68 31 82 01 00       	push   $0x18231
   16132:	e8 c8 0e 00 00       	call   16fff <log_printf>
   16137:	83 c4 10             	add    $0x10,%esp
        goto mount_failed;
   1613a:	eb 1e                	jmp    1615a <mount+0x191>
    }
    list_insert_last(&mounted_list, &fs->node);
   1613c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1613f:	05 10 02 00 00       	add    $0x210,%eax
   16144:	83 ec 08             	sub    $0x8,%esp
   16147:	50                   	push   %eax
   16148:	68 20 69 05 00       	push   $0x56920
   1614d:	e8 0a 0d 00 00       	call   16e5c <list_insert_last>
   16152:	83 c4 10             	add    $0x10,%esp
    return fs;
   16155:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16158:	eb 34                	jmp    1618e <mount+0x1c5>
mount_failed:
    log_printf("mount failed");
   1615a:	83 ec 0c             	sub    $0xc,%esp
   1615d:	68 41 82 01 00       	push   $0x18241
   16162:	e8 98 0e 00 00       	call   16fff <log_printf>
   16167:	83 c4 10             	add    $0x10,%esp
    if (fs)
   1616a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1616e:	74 19                	je     16189 <mount+0x1c0>
    {
        list_insert_first(&free_list, &fs->node);
   16170:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16173:	05 10 02 00 00       	add    $0x210,%eax
   16178:	83 ec 08             	sub    $0x8,%esp
   1617b:	50                   	push   %eax
   1617c:	68 58 7e 05 00       	push   $0x57e58
   16181:	e8 76 0c 00 00       	call   16dfc <list_insert_first>
   16186:	83 c4 10             	add    $0x10,%esp
    }
    return (fs_t *)0;
   16189:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1618e:	c9                   	leave  
   1618f:	c3                   	ret    

00016190 <fs_init>:

void fs_init()
{
   16190:	55                   	push   %ebp
   16191:	89 e5                	mov    %esp,%ebp
   16193:	83 ec 18             	sub    $0x18,%esp
    mount_list_init();
   16196:	e8 b6 fd ff ff       	call   15f51 <mount_list_init>
    file_table_init();
   1619b:	e8 a0 f4 ff ff       	call   15640 <file_table_init>
    // log_printf("fs init done.\n");
    disk_init();
   161a0:	e8 c3 e2 ff ff       	call   14468 <disk_init>

    fs_t *fs = mount(FS_DEVFS, "/dev", 0, 0);
   161a5:	6a 00                	push   $0x0
   161a7:	6a 00                	push   $0x0
   161a9:	68 4e 82 01 00       	push   $0x1824e
   161ae:	6a 00                	push   $0x0
   161b0:	e8 14 fe ff ff       	call   15fc9 <mount>
   161b5:	83 c4 10             	add    $0x10,%esp
   161b8:	89 45 f4             	mov    %eax,-0xc(%ebp)

    ASSERT(fs != (fs_t *)0);
   161bb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   161bf:	75 1c                	jne    161dd <fs_init+0x4d>
   161c1:	68 53 82 01 00       	push   $0x18253
   161c6:	68 70 82 01 00       	push   $0x18270
   161cb:	68 f4 01 00 00       	push   $0x1f4
   161d0:	68 90 81 01 00       	push   $0x18190
   161d5:	e8 2c 0b 00 00       	call   16d06 <pannic>
   161da:	83 c4 10             	add    $0x10,%esp
   161dd:	90                   	nop
   161de:	c9                   	leave  
   161df:	c3                   	ret    

000161e0 <list_node_prev>:
{
   161e0:	55                   	push   %ebp
   161e1:	89 e5                	mov    %esp,%ebp
    return node->prev;
   161e3:	8b 45 08             	mov    0x8(%ebp),%eax
   161e6:	8b 40 04             	mov    0x4(%eax),%eax
}
   161e9:	5d                   	pop    %ebp
   161ea:	c3                   	ret    

000161eb <list_node_next>:
{
   161eb:	55                   	push   %ebp
   161ec:	89 e5                	mov    %esp,%ebp
    return node->next;
   161ee:	8b 45 08             	mov    0x8(%ebp),%eax
   161f1:	8b 00                	mov    (%eax),%eax
}
   161f3:	5d                   	pop    %ebp
   161f4:	c3                   	ret    

000161f5 <kernel_init>:
/**
 * kernel_init - 内核初始化
 * @param boot_info 引导信息
 */
void kernel_init(boot_info_t *boot_info)
{
   161f5:	55                   	push   %ebp
   161f6:	89 e5                	mov    %esp,%ebp
   161f8:	83 ec 08             	sub    $0x8,%esp
    ASSERT(boot_info->ram_region_count != 0);
   161fb:	8b 45 08             	mov    0x8(%ebp),%eax
   161fe:	8b 40 50             	mov    0x50(%eax),%eax
   16201:	85 c0                	test   %eax,%eax
   16203:	75 19                	jne    1621e <kernel_init+0x29>
   16205:	68 78 82 01 00       	push   $0x18278
   1620a:	68 64 83 01 00       	push   $0x18364
   1620f:	6a 1d                	push   $0x1d
   16211:	68 9c 82 01 00       	push   $0x1829c
   16216:	e8 eb 0a 00 00       	call   16d06 <pannic>
   1621b:	83 c4 10             	add    $0x10,%esp
    // ASSERT(3 < 2);
    cpu_init(); // 初始化CPU
   1621e:	e8 06 c4 ff ff       	call   12629 <cpu_init>
    irq_init(); // 初始化中断idt
   16223:	e8 19 ca ff ff       	call   12c41 <irq_init>
    log_init(); // 初始化日志
   16228:	e8 a3 0d 00 00       	call   16fd0 <log_init>

    memory_init(boot_info); // 初始化内存
   1622d:	83 ec 0c             	sub    $0xc,%esp
   16230:	ff 75 08             	pushl  0x8(%ebp)
   16233:	e8 47 a5 ff ff       	call   1077f <memory_init>
   16238:	83 c4 10             	add    $0x10,%esp
    fs_init(); // 初始化文件系统
   1623b:	e8 50 ff ff ff       	call   16190 <fs_init>

    time_init(); // 初始化定时器
   16240:	e8 92 eb ff ff       	call   14dd7 <time_init>

    task_manager_init(); // 初始化任务管理器
   16245:	e8 41 b2 ff ff       	call   1148b <task_manager_init>

    log_printf("init successfully");
   1624a:	83 ec 0c             	sub    $0xc,%esp
   1624d:	68 d1 82 01 00       	push   $0x182d1
   16252:	e8 a8 0d 00 00       	call   16fff <log_printf>
   16257:	83 c4 10             	add    $0x10,%esp
    log_printf("welcome to YesOS , version is 0.0.1");
   1625a:	83 ec 0c             	sub    $0xc,%esp
   1625d:	68 e4 82 01 00       	push   $0x182e4
   16262:	e8 98 0d 00 00       	call   16fff <log_printf>
   16267:	83 c4 10             	add    $0x10,%esp
    log_printf("launch time: %s %s", __DATE__, __TIME__);
   1626a:	83 ec 04             	sub    $0x4,%esp
   1626d:	68 08 83 01 00       	push   $0x18308
   16272:	68 11 83 01 00       	push   $0x18311
   16277:	68 1d 83 01 00       	push   $0x1831d
   1627c:	e8 7e 0d 00 00       	call   16fff <log_printf>
   16281:	83 c4 10             	add    $0x10,%esp

    // for(;;);
}
   16284:	90                   	nop
   16285:	c9                   	leave  
   16286:	c3                   	ret    

00016287 <move_to_first_task>:

/**
 * @brief 移至第一个进程运行
 */
void move_to_first_task(void)
{
   16287:	55                   	push   %ebp
   16288:	89 e5                	mov    %esp,%ebp
   1628a:	56                   	push   %esi
   1628b:	53                   	push   %ebx
   1628c:	83 ec 10             	sub    $0x10,%esp
    task_t *curr = task_current();
   1628f:	e8 78 b4 ff ff       	call   1170c <task_current>
   16294:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ASSERT(curr != 0);
   16297:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1629b:	75 19                	jne    162b6 <move_to_first_task+0x2f>
   1629d:	68 30 83 01 00       	push   $0x18330
   162a2:	68 70 83 01 00       	push   $0x18370
   162a7:	6a 37                	push   $0x37
   162a9:	68 9c 82 01 00       	push   $0x1829c
   162ae:	e8 53 0a 00 00       	call   16d06 <pannic>
   162b3:	83 c4 10             	add    $0x10,%esp

    tss_t *tss = &(curr->tss);
   162b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   162b9:	05 7c 02 00 00       	add    $0x27c,%eax
   162be:	89 45 f0             	mov    %eax,-0x10(%ebp)
        "push %[ss]\n\t"     // SS
        "push %[esp]\n\t"    // ESP
        "push %[eflags]\n\t" // EFLAGS
        "push %[cs]\n\t"     // CS
        "push %[eip]\n\t"    // ip
        "iret\n\t" ::[ss] "r"(tss->ss),
   162c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   162c4:	8b 40 50             	mov    0x50(%eax),%eax
        [esp] "r"(tss->esp), [eflags] "r"(tss->eflags),
   162c7:	8b 55 f0             	mov    -0x10(%ebp),%edx
   162ca:	8b 52 38             	mov    0x38(%edx),%edx
   162cd:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   162d0:	8b 49 24             	mov    0x24(%ecx),%ecx
        [cs] "r"(tss->cs), [eip] "r"(tss->eip));
   162d3:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   162d6:	8b 5b 4c             	mov    0x4c(%ebx),%ebx
   162d9:	8b 75 f0             	mov    -0x10(%ebp),%esi
   162dc:	8b 76 20             	mov    0x20(%esi),%esi
    __asm__ __volatile__(
   162df:	50                   	push   %eax
   162e0:	52                   	push   %edx
   162e1:	51                   	push   %ecx
   162e2:	53                   	push   %ebx
   162e3:	56                   	push   %esi
   162e4:	cf                   	iret   
}
   162e5:	90                   	nop
   162e6:	8d 65 f8             	lea    -0x8(%ebp),%esp
   162e9:	5b                   	pop    %ebx
   162ea:	5e                   	pop    %esi
   162eb:	5d                   	pop    %ebp
   162ec:	c3                   	ret    

000162ed <init_main>:

void init_main()
{
   162ed:	55                   	push   %ebp
   162ee:	89 e5                	mov    %esp,%ebp
   162f0:	83 ec 08             	sub    $0x8,%esp
    // list_test();
    log_printf("Kernel is running...");
   162f3:	83 ec 0c             	sub    $0xc,%esp
   162f6:	68 3a 83 01 00       	push   $0x1833a
   162fb:	e8 ff 0c 00 00       	call   16fff <log_printf>
   16300:	83 c4 10             	add    $0x10,%esp
    log_printf("Version: %s", OS_VERSION);
   16303:	83 ec 08             	sub    $0x8,%esp
   16306:	68 4f 83 01 00       	push   $0x1834f
   1630b:	68 55 83 01 00       	push   $0x18355
   16310:	e8 ea 0c 00 00       	call   16fff <log_printf>
   16315:	83 c4 10             	add    $0x10,%esp
    // int a = 3 / 0;
    task_first_init();
   16318:	e8 55 b2 ff ff       	call   11572 <task_first_init>
    move_to_first_task();
   1631d:	e8 65 ff ff ff       	call   16287 <move_to_first_task>
   16322:	90                   	nop
   16323:	c9                   	leave  
   16324:	c3                   	ret    

00016325 <list_node_prev>:
{
   16325:	55                   	push   %ebp
   16326:	89 e5                	mov    %esp,%ebp
    return node->prev;
   16328:	8b 45 08             	mov    0x8(%ebp),%eax
   1632b:	8b 40 04             	mov    0x4(%eax),%eax
}
   1632e:	5d                   	pop    %ebp
   1632f:	c3                   	ret    

00016330 <list_node_next>:
{
   16330:	55                   	push   %ebp
   16331:	89 e5                	mov    %esp,%ebp
    return node->next;
   16333:	8b 45 08             	mov    0x8(%ebp),%eax
   16336:	8b 00                	mov    (%eax),%eax
}
   16338:	5d                   	pop    %ebp
   16339:	c3                   	ret    

0001633a <list_count>:
{
   1633a:	55                   	push   %ebp
   1633b:	89 e5                	mov    %esp,%ebp
    return list->count;
   1633d:	8b 45 08             	mov    0x8(%ebp),%eax
   16340:	8b 40 08             	mov    0x8(%eax),%eax
}
   16343:	5d                   	pop    %ebp
   16344:	c3                   	ret    

00016345 <mutex_init>:

/**
 * 锁初始化
 */
void mutex_init(mutex_t *mutex)
{
   16345:	55                   	push   %ebp
   16346:	89 e5                	mov    %esp,%ebp
   16348:	83 ec 08             	sub    $0x8,%esp
    mutex->locked_count = 0;
   1634b:	8b 45 08             	mov    0x8(%ebp),%eax
   1634e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    mutex->owner = (task_t *)0;
   16355:	8b 45 08             	mov    0x8(%ebp),%eax
   16358:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    list_init(&mutex->wait_list);
   1635e:	8b 45 08             	mov    0x8(%ebp),%eax
   16361:	83 c0 08             	add    $0x8,%eax
   16364:	83 ec 0c             	sub    $0xc,%esp
   16367:	50                   	push   %eax
   16368:	e8 6a 0a 00 00       	call   16dd7 <list_init>
   1636d:	83 c4 10             	add    $0x10,%esp
}
   16370:	90                   	nop
   16371:	c9                   	leave  
   16372:	c3                   	ret    

00016373 <mutex_lock>:

/**
 * 申请锁
 */
void mutex_lock(mutex_t *mutex)
{
   16373:	55                   	push   %ebp
   16374:	89 e5                	mov    %esp,%ebp
   16376:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   16379:	e8 fe cb ff ff       	call   12f7c <irq_enter_protection>
   1637e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    task_t *curr = task_current();
   16381:	e8 86 b3 ff ff       	call   1170c <task_current>
   16386:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (mutex->locked_count == 0)
   16389:	8b 45 08             	mov    0x8(%ebp),%eax
   1638c:	8b 40 04             	mov    0x4(%eax),%eax
   1638f:	85 c0                	test   %eax,%eax
   16391:	75 14                	jne    163a7 <mutex_lock+0x34>
    {
        // 没有任务占用，占用之
        mutex->locked_count = 1;
   16393:	8b 45 08             	mov    0x8(%ebp),%eax
   16396:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
        mutex->owner = curr;
   1639d:	8b 45 08             	mov    0x8(%ebp),%eax
   163a0:	8b 55 f0             	mov    -0x10(%ebp),%edx
   163a3:	89 10                	mov    %edx,(%eax)
   163a5:	eb 52                	jmp    163f9 <mutex_lock+0x86>
    }
    else if (mutex->owner == curr)
   163a7:	8b 45 08             	mov    0x8(%ebp),%eax
   163aa:	8b 00                	mov    (%eax),%eax
   163ac:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   163af:	75 11                	jne    163c2 <mutex_lock+0x4f>
    {
        // 已经为当前任务所有，只增加计数
        mutex->locked_count++;
   163b1:	8b 45 08             	mov    0x8(%ebp),%eax
   163b4:	8b 40 04             	mov    0x4(%eax),%eax
   163b7:	8d 50 01             	lea    0x1(%eax),%edx
   163ba:	8b 45 08             	mov    0x8(%ebp),%eax
   163bd:	89 50 04             	mov    %edx,0x4(%eax)
   163c0:	eb 37                	jmp    163f9 <mutex_lock+0x86>
    }
    else
    {
        // 有其它任务占用，则进入队列等待
        task_t *curr = task_current();
   163c2:	e8 45 b3 ff ff       	call   1170c <task_current>
   163c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_block(curr);
   163ca:	83 ec 0c             	sub    $0xc,%esp
   163cd:	ff 75 ec             	pushl  -0x14(%ebp)
   163d0:	e8 c7 b2 ff ff       	call   1169c <task_set_block>
   163d5:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&mutex->wait_list, &curr->wait_node);
   163d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   163db:	8d 90 74 02 00 00    	lea    0x274(%eax),%edx
   163e1:	8b 45 08             	mov    0x8(%ebp),%eax
   163e4:	83 c0 08             	add    $0x8,%eax
   163e7:	83 ec 08             	sub    $0x8,%esp
   163ea:	52                   	push   %edx
   163eb:	50                   	push   %eax
   163ec:	e8 6b 0a 00 00       	call   16e5c <list_insert_last>
   163f1:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   163f4:	e8 7e b3 ff ff       	call   11777 <task_dispatch>
    }

    irq_leave_protection(irq_state);
   163f9:	83 ec 0c             	sub    $0xc,%esp
   163fc:	ff 75 f4             	pushl  -0xc(%ebp)
   163ff:	e8 90 cb ff ff       	call   12f94 <irq_leave_protection>
   16404:	83 c4 10             	add    $0x10,%esp
}
   16407:	90                   	nop
   16408:	c9                   	leave  
   16409:	c3                   	ret    

0001640a <mutex_unlock>:

/**
 * 释放锁
 */
void mutex_unlock(mutex_t *mutex)
{
   1640a:	55                   	push   %ebp
   1640b:	89 e5                	mov    %esp,%ebp
   1640d:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   16410:	e8 67 cb ff ff       	call   12f7c <irq_enter_protection>
   16415:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 只有锁的拥有者才能释放锁
    task_t *curr = task_current();
   16418:	e8 ef b2 ff ff       	call   1170c <task_current>
   1641d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (mutex->owner == curr)
   16420:	8b 45 08             	mov    0x8(%ebp),%eax
   16423:	8b 00                	mov    (%eax),%eax
   16425:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   16428:	0f 85 8a 00 00 00    	jne    164b8 <mutex_unlock+0xae>
    {
        if (--mutex->locked_count == 0)
   1642e:	8b 45 08             	mov    0x8(%ebp),%eax
   16431:	8b 40 04             	mov    0x4(%eax),%eax
   16434:	8d 50 ff             	lea    -0x1(%eax),%edx
   16437:	8b 45 08             	mov    0x8(%ebp),%eax
   1643a:	89 50 04             	mov    %edx,0x4(%eax)
   1643d:	8b 45 08             	mov    0x8(%ebp),%eax
   16440:	8b 40 04             	mov    0x4(%eax),%eax
   16443:	85 c0                	test   %eax,%eax
   16445:	75 71                	jne    164b8 <mutex_unlock+0xae>
        {
            // 减到0，释放锁
            mutex->owner = (task_t *)0;
   16447:	8b 45 08             	mov    0x8(%ebp),%eax
   1644a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

            // 如果队列中有任务等待，则立即唤醒并占用锁
            if (list_count(&mutex->wait_list))
   16450:	8b 45 08             	mov    0x8(%ebp),%eax
   16453:	83 c0 08             	add    $0x8,%eax
   16456:	83 ec 0c             	sub    $0xc,%esp
   16459:	50                   	push   %eax
   1645a:	e8 db fe ff ff       	call   1633a <list_count>
   1645f:	83 c4 10             	add    $0x10,%esp
   16462:	85 c0                	test   %eax,%eax
   16464:	74 52                	je     164b8 <mutex_unlock+0xae>
            {
                list_node_t *task_node = list_remove_first(&mutex->wait_list);
   16466:	8b 45 08             	mov    0x8(%ebp),%eax
   16469:	83 c0 08             	add    $0x8,%eax
   1646c:	83 ec 0c             	sub    $0xc,%esp
   1646f:	50                   	push   %eax
   16470:	e8 4a 0a 00 00       	call   16ebf <list_remove_first>
   16475:	83 c4 10             	add    $0x10,%esp
   16478:	89 45 ec             	mov    %eax,-0x14(%ebp)
                task_t *task = list_node_parent(task_node, task_t, wait_node);
   1647b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1647f:	74 0a                	je     1648b <mutex_unlock+0x81>
   16481:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16484:	2d 74 02 00 00       	sub    $0x274,%eax
   16489:	eb 05                	jmp    16490 <mutex_unlock+0x86>
   1648b:	b8 00 00 00 00       	mov    $0x0,%eax
   16490:	89 45 e8             	mov    %eax,-0x18(%ebp)
                task_set_ready(task);
   16493:	83 ec 0c             	sub    $0xc,%esp
   16496:	ff 75 e8             	pushl  -0x18(%ebp)
   16499:	e8 c8 b1 ff ff       	call   11666 <task_set_ready>
   1649e:	83 c4 10             	add    $0x10,%esp

                // 在这里占用，而不是在任务醒后占用，因为可能抢不到
                mutex->locked_count = 1;
   164a1:	8b 45 08             	mov    0x8(%ebp),%eax
   164a4:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
                mutex->owner = task;
   164ab:	8b 45 08             	mov    0x8(%ebp),%eax
   164ae:	8b 55 e8             	mov    -0x18(%ebp),%edx
   164b1:	89 10                	mov    %edx,(%eax)

                task_dispatch();
   164b3:	e8 bf b2 ff ff       	call   11777 <task_dispatch>
            }
        }
    }

    irq_leave_protection(irq_state);
   164b8:	83 ec 0c             	sub    $0xc,%esp
   164bb:	ff 75 f4             	pushl  -0xc(%ebp)
   164be:	e8 d1 ca ff ff       	call   12f94 <irq_leave_protection>
   164c3:	83 c4 10             	add    $0x10,%esp
   164c6:	90                   	nop
   164c7:	c9                   	leave  
   164c8:	c3                   	ret    

000164c9 <list_node_prev>:
{
   164c9:	55                   	push   %ebp
   164ca:	89 e5                	mov    %esp,%ebp
    return node->prev;
   164cc:	8b 45 08             	mov    0x8(%ebp),%eax
   164cf:	8b 40 04             	mov    0x4(%eax),%eax
}
   164d2:	5d                   	pop    %ebp
   164d3:	c3                   	ret    

000164d4 <list_node_next>:
{
   164d4:	55                   	push   %ebp
   164d5:	89 e5                	mov    %esp,%ebp
    return node->next;
   164d7:	8b 45 08             	mov    0x8(%ebp),%eax
   164da:	8b 00                	mov    (%eax),%eax
}
   164dc:	5d                   	pop    %ebp
   164dd:	c3                   	ret    

000164de <list_count>:
{
   164de:	55                   	push   %ebp
   164df:	89 e5                	mov    %esp,%ebp
    return list->count;
   164e1:	8b 45 08             	mov    0x8(%ebp),%eax
   164e4:	8b 40 08             	mov    0x8(%eax),%eax
}
   164e7:	5d                   	pop    %ebp
   164e8:	c3                   	ret    

000164e9 <sem_init>:
#include "cpu/irq.h"
#include "core/task.h"
#include "ipc/sem.h"

void sem_init(sem_t *sem, int count)
{
   164e9:	55                   	push   %ebp
   164ea:	89 e5                	mov    %esp,%ebp
   164ec:	83 ec 08             	sub    $0x8,%esp
    sem->count = count;
   164ef:	8b 45 08             	mov    0x8(%ebp),%eax
   164f2:	8b 55 0c             	mov    0xc(%ebp),%edx
   164f5:	89 10                	mov    %edx,(%eax)
    list_init(&sem->wait_list);
   164f7:	8b 45 08             	mov    0x8(%ebp),%eax
   164fa:	83 c0 04             	add    $0x4,%eax
   164fd:	83 ec 0c             	sub    $0xc,%esp
   16500:	50                   	push   %eax
   16501:	e8 d1 08 00 00       	call   16dd7 <list_init>
   16506:	83 c4 10             	add    $0x10,%esp
}
   16509:	90                   	nop
   1650a:	c9                   	leave  
   1650b:	c3                   	ret    

0001650c <sem_wait>:

void sem_wait(sem_t *sem)
{
   1650c:	55                   	push   %ebp
   1650d:	89 e5                	mov    %esp,%ebp
   1650f:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   16512:	e8 65 ca ff ff       	call   12f7c <irq_enter_protection>
   16517:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (sem->count > 0)
   1651a:	8b 45 08             	mov    0x8(%ebp),%eax
   1651d:	8b 00                	mov    (%eax),%eax
   1651f:	85 c0                	test   %eax,%eax
   16521:	7e 0f                	jle    16532 <sem_wait+0x26>
    {
        sem->count--;
   16523:	8b 45 08             	mov    0x8(%ebp),%eax
   16526:	8b 00                	mov    (%eax),%eax
   16528:	8d 50 ff             	lea    -0x1(%eax),%edx
   1652b:	8b 45 08             	mov    0x8(%ebp),%eax
   1652e:	89 10                	mov    %edx,(%eax)
   16530:	eb 37                	jmp    16569 <sem_wait+0x5d>
    }
    else
    {
        task_t *current_task = task_current();
   16532:	e8 d5 b1 ff ff       	call   1170c <task_current>
   16537:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_set_block(current_task);
   1653a:	83 ec 0c             	sub    $0xc,%esp
   1653d:	ff 75 f0             	pushl  -0x10(%ebp)
   16540:	e8 57 b1 ff ff       	call   1169c <task_set_block>
   16545:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&sem->wait_list, &current_task->wait_node);
   16548:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1654b:	8d 90 74 02 00 00    	lea    0x274(%eax),%edx
   16551:	8b 45 08             	mov    0x8(%ebp),%eax
   16554:	83 c0 04             	add    $0x4,%eax
   16557:	83 ec 08             	sub    $0x8,%esp
   1655a:	52                   	push   %edx
   1655b:	50                   	push   %eax
   1655c:	e8 fb 08 00 00       	call   16e5c <list_insert_last>
   16561:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   16564:	e8 0e b2 ff ff       	call   11777 <task_dispatch>
    }
    irq_leave_protection(state);
   16569:	83 ec 0c             	sub    $0xc,%esp
   1656c:	ff 75 f4             	pushl  -0xc(%ebp)
   1656f:	e8 20 ca ff ff       	call   12f94 <irq_leave_protection>
   16574:	83 c4 10             	add    $0x10,%esp
}
   16577:	90                   	nop
   16578:	c9                   	leave  
   16579:	c3                   	ret    

0001657a <sem_signal>:

/**
 * 释放信号量
 */
void sem_signal(sem_t *sem)
{
   1657a:	55                   	push   %ebp
   1657b:	89 e5                	mov    %esp,%ebp
   1657d:	83 ec 18             	sub    $0x18,%esp
    irq_state_t irq_state = irq_enter_protection();
   16580:	e8 f7 c9 ff ff       	call   12f7c <irq_enter_protection>
   16585:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (list_count(&sem->wait_list))
   16588:	8b 45 08             	mov    0x8(%ebp),%eax
   1658b:	83 c0 04             	add    $0x4,%eax
   1658e:	83 ec 0c             	sub    $0xc,%esp
   16591:	50                   	push   %eax
   16592:	e8 47 ff ff ff       	call   164de <list_count>
   16597:	83 c4 10             	add    $0x10,%esp
   1659a:	85 c0                	test   %eax,%eax
   1659c:	74 42                	je     165e0 <sem_signal+0x66>
    {
        // 有进程等待，则唤醒加入就绪队列
        list_node_t *node = list_remove_first(&sem->wait_list);
   1659e:	8b 45 08             	mov    0x8(%ebp),%eax
   165a1:	83 c0 04             	add    $0x4,%eax
   165a4:	83 ec 0c             	sub    $0xc,%esp
   165a7:	50                   	push   %eax
   165a8:	e8 12 09 00 00       	call   16ebf <list_remove_first>
   165ad:	83 c4 10             	add    $0x10,%esp
   165b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_t *task = list_node_parent(node, task_t, wait_node);
   165b3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   165b7:	74 0a                	je     165c3 <sem_signal+0x49>
   165b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   165bc:	2d 74 02 00 00       	sub    $0x274,%eax
   165c1:	eb 05                	jmp    165c8 <sem_signal+0x4e>
   165c3:	b8 00 00 00 00       	mov    $0x0,%eax
   165c8:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_ready(task);
   165cb:	83 ec 0c             	sub    $0xc,%esp
   165ce:	ff 75 ec             	pushl  -0x14(%ebp)
   165d1:	e8 90 b0 ff ff       	call   11666 <task_set_ready>
   165d6:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   165d9:	e8 99 b1 ff ff       	call   11777 <task_dispatch>
   165de:	eb 0d                	jmp    165ed <sem_signal+0x73>
    }
    else
    {
        sem->count++;
   165e0:	8b 45 08             	mov    0x8(%ebp),%eax
   165e3:	8b 00                	mov    (%eax),%eax
   165e5:	8d 50 01             	lea    0x1(%eax),%edx
   165e8:	8b 45 08             	mov    0x8(%ebp),%eax
   165eb:	89 10                	mov    %edx,(%eax)
    }

    irq_leave_protection(irq_state);
   165ed:	83 ec 0c             	sub    $0xc,%esp
   165f0:	ff 75 f4             	pushl  -0xc(%ebp)
   165f3:	e8 9c c9 ff ff       	call   12f94 <irq_leave_protection>
   165f8:	83 c4 10             	add    $0x10,%esp
}
   165fb:	90                   	nop
   165fc:	c9                   	leave  
   165fd:	c3                   	ret    

000165fe <sem_count>:

int sem_count(sem_t *sem)
{
   165fe:	55                   	push   %ebp
   165ff:	89 e5                	mov    %esp,%ebp
   16601:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_protection();
   16604:	e8 73 c9 ff ff       	call   12f7c <irq_enter_protection>
   16609:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int count = sem->count;
   1660c:	8b 45 08             	mov    0x8(%ebp),%eax
   1660f:	8b 00                	mov    (%eax),%eax
   16611:	89 45 f0             	mov    %eax,-0x10(%ebp)
    irq_leave_protection(state);
   16614:	83 ec 0c             	sub    $0xc,%esp
   16617:	ff 75 f4             	pushl  -0xc(%ebp)
   1661a:	e8 75 c9 ff ff       	call   12f94 <irq_leave_protection>
   1661f:	83 c4 10             	add    $0x10,%esp
    return count;
   16622:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16625:	c9                   	leave  
   16626:	c3                   	ret    

00016627 <bitmap_byte_count>:

/**
 * @brief 获取所需要的字节数量
 */
int bitmap_byte_count(int bit_count)
{
   16627:	55                   	push   %ebp
   16628:	89 e5                	mov    %esp,%ebp
    return (bit_count + 7) / 8;
   1662a:	8b 45 08             	mov    0x8(%ebp),%eax
   1662d:	83 c0 07             	add    $0x7,%eax
   16630:	8d 50 07             	lea    0x7(%eax),%edx
   16633:	85 c0                	test   %eax,%eax
   16635:	0f 48 c2             	cmovs  %edx,%eax
   16638:	c1 f8 03             	sar    $0x3,%eax
}
   1663b:	5d                   	pop    %ebp
   1663c:	c3                   	ret    

0001663d <bitmap_init>:

/**
 * @brief 获取所需要的字节数量
 */
void bitmap_init(bitmap_t *bitmap, uint8_t *bits, int count, int init_bit)
{
   1663d:	55                   	push   %ebp
   1663e:	89 e5                	mov    %esp,%ebp
   16640:	83 ec 18             	sub    $0x18,%esp
    bitmap->bit_count = count;
   16643:	8b 45 08             	mov    0x8(%ebp),%eax
   16646:	8b 55 10             	mov    0x10(%ebp),%edx
   16649:	89 10                	mov    %edx,(%eax)
    bitmap->bits = bits;
   1664b:	8b 45 08             	mov    0x8(%ebp),%eax
   1664e:	8b 55 0c             	mov    0xc(%ebp),%edx
   16651:	89 50 04             	mov    %edx,0x4(%eax)

    int bytes = bitmap_byte_count(bitmap->bit_count);
   16654:	8b 45 08             	mov    0x8(%ebp),%eax
   16657:	8b 00                	mov    (%eax),%eax
   16659:	50                   	push   %eax
   1665a:	e8 c8 ff ff ff       	call   16627 <bitmap_byte_count>
   1665f:	83 c4 04             	add    $0x4,%esp
   16662:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_memset(bitmap->bits, init_bit ? 0xFF : 0, bytes);
   16665:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   16669:	74 07                	je     16672 <bitmap_init+0x35>
   1666b:	ba ff 00 00 00       	mov    $0xff,%edx
   16670:	eb 05                	jmp    16677 <bitmap_init+0x3a>
   16672:	ba 00 00 00 00       	mov    $0x0,%edx
   16677:	8b 45 08             	mov    0x8(%ebp),%eax
   1667a:	8b 40 04             	mov    0x4(%eax),%eax
   1667d:	83 ec 04             	sub    $0x4,%esp
   16680:	ff 75 f4             	pushl  -0xc(%ebp)
   16683:	52                   	push   %edx
   16684:	50                   	push   %eax
   16685:	e8 99 03 00 00       	call   16a23 <kernel_memset>
   1668a:	83 c4 10             	add    $0x10,%esp
}
   1668d:	90                   	nop
   1668e:	c9                   	leave  
   1668f:	c3                   	ret    

00016690 <bitmap_get_bit>:

int bitmap_get_bit(bitmap_t *bitmap, int index)
{
   16690:	55                   	push   %ebp
   16691:	89 e5                	mov    %esp,%ebp
   16693:	53                   	push   %ebx
    return (bitmap->bits[index / 8] & (1 << (index % 8))) ? 1 : 0;
   16694:	8b 45 08             	mov    0x8(%ebp),%eax
   16697:	8b 50 04             	mov    0x4(%eax),%edx
   1669a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1669d:	8d 48 07             	lea    0x7(%eax),%ecx
   166a0:	85 c0                	test   %eax,%eax
   166a2:	0f 48 c1             	cmovs  %ecx,%eax
   166a5:	c1 f8 03             	sar    $0x3,%eax
   166a8:	01 d0                	add    %edx,%eax
   166aa:	0f b6 00             	movzbl (%eax),%eax
   166ad:	0f b6 d8             	movzbl %al,%ebx
   166b0:	8b 45 0c             	mov    0xc(%ebp),%eax
   166b3:	99                   	cltd   
   166b4:	c1 ea 1d             	shr    $0x1d,%edx
   166b7:	01 d0                	add    %edx,%eax
   166b9:	83 e0 07             	and    $0x7,%eax
   166bc:	29 d0                	sub    %edx,%eax
   166be:	89 c1                	mov    %eax,%ecx
   166c0:	d3 fb                	sar    %cl,%ebx
   166c2:	89 d8                	mov    %ebx,%eax
   166c4:	83 e0 01             	and    $0x1,%eax
}
   166c7:	5b                   	pop    %ebx
   166c8:	5d                   	pop    %ebp
   166c9:	c3                   	ret    

000166ca <bitmap_set_bit>:

void bitmap_set_bit(bitmap_t *bitmap, int index, int count, int bit)
{
   166ca:	55                   	push   %ebp
   166cb:	89 e5                	mov    %esp,%ebp
   166cd:	56                   	push   %esi
   166ce:	53                   	push   %ebx
   166cf:	83 ec 10             	sub    $0x10,%esp
    for (int i = 0; (i < count) && (index < bitmap->bit_count); i++, index++)
   166d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   166d9:	e9 a2 00 00 00       	jmp    16780 <bitmap_set_bit+0xb6>
    {
        if (bit)
   166de:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   166e2:	74 4a                	je     1672e <bitmap_set_bit+0x64>
        {
            bitmap->bits[index / 8] |= (1 << (index % 8));
   166e4:	8b 45 08             	mov    0x8(%ebp),%eax
   166e7:	8b 50 04             	mov    0x4(%eax),%edx
   166ea:	8b 45 0c             	mov    0xc(%ebp),%eax
   166ed:	8d 48 07             	lea    0x7(%eax),%ecx
   166f0:	85 c0                	test   %eax,%eax
   166f2:	0f 48 c1             	cmovs  %ecx,%eax
   166f5:	c1 f8 03             	sar    $0x3,%eax
   166f8:	89 c3                	mov    %eax,%ebx
   166fa:	89 d8                	mov    %ebx,%eax
   166fc:	01 d0                	add    %edx,%eax
   166fe:	0f b6 00             	movzbl (%eax),%eax
   16701:	89 c6                	mov    %eax,%esi
   16703:	8b 45 0c             	mov    0xc(%ebp),%eax
   16706:	99                   	cltd   
   16707:	c1 ea 1d             	shr    $0x1d,%edx
   1670a:	01 d0                	add    %edx,%eax
   1670c:	83 e0 07             	and    $0x7,%eax
   1670f:	29 d0                	sub    %edx,%eax
   16711:	ba 01 00 00 00       	mov    $0x1,%edx
   16716:	89 c1                	mov    %eax,%ecx
   16718:	d3 e2                	shl    %cl,%edx
   1671a:	89 d0                	mov    %edx,%eax
   1671c:	89 f2                	mov    %esi,%edx
   1671e:	09 c2                	or     %eax,%edx
   16720:	8b 45 08             	mov    0x8(%ebp),%eax
   16723:	8b 40 04             	mov    0x4(%eax),%eax
   16726:	89 d9                	mov    %ebx,%ecx
   16728:	01 c8                	add    %ecx,%eax
   1672a:	88 10                	mov    %dl,(%eax)
   1672c:	eb 4a                	jmp    16778 <bitmap_set_bit+0xae>
        }
        else
        {
            bitmap->bits[index / 8] &= ~(1 << (index % 8));
   1672e:	8b 45 08             	mov    0x8(%ebp),%eax
   16731:	8b 50 04             	mov    0x4(%eax),%edx
   16734:	8b 45 0c             	mov    0xc(%ebp),%eax
   16737:	8d 48 07             	lea    0x7(%eax),%ecx
   1673a:	85 c0                	test   %eax,%eax
   1673c:	0f 48 c1             	cmovs  %ecx,%eax
   1673f:	c1 f8 03             	sar    $0x3,%eax
   16742:	89 c3                	mov    %eax,%ebx
   16744:	89 d8                	mov    %ebx,%eax
   16746:	01 d0                	add    %edx,%eax
   16748:	0f b6 00             	movzbl (%eax),%eax
   1674b:	89 c6                	mov    %eax,%esi
   1674d:	8b 45 0c             	mov    0xc(%ebp),%eax
   16750:	99                   	cltd   
   16751:	c1 ea 1d             	shr    $0x1d,%edx
   16754:	01 d0                	add    %edx,%eax
   16756:	83 e0 07             	and    $0x7,%eax
   16759:	29 d0                	sub    %edx,%eax
   1675b:	ba 01 00 00 00       	mov    $0x1,%edx
   16760:	89 c1                	mov    %eax,%ecx
   16762:	d3 e2                	shl    %cl,%edx
   16764:	89 d0                	mov    %edx,%eax
   16766:	f7 d0                	not    %eax
   16768:	89 f2                	mov    %esi,%edx
   1676a:	21 c2                	and    %eax,%edx
   1676c:	8b 45 08             	mov    0x8(%ebp),%eax
   1676f:	8b 40 04             	mov    0x4(%eax),%eax
   16772:	89 d9                	mov    %ebx,%ecx
   16774:	01 c8                	add    %ecx,%eax
   16776:	88 10                	mov    %dl,(%eax)
    for (int i = 0; (i < count) && (index < bitmap->bit_count); i++, index++)
   16778:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1677c:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
   16780:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16783:	3b 45 10             	cmp    0x10(%ebp),%eax
   16786:	7d 0e                	jge    16796 <bitmap_set_bit+0xcc>
   16788:	8b 45 08             	mov    0x8(%ebp),%eax
   1678b:	8b 00                	mov    (%eax),%eax
   1678d:	39 45 0c             	cmp    %eax,0xc(%ebp)
   16790:	0f 8c 48 ff ff ff    	jl     166de <bitmap_set_bit+0x14>
        }
    }
}
   16796:	90                   	nop
   16797:	83 c4 10             	add    $0x10,%esp
   1679a:	5b                   	pop    %ebx
   1679b:	5e                   	pop    %esi
   1679c:	5d                   	pop    %ebp
   1679d:	c3                   	ret    

0001679e <bitmap_is_set>:

int bitmap_is_set(bitmap_t *bitmap, int index)
{
   1679e:	55                   	push   %ebp
   1679f:	89 e5                	mov    %esp,%ebp
    return bitmap_get_bit(bitmap, index) ? 1 : 0;
   167a1:	ff 75 0c             	pushl  0xc(%ebp)
   167a4:	ff 75 08             	pushl  0x8(%ebp)
   167a7:	e8 e4 fe ff ff       	call   16690 <bitmap_get_bit>
   167ac:	83 c4 08             	add    $0x8,%esp
   167af:	85 c0                	test   %eax,%eax
   167b1:	0f 95 c0             	setne  %al
   167b4:	0f b6 c0             	movzbl %al,%eax
}
   167b7:	c9                   	leave  
   167b8:	c3                   	ret    

000167b9 <bitmap_alloc_nbits>:

int bitmap_alloc_nbits(bitmap_t *bitmap, int bit, int count)
{
   167b9:	55                   	push   %ebp
   167ba:	89 e5                	mov    %esp,%ebp
   167bc:	83 ec 10             	sub    $0x10,%esp
    int search_idx = 0;
   167bf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int ok_index =-1;
   167c6:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
    while(search_idx < bitmap->bit_count)
   167cd:	e9 82 00 00 00       	jmp    16854 <bitmap_alloc_nbits+0x9b>
    {
        if(bitmap_get_bit(bitmap,search_idx)!=bit)
   167d2:	ff 75 fc             	pushl  -0x4(%ebp)
   167d5:	ff 75 08             	pushl  0x8(%ebp)
   167d8:	e8 b3 fe ff ff       	call   16690 <bitmap_get_bit>
   167dd:	83 c4 08             	add    $0x8,%esp
   167e0:	39 45 0c             	cmp    %eax,0xc(%ebp)
   167e3:	74 06                	je     167eb <bitmap_alloc_nbits+0x32>
        {
            search_idx ++;
   167e5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
            continue;
   167e9:	eb 69                	jmp    16854 <bitmap_alloc_nbits+0x9b>
        }
        ok_index = search_idx;
   167eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   167ee:	89 45 f8             	mov    %eax,-0x8(%ebp)
        int i;
        for(i = 1 ;( i <count )&& (search_idx < bitmap->bit_count); i++,search_idx++)
   167f1:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   167f8:	eb 24                	jmp    1681e <bitmap_alloc_nbits+0x65>
        {
            if (bitmap_get_bit(bitmap,  search_idx) != bit)
   167fa:	ff 75 fc             	pushl  -0x4(%ebp)
   167fd:	ff 75 08             	pushl  0x8(%ebp)
   16800:	e8 8b fe ff ff       	call   16690 <bitmap_get_bit>
   16805:	83 c4 08             	add    $0x8,%esp
   16808:	39 45 0c             	cmp    %eax,0xc(%ebp)
   1680b:	74 09                	je     16816 <bitmap_alloc_nbits+0x5d>
            {
                ok_index = -1;
   1680d:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
                break;
   16814:	eb 1a                	jmp    16830 <bitmap_alloc_nbits+0x77>
        for(i = 1 ;( i <count )&& (search_idx < bitmap->bit_count); i++,search_idx++)
   16816:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1681a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1681e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16821:	3b 45 10             	cmp    0x10(%ebp),%eax
   16824:	7d 0a                	jge    16830 <bitmap_alloc_nbits+0x77>
   16826:	8b 45 08             	mov    0x8(%ebp),%eax
   16829:	8b 00                	mov    (%eax),%eax
   1682b:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   1682e:	7c ca                	jl     167fa <bitmap_alloc_nbits+0x41>
            }
        }
        if (i >= count)
   16830:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16833:	3b 45 10             	cmp    0x10(%ebp),%eax
   16836:	7c 1c                	jl     16854 <bitmap_alloc_nbits+0x9b>
        {
            bitmap_set_bit(bitmap,ok_index,count,~bit);
   16838:	8b 45 0c             	mov    0xc(%ebp),%eax
   1683b:	f7 d0                	not    %eax
   1683d:	50                   	push   %eax
   1683e:	ff 75 10             	pushl  0x10(%ebp)
   16841:	ff 75 f8             	pushl  -0x8(%ebp)
   16844:	ff 75 08             	pushl  0x8(%ebp)
   16847:	e8 7e fe ff ff       	call   166ca <bitmap_set_bit>
   1684c:	83 c4 10             	add    $0x10,%esp
            return ok_index;
   1684f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16852:	eb 13                	jmp    16867 <bitmap_alloc_nbits+0xae>
    while(search_idx < bitmap->bit_count)
   16854:	8b 45 08             	mov    0x8(%ebp),%eax
   16857:	8b 00                	mov    (%eax),%eax
   16859:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   1685c:	0f 8c 70 ff ff ff    	jl     167d2 <bitmap_alloc_nbits+0x19>
        }
    }
    return -1;
   16862:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   16867:	c9                   	leave  
   16868:	c3                   	ret    

00016869 <hlt>:
{
   16869:	55                   	push   %ebp
   1686a:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("hlt");
   1686c:	f4                   	hlt    
}
   1686d:	90                   	nop
   1686e:	5d                   	pop    %ebp
   1686f:	c3                   	ret    

00016870 <kernel_strcpy>:
#include "tools/klib.h"
#include "tools/log.h"
#include "comm/cpu_instr.h"

void kernel_strcpy(char *dest, const char *src)
{
   16870:	55                   	push   %ebp
   16871:	89 e5                	mov    %esp,%ebp
    if (!dest || !src)
   16873:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   16877:	74 35                	je     168ae <kernel_strcpy+0x3e>
   16879:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1687d:	74 2f                	je     168ae <kernel_strcpy+0x3e>
    {
        return;
    }

    while (*dest && *src)
   1687f:	eb 17                	jmp    16898 <kernel_strcpy+0x28>
    {
        *dest++ = *src++;
   16881:	8b 55 0c             	mov    0xc(%ebp),%edx
   16884:	8d 42 01             	lea    0x1(%edx),%eax
   16887:	89 45 0c             	mov    %eax,0xc(%ebp)
   1688a:	8b 45 08             	mov    0x8(%ebp),%eax
   1688d:	8d 48 01             	lea    0x1(%eax),%ecx
   16890:	89 4d 08             	mov    %ecx,0x8(%ebp)
   16893:	0f b6 12             	movzbl (%edx),%edx
   16896:	88 10                	mov    %dl,(%eax)
    while (*dest && *src)
   16898:	8b 45 08             	mov    0x8(%ebp),%eax
   1689b:	0f b6 00             	movzbl (%eax),%eax
   1689e:	84 c0                	test   %al,%al
   168a0:	74 0d                	je     168af <kernel_strcpy+0x3f>
   168a2:	8b 45 0c             	mov    0xc(%ebp),%eax
   168a5:	0f b6 00             	movzbl (%eax),%eax
   168a8:	84 c0                	test   %al,%al
   168aa:	75 d5                	jne    16881 <kernel_strcpy+0x11>
   168ac:	eb 01                	jmp    168af <kernel_strcpy+0x3f>
        return;
   168ae:	90                   	nop
    }
}
   168af:	5d                   	pop    %ebp
   168b0:	c3                   	ret    

000168b1 <kernel_strncpy>:

void kernel_strncpy(char *dest, const char *src, int size)
{
   168b1:	55                   	push   %ebp
   168b2:	89 e5                	mov    %esp,%ebp
   168b4:	83 ec 10             	sub    $0x10,%esp
    if (!dest || !src || !size)
   168b7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   168bb:	74 61                	je     1691e <kernel_strncpy+0x6d>
   168bd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   168c1:	74 5b                	je     1691e <kernel_strncpy+0x6d>
   168c3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   168c7:	74 55                	je     1691e <kernel_strncpy+0x6d>
    {
        return;
    }

    char *d = dest;
   168c9:	8b 45 08             	mov    0x8(%ebp),%eax
   168cc:	89 45 fc             	mov    %eax,-0x4(%ebp)
    const char *s = src;
   168cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   168d2:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while ((size-- > 0) && (*s))
   168d5:	eb 17                	jmp    168ee <kernel_strncpy+0x3d>
    {
        *d++ = *s++;
   168d7:	8b 55 f8             	mov    -0x8(%ebp),%edx
   168da:	8d 42 01             	lea    0x1(%edx),%eax
   168dd:	89 45 f8             	mov    %eax,-0x8(%ebp)
   168e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   168e3:	8d 48 01             	lea    0x1(%eax),%ecx
   168e6:	89 4d fc             	mov    %ecx,-0x4(%ebp)
   168e9:	0f b6 12             	movzbl (%edx),%edx
   168ec:	88 10                	mov    %dl,(%eax)
    while ((size-- > 0) && (*s))
   168ee:	8b 45 10             	mov    0x10(%ebp),%eax
   168f1:	8d 50 ff             	lea    -0x1(%eax),%edx
   168f4:	89 55 10             	mov    %edx,0x10(%ebp)
   168f7:	85 c0                	test   %eax,%eax
   168f9:	7e 0a                	jle    16905 <kernel_strncpy+0x54>
   168fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   168fe:	0f b6 00             	movzbl (%eax),%eax
   16901:	84 c0                	test   %al,%al
   16903:	75 d2                	jne    168d7 <kernel_strncpy+0x26>
    }
    if (size == 0)
   16905:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   16909:	75 0b                	jne    16916 <kernel_strncpy+0x65>
    {
        *(d - 1) = '\0';
   1690b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1690e:	83 e8 01             	sub    $0x1,%eax
   16911:	c6 00 00             	movb   $0x0,(%eax)
   16914:	eb 09                	jmp    1691f <kernel_strncpy+0x6e>
    }
    else
    {
        *d = '\0';
   16916:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16919:	c6 00 00             	movb   $0x0,(%eax)
   1691c:	eb 01                	jmp    1691f <kernel_strncpy+0x6e>
        return;
   1691e:	90                   	nop
    }
}
   1691f:	c9                   	leave  
   16920:	c3                   	ret    

00016921 <kernel_strncmp>:
/**
 * 比较两个字符串，最多比较size个字符
 * 如果某一字符串提前比较完成，也算相同
 */
int kernel_strncmp(const char *s1, const char *s2, int size)
{
   16921:	55                   	push   %ebp
   16922:	89 e5                	mov    %esp,%ebp
    if (!s1 || !s2)
   16924:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   16928:	74 06                	je     16930 <kernel_strncmp+0xf>
   1692a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1692e:	75 13                	jne    16943 <kernel_strncmp+0x22>
    {
        return -1;
   16930:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16935:	eb 66                	jmp    1699d <kernel_strncmp+0x7c>
    }

    // 2023-3-18 这里size没有用到
    while (*s1 && *s2 && (*s1 == *s2) && size)
    {
        s1++;
   16937:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        s2++;
   1693b:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
        size--;
   1693f:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
    while (*s1 && *s2 && (*s1 == *s2) && size)
   16943:	8b 45 08             	mov    0x8(%ebp),%eax
   16946:	0f b6 00             	movzbl (%eax),%eax
   16949:	84 c0                	test   %al,%al
   1694b:	74 20                	je     1696d <kernel_strncmp+0x4c>
   1694d:	8b 45 0c             	mov    0xc(%ebp),%eax
   16950:	0f b6 00             	movzbl (%eax),%eax
   16953:	84 c0                	test   %al,%al
   16955:	74 16                	je     1696d <kernel_strncmp+0x4c>
   16957:	8b 45 08             	mov    0x8(%ebp),%eax
   1695a:	0f b6 10             	movzbl (%eax),%edx
   1695d:	8b 45 0c             	mov    0xc(%ebp),%eax
   16960:	0f b6 00             	movzbl (%eax),%eax
   16963:	38 c2                	cmp    %al,%dl
   16965:	75 06                	jne    1696d <kernel_strncmp+0x4c>
   16967:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1696b:	75 ca                	jne    16937 <kernel_strncmp+0x16>
    }

    return !((*s1 == '\0') || (*s2 == '\0') || (*s1 == *s2));
   1696d:	8b 45 08             	mov    0x8(%ebp),%eax
   16970:	0f b6 00             	movzbl (%eax),%eax
   16973:	84 c0                	test   %al,%al
   16975:	74 21                	je     16998 <kernel_strncmp+0x77>
   16977:	8b 45 0c             	mov    0xc(%ebp),%eax
   1697a:	0f b6 00             	movzbl (%eax),%eax
   1697d:	84 c0                	test   %al,%al
   1697f:	74 17                	je     16998 <kernel_strncmp+0x77>
   16981:	8b 45 08             	mov    0x8(%ebp),%eax
   16984:	0f b6 10             	movzbl (%eax),%edx
   16987:	8b 45 0c             	mov    0xc(%ebp),%eax
   1698a:	0f b6 00             	movzbl (%eax),%eax
   1698d:	38 c2                	cmp    %al,%dl
   1698f:	74 07                	je     16998 <kernel_strncmp+0x77>
   16991:	b8 01 00 00 00       	mov    $0x1,%eax
   16996:	eb 05                	jmp    1699d <kernel_strncmp+0x7c>
   16998:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1699d:	5d                   	pop    %ebp
   1699e:	c3                   	ret    

0001699f <kernel_strlen>:

int kernel_strlen(const char *str)
{
   1699f:	55                   	push   %ebp
   169a0:	89 e5                	mov    %esp,%ebp
   169a2:	83 ec 10             	sub    $0x10,%esp
    if (!str)
   169a5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   169a9:	75 07                	jne    169b2 <kernel_strlen+0x13>
    {
        return 0;
   169ab:	b8 00 00 00 00       	mov    $0x0,%eax
   169b0:	eb 20                	jmp    169d2 <kernel_strlen+0x33>
    }

    int len = 0;
   169b2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    while (*str++)
   169b9:	eb 04                	jmp    169bf <kernel_strlen+0x20>
    {
        len++;
   169bb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while (*str++)
   169bf:	8b 45 08             	mov    0x8(%ebp),%eax
   169c2:	8d 50 01             	lea    0x1(%eax),%edx
   169c5:	89 55 08             	mov    %edx,0x8(%ebp)
   169c8:	0f b6 00             	movzbl (%eax),%eax
   169cb:	84 c0                	test   %al,%al
   169cd:	75 ec                	jne    169bb <kernel_strlen+0x1c>
    }

    return len;
   169cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   169d2:	c9                   	leave  
   169d3:	c3                   	ret    

000169d4 <kernel_memcpy>:

void kernel_memcpy(void *dest, void *src, int size)
{
   169d4:	55                   	push   %ebp
   169d5:	89 e5                	mov    %esp,%ebp
   169d7:	83 ec 10             	sub    $0x10,%esp
    if (!dest || !src || !size)
   169da:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   169de:	74 40                	je     16a20 <kernel_memcpy+0x4c>
   169e0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   169e4:	74 3a                	je     16a20 <kernel_memcpy+0x4c>
   169e6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   169ea:	74 34                	je     16a20 <kernel_memcpy+0x4c>
    {
        return;
    }

    uint8_t *s = (uint8_t *)src;
   169ec:	8b 45 0c             	mov    0xc(%ebp),%eax
   169ef:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t *d = (uint8_t *)dest;
   169f2:	8b 45 08             	mov    0x8(%ebp),%eax
   169f5:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while (size--)
   169f8:	eb 17                	jmp    16a11 <kernel_memcpy+0x3d>
    {
        *d++ = *s++;
   169fa:	8b 55 fc             	mov    -0x4(%ebp),%edx
   169fd:	8d 42 01             	lea    0x1(%edx),%eax
   16a00:	89 45 fc             	mov    %eax,-0x4(%ebp)
   16a03:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16a06:	8d 48 01             	lea    0x1(%eax),%ecx
   16a09:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   16a0c:	0f b6 12             	movzbl (%edx),%edx
   16a0f:	88 10                	mov    %dl,(%eax)
    while (size--)
   16a11:	8b 45 10             	mov    0x10(%ebp),%eax
   16a14:	8d 50 ff             	lea    -0x1(%eax),%edx
   16a17:	89 55 10             	mov    %edx,0x10(%ebp)
   16a1a:	85 c0                	test   %eax,%eax
   16a1c:	75 dc                	jne    169fa <kernel_memcpy+0x26>
   16a1e:	eb 01                	jmp    16a21 <kernel_memcpy+0x4d>
        return;
   16a20:	90                   	nop
    }
}
   16a21:	c9                   	leave  
   16a22:	c3                   	ret    

00016a23 <kernel_memset>:
void kernel_memset(void *dest, uint8_t val, int size)
{
   16a23:	55                   	push   %ebp
   16a24:	89 e5                	mov    %esp,%ebp
   16a26:	83 ec 14             	sub    $0x14,%esp
   16a29:	8b 45 0c             	mov    0xc(%ebp),%eax
   16a2c:	88 45 ec             	mov    %al,-0x14(%ebp)
    if (!dest || size <= 0)
   16a2f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   16a33:	74 2c                	je     16a61 <kernel_memset+0x3e>
   16a35:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   16a39:	7e 26                	jle    16a61 <kernel_memset+0x3e>
    {
        return;
    }

    uint8_t *d = (uint8_t *)dest;
   16a3b:	8b 45 08             	mov    0x8(%ebp),%eax
   16a3e:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while (size--)
   16a41:	eb 0f                	jmp    16a52 <kernel_memset+0x2f>
    {
        *d++ = val;
   16a43:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16a46:	8d 50 01             	lea    0x1(%eax),%edx
   16a49:	89 55 fc             	mov    %edx,-0x4(%ebp)
   16a4c:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
   16a50:	88 10                	mov    %dl,(%eax)
    while (size--)
   16a52:	8b 45 10             	mov    0x10(%ebp),%eax
   16a55:	8d 50 ff             	lea    -0x1(%eax),%edx
   16a58:	89 55 10             	mov    %edx,0x10(%ebp)
   16a5b:	85 c0                	test   %eax,%eax
   16a5d:	75 e4                	jne    16a43 <kernel_memset+0x20>
   16a5f:	eb 01                	jmp    16a62 <kernel_memset+0x3f>
        return;
   16a61:	90                   	nop
    }
}
   16a62:	c9                   	leave  
   16a63:	c3                   	ret    

00016a64 <kernel_memcmp>:
int kernel_memcmp(const void *str1, const void *str2, int size)
{
   16a64:	55                   	push   %ebp
   16a65:	89 e5                	mov    %esp,%ebp
   16a67:	83 ec 10             	sub    $0x10,%esp
    if (!str1 || !str2 || size <= 0)
   16a6a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   16a6e:	74 0c                	je     16a7c <kernel_memcmp+0x18>
   16a70:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   16a74:	74 06                	je     16a7c <kernel_memcmp+0x18>
   16a76:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   16a7a:	7f 07                	jg     16a83 <kernel_memcmp+0x1f>
    {
        return 1;
   16a7c:	b8 01 00 00 00       	mov    $0x1,%eax
   16a81:	eb 3f                	jmp    16ac2 <kernel_memcmp+0x5e>
    }

    const uint8_t *s1 = (const uint8_t *)str1;
   16a83:	8b 45 08             	mov    0x8(%ebp),%eax
   16a86:	89 45 fc             	mov    %eax,-0x4(%ebp)
    const uint8_t *s2 = (const uint8_t *)str2;
   16a89:	8b 45 0c             	mov    0xc(%ebp),%eax
   16a8c:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while (size--)
   16a8f:	eb 1f                	jmp    16ab0 <kernel_memcmp+0x4c>
    {
        if (*s1 != *s2)
   16a91:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16a94:	0f b6 10             	movzbl (%eax),%edx
   16a97:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16a9a:	0f b6 00             	movzbl (%eax),%eax
   16a9d:	38 c2                	cmp    %al,%dl
   16a9f:	74 07                	je     16aa8 <kernel_memcmp+0x44>
        {
            return 1;
   16aa1:	b8 01 00 00 00       	mov    $0x1,%eax
   16aa6:	eb 1a                	jmp    16ac2 <kernel_memcmp+0x5e>
        }
        s1++;
   16aa8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        s2++;
   16aac:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while (size--)
   16ab0:	8b 45 10             	mov    0x10(%ebp),%eax
   16ab3:	8d 50 ff             	lea    -0x1(%eax),%edx
   16ab6:	89 55 10             	mov    %edx,0x10(%ebp)
   16ab9:	85 c0                	test   %eax,%eax
   16abb:	75 d4                	jne    16a91 <kernel_memcmp+0x2d>
    }

    return 0;
   16abd:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16ac2:	c9                   	leave  
   16ac3:	c3                   	ret    

00016ac4 <kernel_sprintf>:

void kernel_sprintf(char *buf, const char *fmt, ...)
{
   16ac4:	55                   	push   %ebp
   16ac5:	89 e5                	mov    %esp,%ebp
   16ac7:	83 ec 18             	sub    $0x18,%esp
    va_list args;
    va_start(args, fmt);
   16aca:	8d 45 10             	lea    0x10(%ebp),%eax
   16acd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_vsnprintf(buf, fmt, args);
   16ad0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16ad3:	83 ec 04             	sub    $0x4,%esp
   16ad6:	50                   	push   %eax
   16ad7:	ff 75 0c             	pushl  0xc(%ebp)
   16ada:	ff 75 08             	pushl  0x8(%ebp)
   16add:	e8 d9 00 00 00       	call   16bbb <kernel_vsnprintf>
   16ae2:	83 c4 10             	add    $0x10,%esp
    va_end(args);
}
   16ae5:	90                   	nop
   16ae6:	c9                   	leave  
   16ae7:	c3                   	ret    

00016ae8 <kernel_itoa>:

void kernel_itoa(char *buf, int num, int base)
{
   16ae8:	55                   	push   %ebp
   16ae9:	89 e5                	mov    %esp,%ebp
   16aeb:	83 ec 10             	sub    $0x10,%esp
    static const char *num2char = "FEDCBA9876543210123456789ABCDEF";
    char *p = buf;
   16aee:	8b 45 08             	mov    0x8(%ebp),%eax
   16af1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int old_num = num;
   16af4:	8b 45 0c             	mov    0xc(%ebp),%eax
   16af7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (base != 2 && base != 8 && base != 10 && base != 16)
   16afa:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   16afe:	74 18                	je     16b18 <kernel_itoa+0x30>
   16b00:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
   16b04:	74 12                	je     16b18 <kernel_itoa+0x30>
   16b06:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   16b0a:	74 0c                	je     16b18 <kernel_itoa+0x30>
   16b0c:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
   16b10:	74 06                	je     16b18 <kernel_itoa+0x30>
    {
        *p = '\0';
   16b12:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16b15:	c6 00 00             	movb   $0x0,(%eax)
    }
    if (num < 0 && base == 10)
   16b18:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   16b1c:	79 12                	jns    16b30 <kernel_itoa+0x48>
   16b1e:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   16b22:	75 0c                	jne    16b30 <kernel_itoa+0x48>
    {
        *p++ = '-';
   16b24:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16b27:	8d 50 01             	lea    0x1(%eax),%edx
   16b2a:	89 55 fc             	mov    %edx,-0x4(%ebp)
   16b2d:	c6 00 2d             	movb   $0x2d,(%eax)
    }

    do
    {
        char ch = num2char[(num % base) + 15];
   16b30:	8b 0d 20 91 01 00    	mov    0x19120,%ecx
   16b36:	8b 45 0c             	mov    0xc(%ebp),%eax
   16b39:	99                   	cltd   
   16b3a:	f7 7d 10             	idivl  0x10(%ebp)
   16b3d:	89 d0                	mov    %edx,%eax
   16b3f:	83 c0 0f             	add    $0xf,%eax
   16b42:	01 c8                	add    %ecx,%eax
   16b44:	0f b6 00             	movzbl (%eax),%eax
   16b47:	88 45 f3             	mov    %al,-0xd(%ebp)
        *p++ = ch;
   16b4a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16b4d:	8d 50 01             	lea    0x1(%eax),%edx
   16b50:	89 55 fc             	mov    %edx,-0x4(%ebp)
   16b53:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
   16b57:	88 10                	mov    %dl,(%eax)
        num /= base;
   16b59:	8b 45 0c             	mov    0xc(%ebp),%eax
   16b5c:	99                   	cltd   
   16b5d:	f7 7d 10             	idivl  0x10(%ebp)
   16b60:	89 45 0c             	mov    %eax,0xc(%ebp)
        /* code */
    } while (num);
   16b63:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   16b67:	75 c7                	jne    16b30 <kernel_itoa+0x48>

    *p-- = '\0';
   16b69:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16b6c:	8d 50 ff             	lea    -0x1(%eax),%edx
   16b6f:	89 55 fc             	mov    %edx,-0x4(%ebp)
   16b72:	c6 00 00             	movb   $0x0,(%eax)

    char *start = (old_num > 0) ? buf : buf + 1;
   16b75:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   16b79:	7f 08                	jg     16b83 <kernel_itoa+0x9b>
   16b7b:	8b 45 08             	mov    0x8(%ebp),%eax
   16b7e:	83 c0 01             	add    $0x1,%eax
   16b81:	eb 03                	jmp    16b86 <kernel_itoa+0x9e>
   16b83:	8b 45 08             	mov    0x8(%ebp),%eax
   16b86:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while (start < p)
   16b89:	eb 25                	jmp    16bb0 <kernel_itoa+0xc8>
    {
        char tmp = *start;
   16b8b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16b8e:	0f b6 00             	movzbl (%eax),%eax
   16b91:	88 45 f2             	mov    %al,-0xe(%ebp)
        *start = *p;
   16b94:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16b97:	0f b6 10             	movzbl (%eax),%edx
   16b9a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16b9d:	88 10                	mov    %dl,(%eax)
        *p = tmp;
   16b9f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16ba2:	0f b6 55 f2          	movzbl -0xe(%ebp),%edx
   16ba6:	88 10                	mov    %dl,(%eax)
        start++;
   16ba8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
        p--;
   16bac:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    while (start < p)
   16bb0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16bb3:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   16bb6:	72 d3                	jb     16b8b <kernel_itoa+0xa3>
    }
}
   16bb8:	90                   	nop
   16bb9:	c9                   	leave  
   16bba:	c3                   	ret    

00016bbb <kernel_vsnprintf>:

void kernel_vsnprintf(char *buf, const char *fmt, va_list args)
{
   16bbb:	55                   	push   %ebp
   16bbc:	89 e5                	mov    %esp,%ebp
   16bbe:	83 ec 20             	sub    $0x20,%esp
    enum
    {
        NORMAL,
        READ_FMT
    } state = NORMAL;
   16bc1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    char *curr = buf;
   16bc8:	8b 45 08             	mov    0x8(%ebp),%eax
   16bcb:	89 45 f8             	mov    %eax,-0x8(%ebp)
    char ch;
    while ((ch = *fmt++) != '\0')
   16bce:	e9 17 01 00 00       	jmp    16cea <kernel_vsnprintf+0x12f>
    {
        switch (state)
   16bd3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16bd6:	85 c0                	test   %eax,%eax
   16bd8:	74 0a                	je     16be4 <kernel_vsnprintf+0x29>
   16bda:	83 f8 01             	cmp    $0x1,%eax
   16bdd:	74 2b                	je     16c0a <kernel_vsnprintf+0x4f>
   16bdf:	e9 06 01 00 00       	jmp    16cea <kernel_vsnprintf+0x12f>
        {
        case NORMAL:
            if (ch == '%')
   16be4:	80 7d ef 25          	cmpb   $0x25,-0x11(%ebp)
   16be8:	75 0c                	jne    16bf6 <kernel_vsnprintf+0x3b>
            {
                state = READ_FMT;
   16bea:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
   16bf1:	e9 f4 00 00 00       	jmp    16cea <kernel_vsnprintf+0x12f>
            }
            else
            {
                *curr++ = ch;
   16bf6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16bf9:	8d 50 01             	lea    0x1(%eax),%edx
   16bfc:	89 55 f8             	mov    %edx,-0x8(%ebp)
   16bff:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
   16c03:	88 10                	mov    %dl,(%eax)
            }
            break;
   16c05:	e9 e0 00 00 00       	jmp    16cea <kernel_vsnprintf+0x12f>
        case READ_FMT:
            if (ch == 'd')
   16c0a:	80 7d ef 64          	cmpb   $0x64,-0x11(%ebp)
   16c0e:	75 31                	jne    16c41 <kernel_vsnprintf+0x86>
            {
                int num = va_arg(args, int);
   16c10:	8b 45 10             	mov    0x10(%ebp),%eax
   16c13:	8d 50 04             	lea    0x4(%eax),%edx
   16c16:	89 55 10             	mov    %edx,0x10(%ebp)
   16c19:	8b 00                	mov    (%eax),%eax
   16c1b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                kernel_itoa(curr, num, 10);
   16c1e:	6a 0a                	push   $0xa
   16c20:	ff 75 e4             	pushl  -0x1c(%ebp)
   16c23:	ff 75 f8             	pushl  -0x8(%ebp)
   16c26:	e8 bd fe ff ff       	call   16ae8 <kernel_itoa>
   16c2b:	83 c4 0c             	add    $0xc,%esp
                curr += kernel_strlen(curr);
   16c2e:	ff 75 f8             	pushl  -0x8(%ebp)
   16c31:	e8 69 fd ff ff       	call   1699f <kernel_strlen>
   16c36:	83 c4 04             	add    $0x4,%esp
   16c39:	01 45 f8             	add    %eax,-0x8(%ebp)
   16c3c:	e9 a1 00 00 00       	jmp    16ce2 <kernel_vsnprintf+0x127>
            }
            else if (ch == 'x')
   16c41:	80 7d ef 78          	cmpb   $0x78,-0x11(%ebp)
   16c45:	75 2e                	jne    16c75 <kernel_vsnprintf+0xba>
            {
                int num = va_arg(args, int);
   16c47:	8b 45 10             	mov    0x10(%ebp),%eax
   16c4a:	8d 50 04             	lea    0x4(%eax),%edx
   16c4d:	89 55 10             	mov    %edx,0x10(%ebp)
   16c50:	8b 00                	mov    (%eax),%eax
   16c52:	89 45 e8             	mov    %eax,-0x18(%ebp)
                kernel_itoa(curr, num, 16);
   16c55:	6a 10                	push   $0x10
   16c57:	ff 75 e8             	pushl  -0x18(%ebp)
   16c5a:	ff 75 f8             	pushl  -0x8(%ebp)
   16c5d:	e8 86 fe ff ff       	call   16ae8 <kernel_itoa>
   16c62:	83 c4 0c             	add    $0xc,%esp
                curr += kernel_strlen(curr);
   16c65:	ff 75 f8             	pushl  -0x8(%ebp)
   16c68:	e8 32 fd ff ff       	call   1699f <kernel_strlen>
   16c6d:	83 c4 04             	add    $0x4,%esp
   16c70:	01 45 f8             	add    %eax,-0x8(%ebp)
   16c73:	eb 6d                	jmp    16ce2 <kernel_vsnprintf+0x127>
            }
            else if (ch == 'c')
   16c75:	80 7d ef 63          	cmpb   $0x63,-0x11(%ebp)
   16c79:	75 1f                	jne    16c9a <kernel_vsnprintf+0xdf>
            {
                char c = va_arg(args, int);
   16c7b:	8b 45 10             	mov    0x10(%ebp),%eax
   16c7e:	8d 50 04             	lea    0x4(%eax),%edx
   16c81:	89 55 10             	mov    %edx,0x10(%ebp)
   16c84:	8b 00                	mov    (%eax),%eax
   16c86:	88 45 ee             	mov    %al,-0x12(%ebp)
                *curr++ = c;
   16c89:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16c8c:	8d 50 01             	lea    0x1(%eax),%edx
   16c8f:	89 55 f8             	mov    %edx,-0x8(%ebp)
   16c92:	0f b6 55 ee          	movzbl -0x12(%ebp),%edx
   16c96:	88 10                	mov    %dl,(%eax)
   16c98:	eb 48                	jmp    16ce2 <kernel_vsnprintf+0x127>
            }
            else if (ch == 's')
   16c9a:	80 7d ef 73          	cmpb   $0x73,-0x11(%ebp)
   16c9e:	75 42                	jne    16ce2 <kernel_vsnprintf+0x127>
            {
                const char *str = va_arg(args, char *);
   16ca0:	8b 45 10             	mov    0x10(%ebp),%eax
   16ca3:	8d 50 04             	lea    0x4(%eax),%edx
   16ca6:	89 55 10             	mov    %edx,0x10(%ebp)
   16ca9:	8b 00                	mov    (%eax),%eax
   16cab:	89 45 f4             	mov    %eax,-0xc(%ebp)
                int len = kernel_strlen(str);
   16cae:	ff 75 f4             	pushl  -0xc(%ebp)
   16cb1:	e8 e9 fc ff ff       	call   1699f <kernel_strlen>
   16cb6:	83 c4 04             	add    $0x4,%esp
   16cb9:	89 45 f0             	mov    %eax,-0x10(%ebp)
                while (len--)
   16cbc:	eb 17                	jmp    16cd5 <kernel_vsnprintf+0x11a>
                {
                    *curr++ = *str++;
   16cbe:	8b 55 f4             	mov    -0xc(%ebp),%edx
   16cc1:	8d 42 01             	lea    0x1(%edx),%eax
   16cc4:	89 45 f4             	mov    %eax,-0xc(%ebp)
   16cc7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16cca:	8d 48 01             	lea    0x1(%eax),%ecx
   16ccd:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   16cd0:	0f b6 12             	movzbl (%edx),%edx
   16cd3:	88 10                	mov    %dl,(%eax)
                while (len--)
   16cd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16cd8:	8d 50 ff             	lea    -0x1(%eax),%edx
   16cdb:	89 55 f0             	mov    %edx,-0x10(%ebp)
   16cde:	85 c0                	test   %eax,%eax
   16ce0:	75 dc                	jne    16cbe <kernel_vsnprintf+0x103>
                }
            }
            state = NORMAL;
   16ce2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
            break;
   16ce9:	90                   	nop
    while ((ch = *fmt++) != '\0')
   16cea:	8b 45 0c             	mov    0xc(%ebp),%eax
   16ced:	8d 50 01             	lea    0x1(%eax),%edx
   16cf0:	89 55 0c             	mov    %edx,0xc(%ebp)
   16cf3:	0f b6 00             	movzbl (%eax),%eax
   16cf6:	88 45 ef             	mov    %al,-0x11(%ebp)
   16cf9:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
   16cfd:	0f 85 d0 fe ff ff    	jne    16bd3 <kernel_vsnprintf+0x18>
        }
    }
}
   16d03:	90                   	nop
   16d04:	c9                   	leave  
   16d05:	c3                   	ret    

00016d06 <pannic>:

void pannic(const char *file, int line, const char *func, const char *cond)
{
   16d06:	55                   	push   %ebp
   16d07:	89 e5                	mov    %esp,%ebp
   16d09:	83 ec 08             	sub    $0x8,%esp
    log_printf("assert failed! %s", cond);
   16d0c:	83 ec 08             	sub    $0x8,%esp
   16d0f:	ff 75 14             	pushl  0x14(%ebp)
   16d12:	68 84 83 01 00       	push   $0x18384
   16d17:	e8 e3 02 00 00       	call   16fff <log_printf>
   16d1c:	83 c4 10             	add    $0x10,%esp

    log_printf("file: %s, line: %d, func: %s", file, line, func);
   16d1f:	ff 75 10             	pushl  0x10(%ebp)
   16d22:	ff 75 0c             	pushl  0xc(%ebp)
   16d25:	ff 75 08             	pushl  0x8(%ebp)
   16d28:	68 96 83 01 00       	push   $0x18396
   16d2d:	e8 cd 02 00 00       	call   16fff <log_printf>
   16d32:	83 c4 10             	add    $0x10,%esp
    for (;;)
    {
        hlt();
   16d35:	e8 2f fb ff ff       	call   16869 <hlt>
   16d3a:	eb f9                	jmp    16d35 <pannic+0x2f>

00016d3c <string_count>:
    }
}

int string_count(char **start)
{
   16d3c:	55                   	push   %ebp
   16d3d:	89 e5                	mov    %esp,%ebp
   16d3f:	83 ec 10             	sub    $0x10,%esp
    int count = 0;
   16d42:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    if (start)
   16d49:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   16d4d:	74 15                	je     16d64 <string_count+0x28>
    {
        while (*start++)
   16d4f:	eb 04                	jmp    16d55 <string_count+0x19>
        {
            count++;
   16d51:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        while (*start++)
   16d55:	8b 45 08             	mov    0x8(%ebp),%eax
   16d58:	8d 50 04             	lea    0x4(%eax),%edx
   16d5b:	89 55 08             	mov    %edx,0x8(%ebp)
   16d5e:	8b 00                	mov    (%eax),%eax
   16d60:	85 c0                	test   %eax,%eax
   16d62:	75 ed                	jne    16d51 <string_count+0x15>
        }
    }
    return count;
   16d64:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   16d67:	c9                   	leave  
   16d68:	c3                   	ret    

00016d69 <get_file_name>:

/**
 * @brief 从路径中解释文件名
 */
char *get_file_name(char *name)
{
   16d69:	55                   	push   %ebp
   16d6a:	89 e5                	mov    %esp,%ebp
   16d6c:	83 ec 10             	sub    $0x10,%esp
    char *s = name;
   16d6f:	8b 45 08             	mov    0x8(%ebp),%eax
   16d72:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // 定位到结束符
    while (*s != '\0')
   16d75:	eb 04                	jmp    16d7b <get_file_name+0x12>
    {
        s++;
   16d77:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while (*s != '\0')
   16d7b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16d7e:	0f b6 00             	movzbl (%eax),%eax
   16d81:	84 c0                	test   %al,%al
   16d83:	75 f2                	jne    16d77 <get_file_name+0xe>
    }

    // 反向搜索，直到找到反斜杆或者到文件开头
    while ((*s != '\\') && (*s != '/') && (s >= name))
   16d85:	eb 04                	jmp    16d8b <get_file_name+0x22>
    {
        s--;
   16d87:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    while ((*s != '\\') && (*s != '/') && (s >= name))
   16d8b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16d8e:	0f b6 00             	movzbl (%eax),%eax
   16d91:	3c 5c                	cmp    $0x5c,%al
   16d93:	74 12                	je     16da7 <get_file_name+0x3e>
   16d95:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16d98:	0f b6 00             	movzbl (%eax),%eax
   16d9b:	3c 2f                	cmp    $0x2f,%al
   16d9d:	74 08                	je     16da7 <get_file_name+0x3e>
   16d9f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16da2:	3b 45 08             	cmp    0x8(%ebp),%eax
   16da5:	73 e0                	jae    16d87 <get_file_name+0x1e>
    }
    return s + 1;
   16da7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16daa:	83 c0 01             	add    $0x1,%eax
}
   16dad:	c9                   	leave  
   16dae:	c3                   	ret    

00016daf <list_node_prev>:
{
   16daf:	55                   	push   %ebp
   16db0:	89 e5                	mov    %esp,%ebp
    return node->prev;
   16db2:	8b 45 08             	mov    0x8(%ebp),%eax
   16db5:	8b 40 04             	mov    0x4(%eax),%eax
}
   16db8:	5d                   	pop    %ebp
   16db9:	c3                   	ret    

00016dba <list_node_next>:
{
   16dba:	55                   	push   %ebp
   16dbb:	89 e5                	mov    %esp,%ebp
    return node->next;
   16dbd:	8b 45 08             	mov    0x8(%ebp),%eax
   16dc0:	8b 00                	mov    (%eax),%eax
}
   16dc2:	5d                   	pop    %ebp
   16dc3:	c3                   	ret    

00016dc4 <list_is_empty>:
{
   16dc4:	55                   	push   %ebp
   16dc5:	89 e5                	mov    %esp,%ebp
    return list->count == 0;
   16dc7:	8b 45 08             	mov    0x8(%ebp),%eax
   16dca:	8b 40 08             	mov    0x8(%eax),%eax
   16dcd:	85 c0                	test   %eax,%eax
   16dcf:	0f 94 c0             	sete   %al
   16dd2:	0f b6 c0             	movzbl %al,%eax
}
   16dd5:	5d                   	pop    %ebp
   16dd6:	c3                   	ret    

00016dd7 <list_init>:
#include "tools/list.h"

void list_init(list_t *list)
{
   16dd7:	55                   	push   %ebp
   16dd8:	89 e5                	mov    %esp,%ebp
    list->first = list->last = (list_node_t *)0;
   16dda:	8b 45 08             	mov    0x8(%ebp),%eax
   16ddd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   16de4:	8b 45 08             	mov    0x8(%ebp),%eax
   16de7:	8b 50 04             	mov    0x4(%eax),%edx
   16dea:	8b 45 08             	mov    0x8(%ebp),%eax
   16ded:	89 10                	mov    %edx,(%eax)
    list->count = 0;
   16def:	8b 45 08             	mov    0x8(%ebp),%eax
   16df2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
   16df9:	90                   	nop
   16dfa:	5d                   	pop    %ebp
   16dfb:	c3                   	ret    

00016dfc <list_insert_first>:
 * 将指定表项插入到指定链表的头部
 * @param list 待插入的链表
 * @param node 待插入的结点
 */
void list_insert_first(list_t *list, list_node_t *node)
{
   16dfc:	55                   	push   %ebp
   16dfd:	89 e5                	mov    %esp,%ebp
    // 设置好待插入结点的前后，前面为空
    node->next = list->first;
   16dff:	8b 45 08             	mov    0x8(%ebp),%eax
   16e02:	8b 10                	mov    (%eax),%edx
   16e04:	8b 45 0c             	mov    0xc(%ebp),%eax
   16e07:	89 10                	mov    %edx,(%eax)
    node->prev = (list_node_t *)0;
   16e09:	8b 45 0c             	mov    0xc(%ebp),%eax
   16e0c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // 如果为空，需要同时设置first和last指向自己
    if (list_is_empty(list))
   16e13:	ff 75 08             	pushl  0x8(%ebp)
   16e16:	e8 a9 ff ff ff       	call   16dc4 <list_is_empty>
   16e1b:	83 c4 04             	add    $0x4,%esp
   16e1e:	85 c0                	test   %eax,%eax
   16e20:	74 15                	je     16e37 <list_insert_first+0x3b>
    {
        list->last = list->first = node;
   16e22:	8b 45 08             	mov    0x8(%ebp),%eax
   16e25:	8b 55 0c             	mov    0xc(%ebp),%edx
   16e28:	89 10                	mov    %edx,(%eax)
   16e2a:	8b 45 08             	mov    0x8(%ebp),%eax
   16e2d:	8b 10                	mov    (%eax),%edx
   16e2f:	8b 45 08             	mov    0x8(%ebp),%eax
   16e32:	89 50 04             	mov    %edx,0x4(%eax)
   16e35:	eb 13                	jmp    16e4a <list_insert_first+0x4e>
    }
    else
    {
        // 否则，设置好原本第一个结点的pre
        list->first->prev = node;
   16e37:	8b 45 08             	mov    0x8(%ebp),%eax
   16e3a:	8b 00                	mov    (%eax),%eax
   16e3c:	8b 55 0c             	mov    0xc(%ebp),%edx
   16e3f:	89 50 04             	mov    %edx,0x4(%eax)

        // 调整first指向
        list->first = node;
   16e42:	8b 45 08             	mov    0x8(%ebp),%eax
   16e45:	8b 55 0c             	mov    0xc(%ebp),%edx
   16e48:	89 10                	mov    %edx,(%eax)
    }

    list->count++;
   16e4a:	8b 45 08             	mov    0x8(%ebp),%eax
   16e4d:	8b 40 08             	mov    0x8(%eax),%eax
   16e50:	8d 50 01             	lea    0x1(%eax),%edx
   16e53:	8b 45 08             	mov    0x8(%ebp),%eax
   16e56:	89 50 08             	mov    %edx,0x8(%eax)
}
   16e59:	90                   	nop
   16e5a:	c9                   	leave  
   16e5b:	c3                   	ret    

00016e5c <list_insert_last>:
 * 将指定表项插入到指定链表的尾部
 * @param list 操作的链表
 * @param node 待插入的结点
 */
void list_insert_last(list_t *list, list_node_t *node)
{
   16e5c:	55                   	push   %ebp
   16e5d:	89 e5                	mov    %esp,%ebp
    // 设置好结点本身
    node->prev = list->last;
   16e5f:	8b 45 08             	mov    0x8(%ebp),%eax
   16e62:	8b 50 04             	mov    0x4(%eax),%edx
   16e65:	8b 45 0c             	mov    0xc(%ebp),%eax
   16e68:	89 50 04             	mov    %edx,0x4(%eax)
    node->next = (list_node_t *)0;
   16e6b:	8b 45 0c             	mov    0xc(%ebp),%eax
   16e6e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    // 表空，则first/last都指向唯一的node
    if (list_is_empty(list))
   16e74:	ff 75 08             	pushl  0x8(%ebp)
   16e77:	e8 48 ff ff ff       	call   16dc4 <list_is_empty>
   16e7c:	83 c4 04             	add    $0x4,%esp
   16e7f:	85 c0                	test   %eax,%eax
   16e81:	74 16                	je     16e99 <list_insert_last+0x3d>
    {
        list->first = list->last = node;
   16e83:	8b 45 08             	mov    0x8(%ebp),%eax
   16e86:	8b 55 0c             	mov    0xc(%ebp),%edx
   16e89:	89 50 04             	mov    %edx,0x4(%eax)
   16e8c:	8b 45 08             	mov    0x8(%ebp),%eax
   16e8f:	8b 50 04             	mov    0x4(%eax),%edx
   16e92:	8b 45 08             	mov    0x8(%ebp),%eax
   16e95:	89 10                	mov    %edx,(%eax)
   16e97:	eb 14                	jmp    16ead <list_insert_last+0x51>
    }
    else
    {
        // 否则，调整last结点的向一指向为node
        list->last->next = node;
   16e99:	8b 45 08             	mov    0x8(%ebp),%eax
   16e9c:	8b 40 04             	mov    0x4(%eax),%eax
   16e9f:	8b 55 0c             	mov    0xc(%ebp),%edx
   16ea2:	89 10                	mov    %edx,(%eax)

        // node变成了新的后继结点
        list->last = node;
   16ea4:	8b 45 08             	mov    0x8(%ebp),%eax
   16ea7:	8b 55 0c             	mov    0xc(%ebp),%edx
   16eaa:	89 50 04             	mov    %edx,0x4(%eax)
    }

    list->count++;
   16ead:	8b 45 08             	mov    0x8(%ebp),%eax
   16eb0:	8b 40 08             	mov    0x8(%eax),%eax
   16eb3:	8d 50 01             	lea    0x1(%eax),%edx
   16eb6:	8b 45 08             	mov    0x8(%ebp),%eax
   16eb9:	89 50 08             	mov    %edx,0x8(%eax)
}
   16ebc:	90                   	nop
   16ebd:	c9                   	leave  
   16ebe:	c3                   	ret    

00016ebf <list_remove_first>:

list_node_t *list_remove_first(list_t *list)
{
   16ebf:	55                   	push   %ebp
   16ec0:	89 e5                	mov    %esp,%ebp
   16ec2:	83 ec 10             	sub    $0x10,%esp
    if (list_is_empty(list))
   16ec5:	ff 75 08             	pushl  0x8(%ebp)
   16ec8:	e8 f7 fe ff ff       	call   16dc4 <list_is_empty>
   16ecd:	83 c4 04             	add    $0x4,%esp
   16ed0:	85 c0                	test   %eax,%eax
   16ed2:	74 07                	je     16edb <list_remove_first+0x1c>
    {
        return (list_node_t *)0;
   16ed4:	b8 00 00 00 00       	mov    $0x0,%eax
   16ed9:	eb 5a                	jmp    16f35 <list_remove_first+0x76>
    }

    list_node_t *remove_node = list->first;
   16edb:	8b 45 08             	mov    0x8(%ebp),%eax
   16ede:	8b 00                	mov    (%eax),%eax
   16ee0:	89 45 fc             	mov    %eax,-0x4(%ebp)
    list->first = remove_node->next;
   16ee3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16ee6:	8b 10                	mov    (%eax),%edx
   16ee8:	8b 45 08             	mov    0x8(%ebp),%eax
   16eeb:	89 10                	mov    %edx,(%eax)

    if (list->first == (list_node_t *)0)
   16eed:	8b 45 08             	mov    0x8(%ebp),%eax
   16ef0:	8b 00                	mov    (%eax),%eax
   16ef2:	85 c0                	test   %eax,%eax
   16ef4:	75 0c                	jne    16f02 <list_remove_first+0x43>
    {
        list->last = (list_node_t *)0;
   16ef6:	8b 45 08             	mov    0x8(%ebp),%eax
   16ef9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   16f00:	eb 0c                	jmp    16f0e <list_remove_first+0x4f>
    }
    else
    {
        remove_node->next->prev = (list_node_t *)0;
   16f02:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16f05:	8b 00                	mov    (%eax),%eax
   16f07:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    }

    remove_node->next = remove_node->prev = (list_node_t *)0;
   16f0e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16f11:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   16f18:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16f1b:	8b 50 04             	mov    0x4(%eax),%edx
   16f1e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16f21:	89 10                	mov    %edx,(%eax)

    list->count--;
   16f23:	8b 45 08             	mov    0x8(%ebp),%eax
   16f26:	8b 40 08             	mov    0x8(%eax),%eax
   16f29:	8d 50 ff             	lea    -0x1(%eax),%edx
   16f2c:	8b 45 08             	mov    0x8(%ebp),%eax
   16f2f:	89 50 08             	mov    %edx,0x8(%eax)
    return remove_node;
   16f32:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   16f35:	c9                   	leave  
   16f36:	c3                   	ret    

00016f37 <list_remove>:

list_node_t *list_remove(list_t *list, list_node_t *node)
{
   16f37:	55                   	push   %ebp
   16f38:	89 e5                	mov    %esp,%ebp
    if (node == list->first)
   16f3a:	8b 45 08             	mov    0x8(%ebp),%eax
   16f3d:	8b 00                	mov    (%eax),%eax
   16f3f:	39 45 0c             	cmp    %eax,0xc(%ebp)
   16f42:	75 0a                	jne    16f4e <list_remove+0x17>
    {
        list->first = node->next;
   16f44:	8b 45 0c             	mov    0xc(%ebp),%eax
   16f47:	8b 10                	mov    (%eax),%edx
   16f49:	8b 45 08             	mov    0x8(%ebp),%eax
   16f4c:	89 10                	mov    %edx,(%eax)
    }

    if (node == list->last)
   16f4e:	8b 45 08             	mov    0x8(%ebp),%eax
   16f51:	8b 40 04             	mov    0x4(%eax),%eax
   16f54:	39 45 0c             	cmp    %eax,0xc(%ebp)
   16f57:	75 0c                	jne    16f65 <list_remove+0x2e>
    {
        list->last = node->prev;
   16f59:	8b 45 0c             	mov    0xc(%ebp),%eax
   16f5c:	8b 50 04             	mov    0x4(%eax),%edx
   16f5f:	8b 45 08             	mov    0x8(%ebp),%eax
   16f62:	89 50 04             	mov    %edx,0x4(%eax)
    }

    if (node->prev)
   16f65:	8b 45 0c             	mov    0xc(%ebp),%eax
   16f68:	8b 40 04             	mov    0x4(%eax),%eax
   16f6b:	85 c0                	test   %eax,%eax
   16f6d:	74 0d                	je     16f7c <list_remove+0x45>
    {
        node->prev->next = node->next;
   16f6f:	8b 45 0c             	mov    0xc(%ebp),%eax
   16f72:	8b 40 04             	mov    0x4(%eax),%eax
   16f75:	8b 55 0c             	mov    0xc(%ebp),%edx
   16f78:	8b 12                	mov    (%edx),%edx
   16f7a:	89 10                	mov    %edx,(%eax)
    }

    if (node->next)
   16f7c:	8b 45 0c             	mov    0xc(%ebp),%eax
   16f7f:	8b 00                	mov    (%eax),%eax
   16f81:	85 c0                	test   %eax,%eax
   16f83:	74 0e                	je     16f93 <list_remove+0x5c>
    {
        node->next->prev = node->prev;
   16f85:	8b 45 0c             	mov    0xc(%ebp),%eax
   16f88:	8b 00                	mov    (%eax),%eax
   16f8a:	8b 55 0c             	mov    0xc(%ebp),%edx
   16f8d:	8b 52 04             	mov    0x4(%edx),%edx
   16f90:	89 50 04             	mov    %edx,0x4(%eax)
    }

    node->prev = node->next = (list_node_t *)0;
   16f93:	8b 45 0c             	mov    0xc(%ebp),%eax
   16f96:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   16f9c:	8b 45 0c             	mov    0xc(%ebp),%eax
   16f9f:	8b 10                	mov    (%eax),%edx
   16fa1:	8b 45 0c             	mov    0xc(%ebp),%eax
   16fa4:	89 50 04             	mov    %edx,0x4(%eax)
    list->count--;
   16fa7:	8b 45 08             	mov    0x8(%ebp),%eax
   16faa:	8b 40 08             	mov    0x8(%eax),%eax
   16fad:	8d 50 ff             	lea    -0x1(%eax),%edx
   16fb0:	8b 45 08             	mov    0x8(%ebp),%eax
   16fb3:	89 50 08             	mov    %edx,0x8(%eax)
    return node;
   16fb6:	8b 45 0c             	mov    0xc(%ebp),%eax
   16fb9:	5d                   	pop    %ebp
   16fba:	c3                   	ret    

00016fbb <list_node_prev>:
{
   16fbb:	55                   	push   %ebp
   16fbc:	89 e5                	mov    %esp,%ebp
    return node->prev;
   16fbe:	8b 45 08             	mov    0x8(%ebp),%eax
   16fc1:	8b 40 04             	mov    0x4(%eax),%eax
}
   16fc4:	5d                   	pop    %ebp
   16fc5:	c3                   	ret    

00016fc6 <list_node_next>:
{
   16fc6:	55                   	push   %ebp
   16fc7:	89 e5                	mov    %esp,%ebp
    return node->next;
   16fc9:	8b 45 08             	mov    0x8(%ebp),%eax
   16fcc:	8b 00                	mov    (%eax),%eax
}
   16fce:	5d                   	pop    %ebp
   16fcf:	c3                   	ret    

00016fd0 <log_init>:

/**
 * @brief 初始化日志输出
 */
void log_init(void)
{
   16fd0:	55                   	push   %ebp
   16fd1:	89 e5                	mov    %esp,%ebp
   16fd3:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   16fd6:	83 ec 0c             	sub    $0xc,%esp
   16fd9:	68 78 7e 05 00       	push   $0x57e78
   16fde:	e8 62 f3 ff ff       	call   16345 <mutex_init>
   16fe3:	83 c4 10             	add    $0x10,%esp

    log_dev_id = dev_open(DEV_TTY, 0, (void *)0);
   16fe6:	83 ec 04             	sub    $0x4,%esp
   16fe9:	6a 00                	push   $0x0
   16feb:	6a 00                	push   $0x0
   16fed:	6a 01                	push   $0x1
   16fef:	e8 91 cb ff ff       	call   13b85 <dev_open>
   16ff4:	83 c4 10             	add    $0x10,%esp
   16ff7:	a3 8c 7e 05 00       	mov    %eax,0x57e8c

    // If serial is not faulty set it in normal operation mode
    // (not-loopback with IRQs enabled and OUT#1 and OUT#2 bits enabled)
    outb(COM1_PORT + 4, 0x0F);
#endif
}
   16ffc:	90                   	nop
   16ffd:	c9                   	leave  
   16ffe:	c3                   	ret    

00016fff <log_printf>:

void log_printf(const char *fmt, ...)
{
   16fff:	55                   	push   %ebp
   17000:	89 e5                	mov    %esp,%ebp
   17002:	81 ec 98 00 00 00    	sub    $0x98,%esp
    char str_buf[128];
    va_list args;

    kernel_memset(str_buf,'\0',sizeof(str_buf));
   17008:	83 ec 04             	sub    $0x4,%esp
   1700b:	68 80 00 00 00       	push   $0x80
   17010:	6a 00                	push   $0x0
   17012:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   17018:	50                   	push   %eax
   17019:	e8 05 fa ff ff       	call   16a23 <kernel_memset>
   1701e:	83 c4 10             	add    $0x10,%esp

    va_start(args, fmt);
   17021:	8d 45 0c             	lea    0xc(%ebp),%eax
   17024:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)

    kernel_vsnprintf(str_buf, fmt, args);
   1702a:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
   17030:	83 ec 04             	sub    $0x4,%esp
   17033:	50                   	push   %eax
   17034:	ff 75 08             	pushl  0x8(%ebp)
   17037:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   1703d:	50                   	push   %eax
   1703e:	e8 78 fb ff ff       	call   16bbb <kernel_vsnprintf>
   17043:	83 c4 10             	add    $0x10,%esp

    va_end(args);

    
    // irq_state_t state = irq_enter_protection();
    mutex_lock(&mutex);
   17046:	83 ec 0c             	sub    $0xc,%esp
   17049:	68 78 7e 05 00       	push   $0x57e78
   1704e:	e8 20 f3 ff ff       	call   16373 <mutex_lock>
   17053:	83 c4 10             	add    $0x10,%esp

    // irq_leave_protection(state);
    
#else
    // console_write(0, str_buf, kernel_strlen(str_buf));
    dev_write(log_dev_id, 0, str_buf, kernel_strlen(str_buf));
   17056:	83 ec 0c             	sub    $0xc,%esp
   17059:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   1705f:	50                   	push   %eax
   17060:	e8 3a f9 ff ff       	call   1699f <kernel_strlen>
   17065:	83 c4 10             	add    $0x10,%esp
   17068:	89 c2                	mov    %eax,%edx
   1706a:	a1 8c 7e 05 00       	mov    0x57e8c,%eax
   1706f:	52                   	push   %edx
   17070:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
   17076:	52                   	push   %edx
   17077:	6a 00                	push   $0x0
   17079:	50                   	push   %eax
   1707a:	e8 dd cc ff ff       	call   13d5c <dev_write>
   1707f:	83 c4 10             	add    $0x10,%esp
    char c = '\n';
   17082:	c6 85 73 ff ff ff 0a 	movb   $0xa,-0x8d(%ebp)
    //console_write(0, &c, 1);
    dev_write(log_dev_id, 0, &c, 1);
   17089:	a1 8c 7e 05 00       	mov    0x57e8c,%eax
   1708e:	6a 01                	push   $0x1
   17090:	8d 95 73 ff ff ff    	lea    -0x8d(%ebp),%edx
   17096:	52                   	push   %edx
   17097:	6a 00                	push   $0x0
   17099:	50                   	push   %eax
   1709a:	e8 bd cc ff ff       	call   13d5c <dev_write>
   1709f:	83 c4 10             	add    $0x10,%esp

#endif
    mutex_unlock(&mutex);
   170a2:	83 ec 0c             	sub    $0xc,%esp
   170a5:	68 78 7e 05 00       	push   $0x57e78
   170aa:	e8 5b f3 ff ff       	call   1640a <mutex_unlock>
   170af:	83 c4 10             	add    $0x10,%esp
}
   170b2:	90                   	nop
   170b3:	c9                   	leave  
   170b4:	c3                   	ret    

Disassembly of section .first_task:

80000000 <first_task_entry>:
 	.text
 	.global first_task_entry
	.extern first_task_main
first_task_entry:
    // 需要重新加载各数据段
    mov %ss, %ax
80000000:	66 8c d0             	mov    %ss,%ax
    mov %ax, %ds
80000003:	8e d8                	mov    %eax,%ds
    mov %ax, %es
80000005:	8e c0                	mov    %eax,%es
    mov %ax, %fs
80000007:	8e e0                	mov    %eax,%fs
    mov %ax, %gs
80000009:	8e e8                	mov    %eax,%gs
    jmp first_task_main
8000000b:	e9 15 00 00 00       	jmp    80000025 <first_task_main>

80000010 <list_node_prev>:
{
80000010:	55                   	push   %ebp
80000011:	89 e5                	mov    %esp,%ebp
    return node->prev;
80000013:	8b 45 08             	mov    0x8(%ebp),%eax
80000016:	8b 40 04             	mov    0x4(%eax),%eax
}
80000019:	5d                   	pop    %ebp
8000001a:	c3                   	ret    

8000001b <list_node_next>:
{
8000001b:	55                   	push   %ebp
8000001c:	89 e5                	mov    %esp,%ebp
    return node->next;
8000001e:	8b 45 08             	mov    0x8(%ebp),%eax
80000021:	8b 00                	mov    (%eax),%eax
}
80000023:	5d                   	pop    %ebp
80000024:	c3                   	ret    

80000025 <first_task_main>:
#include "applib/lib_syscall.h"
#include "dev/tty.h"
int first_task_main(void)
{
80000025:	55                   	push   %ebp
80000026:	89 e5                	mov    %esp,%ebp
80000028:	83 ec 28             	sub    $0x28,%esp
    {
        print_msg("child task id=%d", pid);
        print_msg("parent: %d", count);
    }
#endif
    for (int i = 0; i < TTY_NR; i++)
8000002b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
80000032:	e9 90 00 00 00       	jmp    800000c7 <first_task_main+0xa2>
    {
        int pid = fork();
80000037:	e8 67 01 00 00       	call   800001a3 <fork>
8000003c:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (pid < 0)
8000003f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
80000043:	79 14                	jns    80000059 <first_task_main+0x34>
        {
            print_msg("create shell proc failed", 0);
80000045:	83 ec 08             	sub    $0x8,%esp
80000048:	6a 00                	push   $0x0
8000004a:	68 d4 83 01 00       	push   $0x183d4
8000004f:	e8 27 01 00 00       	call   8000017b <print_msg>
80000054:	83 c4 10             	add    $0x10,%esp
            break;
80000057:	eb 78                	jmp    800000d1 <first_task_main+0xac>
        }
        else if (pid == 0)
80000059:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
8000005d:	75 64                	jne    800000c3 <first_task_main+0x9e>
        {
            // 子进程
            char tty_num[] = "/dev/tty?";
8000005f:	c7 45 e6 2f 64 65 76 	movl   $0x7665642f,-0x1a(%ebp)
80000066:	c7 45 ea 2f 74 74 79 	movl   $0x7974742f,-0x16(%ebp)
8000006d:	66 c7 45 ee 3f 00    	movw   $0x3f,-0x12(%ebp)
            tty_num[sizeof(tty_num) - 2] = i + '0';
80000073:	8b 45 f4             	mov    -0xc(%ebp),%eax
80000076:	83 c0 30             	add    $0x30,%eax
80000079:	88 45 ee             	mov    %al,-0x12(%ebp)
            char *argv[] = {tty_num, (char *)0};
8000007c:	8d 45 e6             	lea    -0x1a(%ebp),%eax
8000007f:	89 45 dc             	mov    %eax,-0x24(%ebp)
80000082:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
            execve("/shell.elf", argv, (char **)0);
80000089:	83 ec 04             	sub    $0x4,%esp
8000008c:	6a 00                	push   $0x0
8000008e:	8d 45 dc             	lea    -0x24(%ebp),%eax
80000091:	50                   	push   %eax
80000092:	68 ed 83 01 00       	push   $0x183ed
80000097:	e8 22 01 00 00       	call   800001be <execve>
8000009c:	83 c4 10             	add    $0x10,%esp
            print_msg("create shell proc failed", 0);
8000009f:	83 ec 08             	sub    $0x8,%esp
800000a2:	6a 00                	push   $0x0
800000a4:	68 d4 83 01 00       	push   $0x183d4
800000a9:	e8 cd 00 00 00       	call   8000017b <print_msg>
800000ae:	83 c4 10             	add    $0x10,%esp
            while (1)
            {
                msleep(10000);
800000b1:	83 ec 0c             	sub    $0xc,%esp
800000b4:	68 10 27 00 00       	push   $0x2710
800000b9:	e8 78 00 00 00       	call   80000136 <msleep>
800000be:	83 c4 10             	add    $0x10,%esp
800000c1:	eb ee                	jmp    800000b1 <first_task_main+0x8c>
    for (int i = 0; i < TTY_NR; i++)
800000c3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
800000c7:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
800000cb:	0f 8e 66 ff ff ff    	jle    80000037 <first_task_main+0x12>
        }
    }

    while (1)
    {
        msleep(10000);
800000d1:	83 ec 0c             	sub    $0xc,%esp
800000d4:	68 10 27 00 00       	push   $0x2710
800000d9:	e8 58 00 00 00       	call   80000136 <msleep>
800000de:	83 c4 10             	add    $0x10,%esp
800000e1:	eb ee                	jmp    800000d1 <first_task_main+0xac>

800000e3 <sys_call>:
    int arg2;
    int arg3;
} sycall_args_t;

static inline int sys_call(sycall_args_t *args)
{
800000e3:	55                   	push   %ebp
800000e4:	89 e5                	mov    %esp,%ebp
800000e6:	57                   	push   %edi
800000e7:	56                   	push   %esi
800000e8:	53                   	push   %ebx
800000e9:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[] = {0, SELECTOR_SYSCALL | 0};
800000ec:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
800000f3:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%ebp)

    int ret = 0;
800000fa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        "push %[arg2]\n\t"
        "push %[arg1]\n\t"
        "push %[arg0]\n\t"
        "push %[id]\n\t"
        "lcall *(%[a])" : "=a"(ret) :
        [arg3] "r"(args->arg3),
80000101:	8b 45 08             	mov    0x8(%ebp),%eax
80000104:	8b 40 10             	mov    0x10(%eax),%eax
        [arg2] "r"(args->arg2),
80000107:	8b 55 08             	mov    0x8(%ebp),%edx
8000010a:	8b 52 0c             	mov    0xc(%edx),%edx
        [arg1] "r"(args->arg1),
8000010d:	8b 4d 08             	mov    0x8(%ebp),%ecx
80000110:	8b 49 08             	mov    0x8(%ecx),%ecx
        [arg0] "r"(args->arg0),
80000113:	8b 5d 08             	mov    0x8(%ebp),%ebx
80000116:	8b 5b 04             	mov    0x4(%ebx),%ebx
        [id] "r"(args->id),
80000119:	8b 75 08             	mov    0x8(%ebp),%esi
8000011c:	8b 36                	mov    (%esi),%esi
    __asm__ __volatile__(
8000011e:	8d 7d e8             	lea    -0x18(%ebp),%edi
80000121:	50                   	push   %eax
80000122:	52                   	push   %edx
80000123:	51                   	push   %ecx
80000124:	53                   	push   %ebx
80000125:	56                   	push   %esi
80000126:	ff 1f                	lcall  *(%edi)
80000128:	89 45 f0             	mov    %eax,-0x10(%ebp)
        [a] "r"(addr));
    return ret;
8000012b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
8000012e:	83 c4 10             	add    $0x10,%esp
80000131:	5b                   	pop    %ebx
80000132:	5e                   	pop    %esi
80000133:	5f                   	pop    %edi
80000134:	5d                   	pop    %ebp
80000135:	c3                   	ret    

80000136 <msleep>:


#include "lib_syscall.h"

void msleep(int ms)
{
80000136:	55                   	push   %ebp
80000137:	89 e5                	mov    %esp,%ebp
80000139:	83 ec 20             	sub    $0x20,%esp
    if (ms <= 0)
8000013c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
80000140:	7e 1b                	jle    8000015d <msleep+0x27>
        return;
    sycall_args_t args;
    args.id = SYS_sleep;
80000142:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    args.arg0 = ms;
80000149:	8b 45 08             	mov    0x8(%ebp),%eax
8000014c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    sys_call(&args);
8000014f:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000152:	50                   	push   %eax
80000153:	e8 8b ff ff ff       	call   800000e3 <sys_call>
80000158:	83 c4 04             	add    $0x4,%esp
8000015b:	eb 01                	jmp    8000015e <msleep+0x28>
        return;
8000015d:	90                   	nop
}
8000015e:	c9                   	leave  
8000015f:	c3                   	ret    

80000160 <getpid>:

int getpid(void)
{
80000160:	55                   	push   %ebp
80000161:	89 e5                	mov    %esp,%ebp
80000163:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_getpid;
80000166:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
    return sys_call(&args);
8000016d:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000170:	50                   	push   %eax
80000171:	e8 6d ff ff ff       	call   800000e3 <sys_call>
80000176:	83 c4 04             	add    $0x4,%esp
}
80000179:	c9                   	leave  
8000017a:	c3                   	ret    

8000017b <print_msg>:

void print_msg(const char *fmt, int arg)
{
8000017b:	55                   	push   %ebp
8000017c:	89 e5                	mov    %esp,%ebp
8000017e:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_printmsg;
80000181:	c7 45 ec 64 00 00 00 	movl   $0x64,-0x14(%ebp)
    args.arg0 = (int)fmt;
80000188:	8b 45 08             	mov    0x8(%ebp),%eax
8000018b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = arg;
8000018e:	8b 45 0c             	mov    0xc(%ebp),%eax
80000191:	89 45 f4             	mov    %eax,-0xc(%ebp)
    sys_call(&args);
80000194:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000197:	50                   	push   %eax
80000198:	e8 46 ff ff ff       	call   800000e3 <sys_call>
8000019d:	83 c4 04             	add    $0x4,%esp
}
800001a0:	90                   	nop
800001a1:	c9                   	leave  
800001a2:	c3                   	ret    

800001a3 <fork>:
int fork()
{
800001a3:	55                   	push   %ebp
800001a4:	89 e5                	mov    %esp,%ebp
800001a6:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_fork;
800001a9:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
    return sys_call(&args);
800001b0:	8d 45 ec             	lea    -0x14(%ebp),%eax
800001b3:	50                   	push   %eax
800001b4:	e8 2a ff ff ff       	call   800000e3 <sys_call>
800001b9:	83 c4 04             	add    $0x4,%esp
}
800001bc:	c9                   	leave  
800001bd:	c3                   	ret    

800001be <execve>:

int execve(const char *name, char *const *argv, char *const *env)
{
800001be:	55                   	push   %ebp
800001bf:	89 e5                	mov    %esp,%ebp
800001c1:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_execve;
800001c4:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
    args.arg0 = (int)name;
800001cb:	8b 45 08             	mov    0x8(%ebp),%eax
800001ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)argv;
800001d1:	8b 45 0c             	mov    0xc(%ebp),%eax
800001d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = (int)env;
800001d7:	8b 45 10             	mov    0x10(%ebp),%eax
800001da:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return sys_call(&args);
800001dd:	8d 45 ec             	lea    -0x14(%ebp),%eax
800001e0:	50                   	push   %eax
800001e1:	e8 fd fe ff ff       	call   800000e3 <sys_call>
800001e6:	83 c4 04             	add    $0x4,%esp
}
800001e9:	c9                   	leave  
800001ea:	c3                   	ret    

800001eb <yield>:

int yield()
{
800001eb:	55                   	push   %ebp
800001ec:	89 e5                	mov    %esp,%ebp
800001ee:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_yield;
800001f1:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%ebp)
    return sys_call(&args);
800001f8:	8d 45 ec             	lea    -0x14(%ebp),%eax
800001fb:	50                   	push   %eax
800001fc:	e8 e2 fe ff ff       	call   800000e3 <sys_call>
80000201:	83 c4 04             	add    $0x4,%esp
}
80000204:	c9                   	leave  
80000205:	c3                   	ret    

80000206 <open>:

int open(const char *name, int flags, ...)
{
80000206:	55                   	push   %ebp
80000207:	89 e5                	mov    %esp,%ebp
80000209:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_open;
8000020c:	c7 45 ec 32 00 00 00 	movl   $0x32,-0x14(%ebp)
    args.arg0 = (int)name;
80000213:	8b 45 08             	mov    0x8(%ebp),%eax
80000216:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)flags;
80000219:	8b 45 0c             	mov    0xc(%ebp),%eax
8000021c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return sys_call(&args);
8000021f:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000222:	50                   	push   %eax
80000223:	e8 bb fe ff ff       	call   800000e3 <sys_call>
80000228:	83 c4 04             	add    $0x4,%esp
}
8000022b:	c9                   	leave  
8000022c:	c3                   	ret    

8000022d <read>:
int read(int file, char *ptr, int len)
{
8000022d:	55                   	push   %ebp
8000022e:	89 e5                	mov    %esp,%ebp
80000230:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_read;
80000233:	c7 45 ec 33 00 00 00 	movl   $0x33,-0x14(%ebp)
    args.arg0 = (int)file;
8000023a:	8b 45 08             	mov    0x8(%ebp),%eax
8000023d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)ptr;
80000240:	8b 45 0c             	mov    0xc(%ebp),%eax
80000243:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = (int)len;
80000246:	8b 45 10             	mov    0x10(%ebp),%eax
80000249:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return sys_call(&args);
8000024c:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000024f:	50                   	push   %eax
80000250:	e8 8e fe ff ff       	call   800000e3 <sys_call>
80000255:	83 c4 04             	add    $0x4,%esp
}
80000258:	c9                   	leave  
80000259:	c3                   	ret    

8000025a <write>:
int write(int file, const char *ptr, int len)
{
8000025a:	55                   	push   %ebp
8000025b:	89 e5                	mov    %esp,%ebp
8000025d:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_write;
80000260:	c7 45 ec 34 00 00 00 	movl   $0x34,-0x14(%ebp)
    args.arg0 = (int)file;
80000267:	8b 45 08             	mov    0x8(%ebp),%eax
8000026a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)ptr;
8000026d:	8b 45 0c             	mov    0xc(%ebp),%eax
80000270:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = (int)len;
80000273:	8b 45 10             	mov    0x10(%ebp),%eax
80000276:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return sys_call(&args);
80000279:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000027c:	50                   	push   %eax
8000027d:	e8 61 fe ff ff       	call   800000e3 <sys_call>
80000282:	83 c4 04             	add    $0x4,%esp
}
80000285:	c9                   	leave  
80000286:	c3                   	ret    

80000287 <close>:
int close(int file)
{
80000287:	55                   	push   %ebp
80000288:	89 e5                	mov    %esp,%ebp
8000028a:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_close;
8000028d:	c7 45 ec 35 00 00 00 	movl   $0x35,-0x14(%ebp)
    args.arg0 = (int)file;
80000294:	8b 45 08             	mov    0x8(%ebp),%eax
80000297:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return sys_call(&args);
8000029a:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000029d:	50                   	push   %eax
8000029e:	e8 40 fe ff ff       	call   800000e3 <sys_call>
800002a3:	83 c4 04             	add    $0x4,%esp
}
800002a6:	c9                   	leave  
800002a7:	c3                   	ret    

800002a8 <lseek>:
int lseek(int file, int ptr, int dir)
{
800002a8:	55                   	push   %ebp
800002a9:	89 e5                	mov    %esp,%ebp
800002ab:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_lseek;
800002ae:	c7 45 ec 36 00 00 00 	movl   $0x36,-0x14(%ebp)
    args.arg0 = (int)file;
800002b5:	8b 45 08             	mov    0x8(%ebp),%eax
800002b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)ptr;
800002bb:	8b 45 0c             	mov    0xc(%ebp),%eax
800002be:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = (int)dir;
800002c1:	8b 45 10             	mov    0x10(%ebp),%eax
800002c4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return sys_call(&args);
800002c7:	8d 45 ec             	lea    -0x14(%ebp),%eax
800002ca:	50                   	push   %eax
800002cb:	e8 13 fe ff ff       	call   800000e3 <sys_call>
800002d0:	83 c4 04             	add    $0x4,%esp
}
800002d3:	c9                   	leave  
800002d4:	c3                   	ret    

800002d5 <isatty>:

int isatty(int file)
{
800002d5:	55                   	push   %ebp
800002d6:	89 e5                	mov    %esp,%ebp
800002d8:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_isatty;
800002db:	c7 45 ec 37 00 00 00 	movl   $0x37,-0x14(%ebp)
    args.arg0 = (int)file;
800002e2:	8b 45 08             	mov    0x8(%ebp),%eax
800002e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return sys_call(&args);
800002e8:	8d 45 ec             	lea    -0x14(%ebp),%eax
800002eb:	50                   	push   %eax
800002ec:	e8 f2 fd ff ff       	call   800000e3 <sys_call>
800002f1:	83 c4 04             	add    $0x4,%esp
}
800002f4:	c9                   	leave  
800002f5:	c3                   	ret    

800002f6 <fstat>:
int fstat(int file, struct stat *st)
{
800002f6:	55                   	push   %ebp
800002f7:	89 e5                	mov    %esp,%ebp
800002f9:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_fstat;
800002fc:	c7 45 ec 38 00 00 00 	movl   $0x38,-0x14(%ebp)
    args.arg0 = (int)file;
80000303:	8b 45 08             	mov    0x8(%ebp),%eax
80000306:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)st;
80000309:	8b 45 0c             	mov    0xc(%ebp),%eax
8000030c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return sys_call(&args);
8000030f:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000312:	50                   	push   %eax
80000313:	e8 cb fd ff ff       	call   800000e3 <sys_call>
80000318:	83 c4 04             	add    $0x4,%esp
}
8000031b:	c9                   	leave  
8000031c:	c3                   	ret    

8000031d <sbrk>:

void *sbrk(ptrdiff_t incr)
{
8000031d:	55                   	push   %ebp
8000031e:	89 e5                	mov    %esp,%ebp
80000320:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_sbrk;
80000323:	c7 45 ec 39 00 00 00 	movl   $0x39,-0x14(%ebp)
    args.arg0 = (int)incr;
8000032a:	8b 45 08             	mov    0x8(%ebp),%eax
8000032d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return (void *)sys_call(&args);
80000330:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000333:	50                   	push   %eax
80000334:	e8 aa fd ff ff       	call   800000e3 <sys_call>
80000339:	83 c4 04             	add    $0x4,%esp
}
8000033c:	c9                   	leave  
8000033d:	c3                   	ret    

8000033e <dup>:

int dup(int file)
{
8000033e:	55                   	push   %ebp
8000033f:	89 e5                	mov    %esp,%ebp
80000341:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_dup;
80000344:	c7 45 ec 3a 00 00 00 	movl   $0x3a,-0x14(%ebp)
    args.arg0 = (int)file;
8000034b:	8b 45 08             	mov    0x8(%ebp),%eax
8000034e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return sys_call(&args);
80000351:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000354:	50                   	push   %eax
80000355:	e8 89 fd ff ff       	call   800000e3 <sys_call>
8000035a:	83 c4 04             	add    $0x4,%esp
}
8000035d:	c9                   	leave  
8000035e:	c3                   	ret    

8000035f <_exit>:

void _exit(int status)
{
8000035f:	55                   	push   %ebp
80000360:	89 e5                	mov    %esp,%ebp
80000362:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_exit;
80000365:	c7 45 ec 3b 00 00 00 	movl   $0x3b,-0x14(%ebp)
    args.arg0 = status;
8000036c:	8b 45 08             	mov    0x8(%ebp),%eax
8000036f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    sys_call(&args);
80000372:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000375:	50                   	push   %eax
80000376:	e8 68 fd ff ff       	call   800000e3 <sys_call>
8000037b:	83 c4 04             	add    $0x4,%esp
    while(1);
8000037e:	eb fe                	jmp    8000037e <_exit+0x1f>

80000380 <wait>:
}

int wait(int *status)
{
80000380:	55                   	push   %ebp
80000381:	89 e5                	mov    %esp,%ebp
80000383:	83 ec 20             	sub    $0x20,%esp
    sycall_args_t args;
    args.id = SYS_wait;
80000386:	c7 45 ec 3c 00 00 00 	movl   $0x3c,-0x14(%ebp)
    args.arg0 = (int)status;
8000038d:	8b 45 08             	mov    0x8(%ebp),%eax
80000390:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return sys_call(&args);
80000393:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000396:	50                   	push   %eax
80000397:	e8 47 fd ff ff       	call   800000e3 <sys_call>
8000039c:	83 c4 04             	add    $0x4,%esp
8000039f:	c9                   	leave  
800003a0:	c3                   	ret    
